From d3892466bc961cc9c80e2b8ea75340920292502c Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jallison@ciq.com>
Date: Thu, 4 Apr 2024 18:04:39 -0700
Subject: [PATCH 05/09] CVE-2023-42669.patch

---
 .../protocol/dcerpcendpointservers.xml        |    2 +-
 lib/param/loadparm.c                          |    2 +-
 lib/param/loadparm.c.orig                     | 3749 +++++++++++++
 selftest/target/Samba4.pm                     |    2 +-
 selftest/target/Samba4.pm.orig                | 3662 +++++++++++++
 source3/param/loadparm.c                      |    2 +-
 source3/param/loadparm.c.orig                 | 4837 +++++++++++++++++
 source4/rpc_server/wscript_build              |    3 +-
 8 files changed, 12254 insertions(+), 5 deletions(-)
 create mode 100644 lib/param/loadparm.c.orig
 create mode 100755 selftest/target/Samba4.pm.orig
 create mode 100644 source3/param/loadparm.c.orig

diff --git a/docs-xml/smbdotconf/protocol/dcerpcendpointservers.xml b/docs-xml/smbdotconf/protocol/dcerpcendpointservers.xml
index 8a217cc..c6642b7 100644
--- a/docs-xml/smbdotconf/protocol/dcerpcendpointservers.xml
+++ b/docs-xml/smbdotconf/protocol/dcerpcendpointservers.xml
@@ -6,6 +6,6 @@
 	<para>Specifies which DCE/RPC endpoint servers should be run.</para>
 </description>
 
-<value type="default">epmapper, wkssvc, rpcecho, samr, netlogon, lsarpc, drsuapi, dssetup, unixinfo, browser, eventlog6, backupkey, dnsserver</value>
+<value type="default">epmapper, wkssvc, samr, netlogon, lsarpc, drsuapi, dssetup, unixinfo, browser, eventlog6, backupkey, dnsserver</value>
 <value type="example">rpcecho</value>
 </samba:parameter>
diff --git a/lib/param/loadparm.c b/lib/param/loadparm.c
index fc0dc4d..38de1d2 100644
--- a/lib/param/loadparm.c
+++ b/lib/param/loadparm.c
@@ -2732,7 +2732,7 @@ struct loadparm_context *loadparm_init(TALLOC_CTX *mem_ctx)
 	lpcfg_do_global_parameter(lp_ctx, "ntvfs handler", "unixuid default");
 	lpcfg_do_global_parameter(lp_ctx, "max connections", "0");
 
-	lpcfg_do_global_parameter(lp_ctx, "dcerpc endpoint servers", "epmapper wkssvc rpcecho samr netlogon lsarpc drsuapi dssetup unixinfo browser eventlog6 backupkey dnsserver");
+	lpcfg_do_global_parameter(lp_ctx, "dcerpc endpoint servers", "epmapper wkssvc samr netlogon lsarpc drsuapi dssetup unixinfo browser eventlog6 backupkey dnsserver");
 	lpcfg_do_global_parameter(lp_ctx, "server services", "s3fs rpc nbt wrepl ldap cldap kdc drepl winbindd ntp_signd kcc dnsupdate dns");
 	lpcfg_do_global_parameter(lp_ctx, "kccsrv:samba_kcc", "true");
 	/* the winbind method for domain controllers is for both RODC
diff --git a/lib/param/loadparm.c.orig b/lib/param/loadparm.c.orig
new file mode 100644
index 0000000..fc0dc4d
--- /dev/null
+++ b/lib/param/loadparm.c.orig
@@ -0,0 +1,3749 @@
+/* 
+   Unix SMB/CIFS implementation.
+   Parameter loading functions
+   Copyright (C) Karl Auer 1993-1998
+
+   Largely re-written by Andrew Tridgell, September 1994
+
+   Copyright (C) Simo Sorce 2001
+   Copyright (C) Alexander Bokovoy 2002
+   Copyright (C) Stefan (metze) Metzmacher 2002
+   Copyright (C) Jim McDonough (jmcd@us.ibm.com)  2003.
+   Copyright (C) James Myers 2003 <myersjj@samba.org>
+   Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007
+   Copyright (C) Andrew Bartlett 2011-2012
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*
+ *  Load parameters.
+ *
+ *  This module provides suitable callback functions for the params
+ *  module. It builds the internal table of service details which is
+ *  then used by the rest of the server.
+ *
+ * To add a parameter:
+ *
+ * 1) add it to the global or service structure definition
+ * 2) add it to the parm_table
+ * 3) add it to the list of available functions (eg: using FN_GLOBAL_STRING())
+ * 4) If it's a global then initialise it in init_globals. If a local
+ *    (ie. service) parameter then initialise it in the sDefault structure
+ *
+ *
+ * Notes:
+ *   The configuration file is processed sequentially for speed. It is NOT
+ *   accessed randomly as happens in 'real' Windows. For this reason, there
+ *   is a fair bit of sequence-dependent code here - ie., code which assumes
+ *   that certain things happen before others. In particular, the code which
+ *   happens at the boundary between sections is delicately poised, so be
+ *   careful!
+ *
+ */
+
+#include "includes.h"
+#include "version.h"
+#include "dynconfig/dynconfig.h"
+#include "system/time.h"
+#include "system/locale.h"
+#include "system/network.h" /* needed for TCP_NODELAY */
+#include "../lib/util/dlinklist.h"
+#include "lib/param/param.h"
+#define LOADPARM_SUBSTITUTION_INTERNALS 1
+#include "lib/param/loadparm.h"
+#include "auth/gensec/gensec.h"
+#include "lib/param/s3_param.h"
+#include "lib/util/bitmap.h"
+#include "libcli/smb/smb_constants.h"
+#include "tdb.h"
+#include "librpc/gen_ndr/nbt.h"
+#include "librpc/gen_ndr/dns.h"
+#include "librpc/gen_ndr/security.h"
+#include "libds/common/roles.h"
+#include "lib/util/samba_util.h"
+#include "libcli/auth/ntlm_check.h"
+#include "lib/crypto/gnutls_helpers.h"
+#include "lib/util/smb_strtox.h"
+#include "auth/credentials/credentials.h"
+
+#ifdef HAVE_HTTPCONNECTENCRYPT
+#include <cups/http.h>
+#endif
+
+#define standard_sub_basic talloc_strdup
+
+#include "lib/param/param_global.h"
+
+struct loadparm_service *lpcfg_default_service(struct loadparm_context *lp_ctx)
+{
+	return lp_ctx->sDefault;
+}
+
+int lpcfg_rpc_low_port(struct loadparm_context *lp_ctx)
+{
+	return lp_ctx->globals->rpc_low_port;
+}
+
+int lpcfg_rpc_high_port(struct loadparm_context *lp_ctx)
+{
+	return lp_ctx->globals->rpc_high_port;
+}
+
+enum samba_weak_crypto lpcfg_weak_crypto(struct loadparm_context *lp_ctx)
+{
+	if (lp_ctx->globals->weak_crypto == SAMBA_WEAK_CRYPTO_UNKNOWN) {
+		lp_ctx->globals->weak_crypto = SAMBA_WEAK_CRYPTO_DISALLOWED;
+
+		if (samba_gnutls_weak_crypto_allowed()) {
+			lp_ctx->globals->weak_crypto = SAMBA_WEAK_CRYPTO_ALLOWED;
+		}
+	}
+
+	return lp_ctx->globals->weak_crypto;
+}
+
+/**
+ * Convenience routine to grab string parameters into temporary memory
+ * and run standard_sub_basic on them.
+ *
+ * The buffers can be written to by
+ * callers without affecting the source string.
+ */
+
+static const char *lpcfg_string(const char *s)
+{
+#if 0  /* until REWRITE done to make thread-safe */
+	size_t len = s ? strlen(s) : 0;
+	char *ret;
+#endif
+
+	/* The follow debug is useful for tracking down memory problems
+	   especially if you have an inner loop that is calling a lp_*()
+	   function that returns a string.  Perhaps this debug should be
+	   present all the time? */
+
+#if 0
+	DEBUG(10, ("lpcfg_string(%s)\n", s));
+#endif
+
+#if 0  /* until REWRITE done to make thread-safe */
+	if (!lp_talloc)
+		lp_talloc = talloc_init("lp_talloc");
+
+	ret = talloc_array(lp_talloc, char, len + 100);	/* leave room for substitution */
+
+	if (!ret)
+		return NULL;
+
+	if (!s)
+		*ret = 0;
+	else
+		strlcpy(ret, s, len);
+
+	if (trim_string(ret, "\"", "\"")) {
+		if (strchr(ret,'"') != NULL)
+			strlcpy(ret, s, len);
+	}
+
+	standard_sub_basic(ret,len+100);
+	return (ret);
+#endif
+	return s;
+}
+
+/*
+   In this section all the functions that are used to access the
+   parameters from the rest of the program are defined
+*/
+
+/*
+ * the creation of separate lpcfg_*() and lp_*() functions is to allow
+ * for code compatibility between existing Samba4 and Samba3 code.
+ */
+
+/* this global context supports the lp_*() function varients */
+static struct loadparm_context *global_loadparm_context;
+
+#define FN_GLOBAL_SUBSTITUTED_STRING(fn_name,var_name) \
+ _PUBLIC_ char *lpcfg_ ## fn_name(struct loadparm_context *lp_ctx, \
+		 const struct loadparm_substitution *lp_sub, TALLOC_CTX *mem_ctx) \
+{ \
+	 if (lp_ctx == NULL) return NULL;				\
+	 return lpcfg_substituted_string(mem_ctx, lp_sub, \
+			 lp_ctx->globals->var_name ? lp_ctx->globals->var_name : ""); \
+}
+
+#define FN_GLOBAL_CONST_STRING(fn_name,var_name)				\
+ _PUBLIC_ const char *lpcfg_ ## fn_name(struct loadparm_context *lp_ctx) { \
+	if (lp_ctx == NULL) return NULL;				\
+	return lp_ctx->globals->var_name ? lpcfg_string(lp_ctx->globals->var_name) : ""; \
+}
+
+#define FN_GLOBAL_LIST(fn_name,var_name)				\
+ _PUBLIC_ const char **lpcfg_ ## fn_name(struct loadparm_context *lp_ctx) { \
+	 if (lp_ctx == NULL) return NULL;				\
+	 return lp_ctx->globals->var_name;				\
+ }
+
+#define FN_GLOBAL_BOOL(fn_name,var_name) \
+ _PUBLIC_ bool lpcfg_ ## fn_name(struct loadparm_context *lp_ctx) {\
+	 if (lp_ctx == NULL) return false;				\
+	 return lp_ctx->globals->var_name;				\
+}
+
+#define FN_GLOBAL_INTEGER(fn_name,var_name) \
+ _PUBLIC_ int lpcfg_ ## fn_name(struct loadparm_context *lp_ctx) { \
+	 return lp_ctx->globals->var_name;				\
+ }
+
+/* Local parameters don't need the ->s3_fns because the struct
+ * loadparm_service is shared and lpcfg_service() checks the ->s3_fns
+ * hook */
+#define FN_LOCAL_SUBSTITUTED_STRING(fn_name,val) \
+ _PUBLIC_ char *lpcfg_ ## fn_name(struct loadparm_service *service, \
+					struct loadparm_service *sDefault, TALLOC_CTX *ctx) { \
+	 return(talloc_strdup(ctx, lpcfg_string((const char *)((service != NULL && service->val != NULL) ? service->val : sDefault->val)))); \
+ }
+
+#define FN_LOCAL_CONST_STRING(fn_name,val) \
+ _PUBLIC_ const char *lpcfg_ ## fn_name(struct loadparm_service *service, \
+					struct loadparm_service *sDefault) { \
+	 return((const char *)((service != NULL && service->val != NULL) ? service->val : sDefault->val)); \
+ }
+
+#define FN_LOCAL_LIST(fn_name,val) \
+ _PUBLIC_ const char **lpcfg_ ## fn_name(struct loadparm_service *service, \
+					 struct loadparm_service *sDefault) {\
+	 return(const char **)(service != NULL && service->val != NULL? service->val : sDefault->val); \
+ }
+
+#define FN_LOCAL_PARM_BOOL(fn_name, val) FN_LOCAL_BOOL(fn_name, val)
+
+#define FN_LOCAL_BOOL(fn_name,val) \
+ _PUBLIC_ bool lpcfg_ ## fn_name(struct loadparm_service *service, \
+				 struct loadparm_service *sDefault) {	\
+	 return((service != NULL)? service->val : sDefault->val); \
+ }
+
+#define FN_LOCAL_INTEGER(fn_name,val) \
+ _PUBLIC_ int lpcfg_ ## fn_name(struct loadparm_service *service, \
+				struct loadparm_service *sDefault) {	\
+	 return((service != NULL)? service->val : sDefault->val); \
+ }
+
+#define FN_LOCAL_PARM_INTEGER(fn_name, val) FN_LOCAL_INTEGER(fn_name, val)
+
+#define FN_LOCAL_CHAR(fn_name,val) \
+ _PUBLIC_ char lpcfg_ ## fn_name(struct loadparm_service *service, \
+				struct loadparm_service *sDefault) {	\
+	 return((service != NULL)? service->val : sDefault->val); \
+ }
+
+#define FN_LOCAL_PARM_CHAR(fn_name,val) FN_LOCAL_CHAR(fn_name, val)
+
+#include "lib/param/param_functions.c"
+
+/* These functions cannot be auto-generated */
+FN_LOCAL_BOOL(autoloaded, autoloaded)
+FN_GLOBAL_CONST_STRING(dnsdomain, dnsdomain)
+
+/* local prototypes */
+static struct loadparm_service *lpcfg_getservicebyname(struct loadparm_context *lp_ctx,
+					const char *pszServiceName);
+static bool do_section(const char *pszSectionName, void *);
+static bool set_variable_helper(TALLOC_CTX *mem_ctx, int parmnum, void *parm_ptr,
+				const char *pszParmName, const char *pszParmValue);
+static bool lp_do_parameter_parametric(struct loadparm_context *lp_ctx,
+				       struct loadparm_service *service,
+				       const char *pszParmName,
+				       const char *pszParmValue, int flags);
+
+/* The following are helper functions for parametrical options support. */
+/* It returns a pointer to parametrical option value if it exists or NULL otherwise */
+/* Actual parametrical functions are quite simple */
+struct parmlist_entry *get_parametric_helper(struct loadparm_service *service,
+					     const char *type, const char *option,
+					     struct parmlist_entry *global_opts)
+{
+	size_t type_len = strlen(type);
+	size_t option_len = strlen(option);
+	char param_key[type_len + option_len + 2];
+	struct parmlist_entry *data = NULL;
+
+	snprintf(param_key, sizeof(param_key), "%s:%s", type, option);
+
+	/*
+	 * Try to fetch the option from the data.
+	 */
+	if (service != NULL) {
+		data = service->param_opt;
+		while (data != NULL) {
+			if (strwicmp(data->key, param_key) == 0) {
+				return data;
+			}
+			data = data->next;
+		}
+	}
+
+	/*
+	 * Fall back to fetching from the globals.
+	 */
+	data = global_opts;
+	while (data != NULL) {
+		if (strwicmp(data->key, param_key) == 0) {
+			return data;
+		}
+		data = data->next;
+	}
+
+	return NULL;
+}
+
+const char *lpcfg_get_parametric(struct loadparm_context *lp_ctx,
+			      struct loadparm_service *service,
+			      const char *type, const char *option)
+{
+	struct parmlist_entry *data;
+
+	if (lp_ctx == NULL)
+		return NULL;
+
+	data = get_parametric_helper(service,
+				     type, option, lp_ctx->globals->param_opt);
+
+	if (data == NULL) {
+		return NULL;
+	} else {
+		return data->value;
+	}
+}
+
+
+/**
+ * convenience routine to return int parameters.
+ */
+int lp_int(const char *s)
+{
+
+	if (!s || !*s) {
+		DEBUG(0,("lp_int(%s): is called with NULL!\n",s));
+		return -1;
+	}
+
+	return strtol(s, NULL, 0);
+}
+
+/**
+ * convenience routine to return unsigned long parameters.
+ */
+unsigned long lp_ulong(const char *s)
+{
+	int error = 0;
+	unsigned long int ret;
+
+	if (!s || !*s) {
+		DBG_DEBUG("lp_ulong(%s): is called with NULL!\n",s);
+		return -1;
+	}
+
+	ret = smb_strtoul(s, NULL, 0, &error, SMB_STR_STANDARD);
+	if (error != 0) {
+		DBG_DEBUG("lp_ulong(%s): conversion failed\n",s);
+		return -1;
+	}
+
+	return ret;
+}
+
+/**
+ * convenience routine to return unsigned long long parameters.
+ */
+unsigned long long lp_ulonglong(const char *s)
+{
+	int error = 0;
+	unsigned long long int ret;
+
+	if (!s || !*s) {
+		DBG_DEBUG("lp_ulonglong(%s): is called with NULL!\n", s);
+		return -1;
+	}
+
+	ret = smb_strtoull(s, NULL, 0, &error, SMB_STR_STANDARD);
+	if (error != 0) {
+		DBG_DEBUG("lp_ulonglong(%s): conversion failed\n",s);
+		return -1;
+	}
+
+	return ret;
+}
+
+/**
+ * convenience routine to return unsigned long parameters.
+ */
+static long lp_long(const char *s)
+{
+
+	if (!s) {
+		DEBUG(0,("lp_long(%s): is called with NULL!\n",s));
+		return -1;
+	}
+
+	return strtol(s, NULL, 0);
+}
+
+/**
+ * convenience routine to return unsigned long parameters.
+ */
+static double lp_double(const char *s)
+{
+
+	if (!s) {
+		DEBUG(0,("lp_double(%s): is called with NULL!\n",s));
+		return -1;
+	}
+
+	return strtod(s, NULL);
+}
+
+/**
+ * convenience routine to return boolean parameters.
+ */
+bool lp_bool(const char *s)
+{
+	bool ret = false;
+
+	if (!s || !*s) {
+		DEBUG(0,("lp_bool(%s): is called with NULL!\n",s));
+		return false;
+	}
+
+	if (!set_boolean(s, &ret)) {
+		DEBUG(0,("lp_bool(%s): value is not boolean!\n",s));
+		return false;
+	}
+
+	return ret;
+}
+
+/**
+ * Return parametric option from a given service. Type is a part of option before ':'
+ * Parametric option has following syntax: 'Type: option = value'
+ * Returned value is allocated in 'lp_talloc' context
+ */
+
+const char *lpcfg_parm_string(struct loadparm_context *lp_ctx,
+			      struct loadparm_service *service, const char *type,
+			      const char *option)
+{
+	const char *value = lpcfg_get_parametric(lp_ctx, service, type, option);
+
+	if (value)
+		return lpcfg_string(value);
+
+	return NULL;
+}
+
+/**
+ * Return parametric option from a given service. Type is a part of option before ':'
+ * Parametric option has following syntax: 'Type: option = value'
+ * Returned value is allocated in 'lp_talloc' context
+ */
+
+const char **lpcfg_parm_string_list(TALLOC_CTX *mem_ctx,
+				    struct loadparm_context *lp_ctx,
+				    struct loadparm_service *service,
+				    const char *type,
+				    const char *option, const char *separator)
+{
+	const char *value = lpcfg_get_parametric(lp_ctx, service, type, option);
+
+	if (value != NULL) {
+		char **l = str_list_make(mem_ctx, value, separator);
+		return discard_const_p(const char *, l);
+	}
+
+	return NULL;
+}
+
+/**
+ * Return parametric option from a given service. Type is a part of option before ':'
+ * Parametric option has following syntax: 'Type: option = value'
+ */
+
+int lpcfg_parm_int(struct loadparm_context *lp_ctx,
+		   struct loadparm_service *service, const char *type,
+		   const char *option, int default_v)
+{
+	const char *value = lpcfg_get_parametric(lp_ctx, service, type, option);
+
+	if (value)
+		return lp_int(value);
+
+	return default_v;
+}
+
+/**
+ * Return parametric option from a given service. Type is a part of
+ * option before ':'.
+ * Parametric option has following syntax: 'Type: option = value'.
+ */
+
+int lpcfg_parm_bytes(struct loadparm_context *lp_ctx,
+		  struct loadparm_service *service, const char *type,
+		  const char *option, int default_v)
+{
+	uint64_t bval;
+
+	const char *value = lpcfg_get_parametric(lp_ctx, service, type, option);
+
+	if (value && conv_str_size_error(value, &bval)) {
+		if (bval <= INT_MAX) {
+			return (int)bval;
+		}
+	}
+
+	return default_v;
+}
+
+/**
+ * Return parametric option from a given service.
+ * Type is a part of option before ':'
+ * Parametric option has following syntax: 'Type: option = value'
+ */
+unsigned long lpcfg_parm_ulong(struct loadparm_context *lp_ctx,
+			    struct loadparm_service *service, const char *type,
+			    const char *option, unsigned long default_v)
+{
+	const char *value = lpcfg_get_parametric(lp_ctx, service, type, option);
+
+	if (value)
+		return lp_ulong(value);
+
+	return default_v;
+}
+
+/**
+ * Return parametric option from a given service.
+ * Type is a part of option before ':'
+ * Parametric option has following syntax: 'Type: option = value'
+ */
+unsigned long long lpcfg_parm_ulonglong(struct loadparm_context *lp_ctx,
+					struct loadparm_service *service,
+					const char *type, const char *option,
+					unsigned long long default_v)
+{
+	const char *value = lpcfg_get_parametric(lp_ctx, service, type, option);
+
+	if (value) {
+		return lp_ulonglong(value);
+	}
+
+	return default_v;
+}
+
+long lpcfg_parm_long(struct loadparm_context *lp_ctx,
+		     struct loadparm_service *service, const char *type,
+		     const char *option, long default_v)
+{
+	const char *value = lpcfg_get_parametric(lp_ctx, service, type, option);
+
+	if (value)
+		return lp_long(value);
+
+	return default_v;
+}
+
+double lpcfg_parm_double(struct loadparm_context *lp_ctx,
+		      struct loadparm_service *service, const char *type,
+		      const char *option, double default_v)
+{
+	const char *value = lpcfg_get_parametric(lp_ctx, service, type, option);
+
+	if (value != NULL)
+		return lp_double(value);
+
+	return default_v;
+}
+
+/**
+ * Return parametric option from a given service. Type is a part of option before ':'
+ * Parametric option has following syntax: 'Type: option = value'
+ */
+
+bool lpcfg_parm_bool(struct loadparm_context *lp_ctx,
+		     struct loadparm_service *service, const char *type,
+		     const char *option, bool default_v)
+{
+	const char *value = lpcfg_get_parametric(lp_ctx, service, type, option);
+
+	if (value != NULL)
+		return lp_bool(value);
+
+	return default_v;
+}
+
+
+/* this is used to prevent lots of mallocs of size 1 */
+static const char lpcfg_string_empty[] = "";
+
+/**
+ Free a string value.
+**/
+void lpcfg_string_free(char **s)
+{
+	if (s == NULL) {
+		return;
+	}
+	if (*s == lpcfg_string_empty) {
+		*s = NULL;
+		return;
+	}
+	TALLOC_FREE(*s);
+}
+
+/**
+ * Set a string value, deallocating any existing space, and allocing the space
+ * for the string
+ */
+bool lpcfg_string_set(TALLOC_CTX *mem_ctx, char **dest, const char *src)
+{
+	lpcfg_string_free(dest);
+
+	if ((src == NULL) || (*src == '\0')) {
+		*dest = discard_const_p(char, lpcfg_string_empty);
+		return true;
+	}
+
+	*dest = talloc_strdup(mem_ctx, src);
+	if ((*dest) == NULL) {
+		DEBUG(0,("Out of memory in string_set\n"));
+		return false;
+	}
+
+	return true;
+}
+
+/**
+ * Set a string value, deallocating any existing space, and allocing the space
+ * for the string
+ */
+bool lpcfg_string_set_upper(TALLOC_CTX *mem_ctx, char **dest, const char *src)
+{
+	lpcfg_string_free(dest);
+
+	if ((src == NULL) || (*src == '\0')) {
+		*dest = discard_const_p(char, lpcfg_string_empty);
+		return true;
+	}
+
+	*dest = strupper_talloc(mem_ctx, src);
+	if ((*dest) == NULL) {
+		DEBUG(0,("Out of memory in string_set_upper\n"));
+		return false;
+	}
+
+	return true;
+}
+
+
+
+/**
+ * Add a new service to the services array initialising it with the given
+ * service.
+ */
+
+struct loadparm_service *lpcfg_add_service(struct loadparm_context *lp_ctx,
+					   const struct loadparm_service *pservice,
+					   const char *name)
+{
+	int i;
+	int num_to_alloc = lp_ctx->iNumServices + 1;
+	struct parmlist_entry *data, *pdata;
+
+	if (lp_ctx->s3_fns != NULL) {
+		smb_panic("Add a service should not be called on an s3 loadparm ctx");
+	}
+
+	if (pservice == NULL) {
+		pservice = lp_ctx->sDefault;
+	}
+
+	/* it might already exist */
+	if (name) {
+		struct loadparm_service *service = lpcfg_getservicebyname(lp_ctx,
+								    name);
+		if (service != NULL) {
+			/* Clean all parametric options for service */
+			/* They will be added during parsing again */
+			data = service->param_opt;
+			while (data) {
+				pdata = data->next;
+				talloc_free(data);
+				data = pdata;
+			}
+			service->param_opt = NULL;
+			return service;
+		}
+	}
+
+	/* find an invalid one */
+	for (i = 0; i < lp_ctx->iNumServices; i++)
+		if (lp_ctx->services[i] == NULL)
+			break;
+
+	/* if not, then create one */
+	if (i == lp_ctx->iNumServices) {
+		struct loadparm_service **tsp;
+
+		tsp = talloc_realloc(lp_ctx, lp_ctx->services, struct loadparm_service *, num_to_alloc);
+
+		if (!tsp) {
+			DEBUG(0,("lpcfg_add_service: failed to enlarge services!\n"));
+			return NULL;
+		} else {
+			lp_ctx->services = tsp;
+			lp_ctx->services[lp_ctx->iNumServices] = NULL;
+		}
+
+		lp_ctx->iNumServices++;
+	}
+
+	lp_ctx->services[i] = talloc_zero(lp_ctx->services, struct loadparm_service);
+	if (lp_ctx->services[i] == NULL) {
+		DEBUG(0,("lpcfg_add_service: out of memory!\n"));
+		return NULL;
+	}
+	copy_service(lp_ctx->services[i], pservice, NULL);
+	if (name != NULL)
+		lpcfg_string_set(lp_ctx->services[i], &lp_ctx->services[i]->szService, name);
+	return lp_ctx->services[i];
+}
+
+/**
+ * Map a parameter's string representation to something we can use.
+ * Returns False if the parameter string is not recognised, else TRUE.
+ */
+
+int lpcfg_map_parameter(const char *pszParmName)
+{
+	int iIndex;
+
+	for (iIndex = 0; parm_table[iIndex].label; iIndex++)
+		if (strwicmp(parm_table[iIndex].label, pszParmName) == 0)
+			return iIndex;
+
+	/* Warn only if it isn't parametric option */
+	if (strchr(pszParmName, ':') == NULL)
+		DEBUG(0, ("Unknown parameter encountered: \"%s\"\n", pszParmName));
+	/* We do return 'fail' for parametric options as well because they are
+	   stored in different storage
+	 */
+	return -1;
+}
+
+
+/**
+  return the parameter structure for a parameter
+*/
+struct parm_struct *lpcfg_parm_struct(struct loadparm_context *lp_ctx, const char *name)
+{
+	int num = lpcfg_map_parameter(name);
+
+	if (num < 0) {
+		return NULL;
+	}
+
+	return &parm_table[num];
+}
+
+/**
+  return the parameter pointer for a parameter
+*/
+void *lpcfg_parm_ptr(struct loadparm_context *lp_ctx,
+		  struct loadparm_service *service, struct parm_struct *parm)
+{
+	if (lp_ctx->s3_fns) {
+		return lp_ctx->s3_fns->get_parm_ptr(service, parm);
+	}
+
+	if (service == NULL) {
+		if (parm->p_class == P_LOCAL)
+			return ((char *)lp_ctx->sDefault)+parm->offset;
+		else if (parm->p_class == P_GLOBAL)
+			return ((char *)lp_ctx->globals)+parm->offset;
+		else return NULL;
+	} else {
+		return ((char *)service) + parm->offset;
+	}
+}
+
+/**
+  return the parameter pointer for a parameter
+*/
+bool lpcfg_parm_is_cmdline(struct loadparm_context *lp_ctx, const char *name)
+{
+	int parmnum;
+
+	parmnum = lpcfg_map_parameter(name);
+	if (parmnum == -1) return false;
+
+	return lp_ctx->flags[parmnum] & FLAG_CMDLINE;
+}
+
+bool lpcfg_parm_is_unspecified(struct loadparm_context *lp_ctx, const char *name)
+{
+	int parmnum;
+
+	parmnum = lpcfg_map_parameter(name);
+	if (parmnum == -1) return false;
+
+	return lp_ctx->flags[parmnum] & FLAG_DEFAULT;
+}
+
+/**
+ * Find a service by name. Otherwise works like get_service.
+ */
+
+static struct loadparm_service *lpcfg_getservicebyname(struct loadparm_context *lp_ctx,
+					const char *pszServiceName)
+{
+	int iService;
+
+	if (lp_ctx->s3_fns) {
+		return lp_ctx->s3_fns->get_service(pszServiceName);
+	}
+
+	for (iService = lp_ctx->iNumServices - 1; iService >= 0; iService--)
+		if (lp_ctx->services[iService] != NULL &&
+		    strwicmp(lp_ctx->services[iService]->szService, pszServiceName) == 0) {
+			return lp_ctx->services[iService];
+		}
+
+	return NULL;
+}
+
+/**
+ * Add a parametric option to a parmlist_entry,
+ * replacing old value, if already present.
+ */
+void set_param_opt(TALLOC_CTX *mem_ctx,
+		   struct parmlist_entry **opt_list,
+		   const char *opt_name,
+		   const char *opt_value,
+		   unsigned priority)
+{
+	struct parmlist_entry *new_opt, *opt;
+
+	opt = *opt_list;
+
+	/* Traverse destination */
+	while (opt) {
+		/* If we already have same option, override it */
+		if (strwicmp(opt->key, opt_name) == 0) {
+			if ((opt->priority & FLAG_CMDLINE) &&
+			    !(priority & FLAG_CMDLINE)) {
+				/* it's been marked as not to be
+				   overridden */
+				return;
+			}
+			TALLOC_FREE(opt->list);
+			lpcfg_string_set(opt, &opt->value, opt_value);
+			opt->priority = priority;
+			return;
+		}
+		opt = opt->next;
+	}
+
+	new_opt = talloc_pooled_object(
+		mem_ctx, struct parmlist_entry,
+		2, strlen(opt_name) + 1 + strlen(opt_value) + 1);
+	if (new_opt == NULL) {
+		smb_panic("OOM");
+	}
+	new_opt->key = NULL;
+	lpcfg_string_set(new_opt, &new_opt->key, opt_name);
+	new_opt->value = NULL;
+	lpcfg_string_set(new_opt, &new_opt->value, opt_value);
+
+	new_opt->list = NULL;
+	new_opt->priority = priority;
+	DLIST_ADD(*opt_list, new_opt);
+}
+
+/**
+ * Copy a service structure to another.
+ * If pcopymapDest is NULL then copy all fields
+ */
+
+void copy_service(struct loadparm_service *pserviceDest,
+		  const struct loadparm_service *pserviceSource,
+		  struct bitmap *pcopymapDest)
+{
+	int i;
+	bool bcopyall = (pcopymapDest == NULL);
+	struct parmlist_entry *data;
+
+	for (i = 0; parm_table[i].label; i++)
+		if (parm_table[i].p_class == P_LOCAL &&
+		    (bcopyall || bitmap_query(pcopymapDest, i))) {
+			const void *src_ptr =
+				((const char *)pserviceSource) + parm_table[i].offset;
+			void *dest_ptr =
+				((char *)pserviceDest) + parm_table[i].offset;
+
+			switch (parm_table[i].type) {
+				case P_BOOL:
+				case P_BOOLREV:
+					*(bool *)dest_ptr = *(const bool *)src_ptr;
+					break;
+
+				case P_INTEGER:
+				case P_BYTES:
+				case P_OCTAL:
+				case P_ENUM:
+					*(int *)dest_ptr = *(const int *)src_ptr;
+					break;
+
+				case P_CHAR:
+					*(char *)dest_ptr = *(const char *)src_ptr;
+					break;
+
+				case P_STRING:
+					lpcfg_string_set(pserviceDest,
+						   (char **)dest_ptr,
+						   *(const char * const *)src_ptr);
+					break;
+
+				case P_USTRING:
+					lpcfg_string_set_upper(pserviceDest,
+							 (char **)dest_ptr,
+							 *(const char * const *)src_ptr);
+					break;
+				case P_CMDLIST:
+				case P_LIST:
+					TALLOC_FREE(*((char ***)dest_ptr));
+					*(char ***)dest_ptr = str_list_copy(pserviceDest,
+									    *discard_const_p(const char **, src_ptr));
+					break;
+				default:
+					break;
+			}
+		}
+
+	if (bcopyall) {
+		init_copymap(pserviceDest);
+		if (pserviceSource->copymap)
+			bitmap_copy(pserviceDest->copymap,
+				    pserviceSource->copymap);
+	}
+
+	for (data = pserviceSource->param_opt; data != NULL; data = data->next) {
+		set_param_opt(pserviceDest, &pserviceDest->param_opt,
+			      data->key, data->value, data->priority);
+	}
+}
+
+/**
+ * Check a service for consistency. Return False if the service is in any way
+ * incomplete or faulty, else True.
+ */
+bool lpcfg_service_ok(struct loadparm_service *service)
+{
+	bool bRetval;
+
+	bRetval = true;
+	if (service->szService[0] == '\0') {
+		DEBUG(0, ("The following message indicates an internal error:\n"));
+		DEBUG(0, ("No service name in service entry.\n"));
+		bRetval = false;
+	}
+
+	/* The [printers] entry MUST be printable. I'm all for flexibility, but */
+	/* I can't see why you'd want a non-printable printer service...        */
+	if (strwicmp(service->szService, PRINTERS_NAME) == 0) {
+		if (!service->printable) {
+			DEBUG(0, ("WARNING: [%s] service MUST be printable!\n",
+			       service->szService));
+			service->printable = true;
+		}
+		/* [printers] service must also be non-browsable. */
+		if (service->browseable)
+			service->browseable = false;
+	}
+
+	if (service->path[0] == '\0' &&
+	    strwicmp(service->szService, HOMES_NAME) != 0 &&
+	    service->msdfs_proxy[0] == '\0')
+	{
+		DEBUG(0, ("WARNING: No path in service %s - making it unavailable!\n",
+			service->szService));
+		service->available = false;
+	}
+
+	if (!service->available)
+		DEBUG(1, ("NOTE: Service %s is flagged unavailable.\n",
+			  service->szService));
+
+	return bRetval;
+}
+
+
+/*******************************************************************
+ Keep a linked list of all config files so we know when one has changed
+ it's date and needs to be reloaded.
+********************************************************************/
+
+void add_to_file_list(TALLOC_CTX *mem_ctx, struct file_lists **list,
+			     const char *fname, const char *subfname)
+{
+	struct file_lists *f = *list;
+
+	while (f) {
+		if (f->name && !strcmp(f->name, fname))
+			break;
+		f = f->next;
+	}
+
+	if (!f) {
+		f = talloc(mem_ctx, struct file_lists);
+		if (!f)
+			goto fail;
+		f->next = *list;
+		f->name = talloc_strdup(f, fname);
+		if (!f->name) {
+			TALLOC_FREE(f);
+			goto fail;
+		}
+		f->subfname = talloc_strdup(f, subfname);
+		if (!f->subfname) {
+			TALLOC_FREE(f);
+			goto fail;
+		}
+		*list = f;
+		f->modtime = file_modtime(subfname);
+	} else {
+		time_t t = file_modtime(subfname);
+		if (t)
+			f->modtime = t;
+	}
+	return;
+
+fail:
+	DEBUG(0, ("Unable to add file to file list: %s\n", fname));
+
+}
+
+/*
+ * set the value for a P_ENUM
+ */
+bool lp_set_enum_parm( struct parm_struct *parm, const char *pszParmValue,
+                              int *ptr )
+{
+	int i;
+
+	for (i = 0; parm->enum_list[i].name; i++) {
+		if (strwicmp(pszParmValue, parm->enum_list[i].name) == 0) {
+			*ptr = parm->enum_list[i].value;
+			return true;
+		}
+	}
+	DEBUG(0, ("WARNING: Ignoring invalid value '%s' for parameter '%s'\n",
+		  pszParmValue, parm->label));
+	return false;
+}
+
+
+/***************************************************************************
+ Handle the "realm" parameter
+***************************************************************************/
+
+bool handle_realm(struct loadparm_context *lp_ctx, struct loadparm_service *service,
+		  const char *pszParmValue, char **ptr)
+{
+	char *upper;
+	char *lower;
+
+	upper = strupper_talloc(lp_ctx, pszParmValue);
+	if (upper == NULL) {
+		return false;
+	}
+
+	lower = strlower_talloc(lp_ctx, pszParmValue);
+	if (lower == NULL) {
+		TALLOC_FREE(upper);
+		return false;
+	}
+
+	lpcfg_string_set(lp_ctx->globals->ctx, &lp_ctx->globals->realm, upper);
+	lpcfg_string_set(lp_ctx->globals->ctx, &lp_ctx->globals->dnsdomain, lower);
+
+	return true;
+}
+
+/***************************************************************************
+ Handle the include operation.
+***************************************************************************/
+
+bool handle_include(struct loadparm_context *lp_ctx, struct loadparm_service *service,
+			   const char *pszParmValue, char **ptr)
+{
+	char *fname;
+	const char *substitution_variable_substring;
+	char next_char;
+
+	if (lp_ctx->s3_fns) {
+		return lp_ctx->s3_fns->lp_include(lp_ctx, service, pszParmValue, ptr);
+	}
+
+	fname = standard_sub_basic(lp_ctx, pszParmValue);
+
+	add_to_file_list(lp_ctx, &lp_ctx->file_lists, pszParmValue, fname);
+
+	lpcfg_string_set(lp_ctx, ptr, fname);
+
+	if (file_exist(fname))
+		return pm_process(fname, do_section, lpcfg_do_parameter, lp_ctx);
+
+       /*
+        * If the file doesn't exist, we check that it isn't due to variable
+        * substitution
+        */
+	substitution_variable_substring = strchr(fname, '%');
+
+	if (substitution_variable_substring != NULL) {
+		next_char = substitution_variable_substring[1];
+		if ((next_char >= 'a' && next_char <= 'z')
+		    || (next_char >= 'A' && next_char <= 'Z')) {
+			DEBUG(2, ("Tried to load %s but variable substitution in "
+				 "filename, ignoring file.\n", fname));
+			return true;
+		}
+	}
+
+	DEBUG(2, ("Can't find include file %s\n", fname));
+
+	return false;
+}
+
+/***************************************************************************
+ Handle the interpretation of the copy parameter.
+***************************************************************************/
+
+bool handle_copy(struct loadparm_context *lp_ctx, struct loadparm_service *service,
+			const char *pszParmValue, char **ptr)
+{
+	bool bRetval;
+	struct loadparm_service *serviceTemp = NULL;
+
+	bRetval = false;
+
+	DEBUG(3, ("Copying service from service %s\n", pszParmValue));
+
+	serviceTemp = lpcfg_getservicebyname(lp_ctx, pszParmValue);
+
+	if (service == NULL) {
+		DEBUG(0, ("Unable to copy service - invalid service destination.\n"));
+		return false;
+	}
+
+	if (serviceTemp != NULL) {
+		if (serviceTemp == service) {
+			DEBUG(0, ("Can't copy service %s - unable to copy self!\n", pszParmValue));
+		} else {
+			copy_service(service,
+				     serviceTemp,
+				     service->copymap);
+			lpcfg_string_set(service, ptr, pszParmValue);
+
+			bRetval = true;
+		}
+	} else {
+		DEBUG(0, ("Unable to copy service - source not found: %s\n",
+			  pszParmValue));
+		bRetval = false;
+	}
+
+	return bRetval;
+}
+
+bool handle_debug_list(struct loadparm_context *lp_ctx, struct loadparm_service *service,
+			const char *pszParmValue, char **ptr)
+{
+	lpcfg_string_set(lp_ctx->globals->ctx, ptr, pszParmValue);
+
+	return debug_parse_levels(pszParmValue);
+}
+
+bool handle_logfile(struct loadparm_context *lp_ctx, struct loadparm_service *service,
+		    const char *pszParmValue, char **ptr)
+{
+	if (lp_ctx->s3_fns == NULL) {
+		debug_set_logfile(pszParmValue);
+	}
+
+	lpcfg_string_set(lp_ctx->globals->ctx, ptr, pszParmValue);
+
+	return true;
+}
+
+/*
+ * These special charset handling methods only run in the source3 code.
+ */
+
+bool handle_charset(struct loadparm_context *lp_ctx, struct loadparm_service *service,
+			const char *pszParmValue, char **ptr)
+{
+	if (lp_ctx->s3_fns) {
+		if (*ptr == NULL || strcmp(*ptr, pszParmValue) != 0) {
+			struct smb_iconv_handle *ret = NULL;
+
+			ret = reinit_iconv_handle(NULL,
+						  lpcfg_dos_charset(lp_ctx),
+						  lpcfg_unix_charset(lp_ctx));
+			if (ret == NULL) {
+				smb_panic("reinit_iconv_handle failed");
+			}
+		}
+
+	}
+	return lpcfg_string_set(lp_ctx->globals->ctx, ptr, pszParmValue);
+
+}
+
+bool handle_dos_charset(struct loadparm_context *lp_ctx, struct loadparm_service *service,
+			const char *pszParmValue, char **ptr)
+{
+	bool is_utf8 = false;
+	size_t len = strlen(pszParmValue);
+
+	if (lp_ctx->s3_fns) {
+		if (len == 4 || len == 5) {
+			/* Don't use StrCaseCmp here as we don't want to
+			   initialize iconv. */
+			if ((toupper_m(pszParmValue[0]) == 'U') &&
+			    (toupper_m(pszParmValue[1]) == 'T') &&
+			    (toupper_m(pszParmValue[2]) == 'F')) {
+				if (len == 4) {
+					if (pszParmValue[3] == '8') {
+						is_utf8 = true;
+					}
+				} else {
+					if (pszParmValue[3] == '-' &&
+					    pszParmValue[4] == '8') {
+						is_utf8 = true;
+					}
+				}
+			}
+		}
+
+		if (*ptr == NULL || strcmp(*ptr, pszParmValue) != 0) {
+			struct smb_iconv_handle *ret = NULL;
+			if (is_utf8) {
+				DEBUG(0,("ERROR: invalid DOS charset: 'dos charset' must not "
+					"be UTF8, using (default value) %s instead.\n",
+					DEFAULT_DOS_CHARSET));
+				pszParmValue = DEFAULT_DOS_CHARSET;
+			}
+			ret = reinit_iconv_handle(NULL,
+						lpcfg_dos_charset(lp_ctx),
+						lpcfg_unix_charset(lp_ctx));
+			if (ret == NULL) {
+				smb_panic("reinit_iconv_handle failed");
+			}
+		}
+	}
+
+	return lpcfg_string_set(lp_ctx->globals->ctx, ptr, pszParmValue);
+}
+
+bool handle_printing(struct loadparm_context *lp_ctx, struct loadparm_service *service,
+			    const char *pszParmValue, char **ptr)
+{
+	static int parm_num = -1;
+
+	if (parm_num == -1) {
+		parm_num = lpcfg_map_parameter("printing");
+	}
+
+	if (!lp_set_enum_parm(&parm_table[parm_num], pszParmValue, (int*)ptr)) {
+		return false;
+	}
+
+	if (lp_ctx->s3_fns) {
+		if (service == NULL) {
+			init_printer_values(lp_ctx, lp_ctx->globals->ctx, lp_ctx->sDefault);
+		} else {
+			init_printer_values(lp_ctx, service, service);
+		}
+	}
+
+	return true;
+}
+
+bool handle_ldap_debug_level(struct loadparm_context *lp_ctx, struct loadparm_service *service,
+			     const char *pszParmValue, char **ptr)
+{
+	lp_ctx->globals->ldap_debug_level = lp_int(pszParmValue);
+
+	if (lp_ctx->s3_fns) {
+		lp_ctx->s3_fns->init_ldap_debugging();
+	}
+	return true;
+}
+
+/*
+ * idmap related parameters
+ */
+
+bool handle_idmap_backend(struct loadparm_context *lp_ctx, struct loadparm_service *service,
+			  const char *pszParmValue, char **ptr)
+{
+	if (lp_ctx->s3_fns) {
+		lp_do_parameter_parametric(lp_ctx, service, "idmap config * : backend",
+					   pszParmValue, 0);
+	}
+
+	return lpcfg_string_set(lp_ctx->globals->ctx, ptr, pszParmValue);
+}
+
+bool handle_idmap_uid(struct loadparm_context *lp_ctx, struct loadparm_service *service,
+		      const char *pszParmValue, char **ptr)
+{
+	if (lp_ctx->s3_fns) {
+		lp_do_parameter_parametric(lp_ctx, service, "idmap config * : range",
+					   pszParmValue, 0);
+	}
+
+	return lpcfg_string_set(lp_ctx->globals->ctx, ptr, pszParmValue);
+}
+
+bool handle_idmap_gid(struct loadparm_context *lp_ctx, struct loadparm_service *service,
+		      const char *pszParmValue, char **ptr)
+{
+	if (lp_ctx->s3_fns) {
+		lp_do_parameter_parametric(lp_ctx, service, "idmap config * : range",
+					   pszParmValue, 0);
+	}
+
+	return lpcfg_string_set(lp_ctx->globals->ctx, ptr, pszParmValue);
+}
+
+bool handle_smb_ports(struct loadparm_context *lp_ctx, struct loadparm_service *service,
+		      const char *pszParmValue, char **ptr)
+{
+	static int parm_num = -1;
+	int i;
+	const char **list;
+
+	if (!pszParmValue || !*pszParmValue) {
+		return false;
+	}
+
+	if (parm_num == -1) {
+		parm_num = lpcfg_map_parameter("smb ports");
+		if (parm_num == -1) {
+			return false;
+		}
+	}
+
+	if (!set_variable_helper(lp_ctx->globals->ctx, parm_num, ptr, "smb ports",
+			       	pszParmValue)) {
+		return false;
+	}
+
+	list = lp_ctx->globals->smb_ports;
+	if (list == NULL) {
+		return false;
+	}
+
+	/* Check that each port is a valid integer and within range */
+	for (i = 0; list[i] != NULL; i++) {
+		char *end = NULL;
+		int port = 0;
+		port = strtol(list[i], &end, 10);
+		if (*end != '\0' || port <= 0 || port > 65535) {
+			TALLOC_FREE(list);
+			return false;
+		}
+	}
+
+	return true;
+}
+
+bool handle_rpc_server_dynamic_port_range(struct loadparm_context *lp_ctx,
+					  struct loadparm_service *service,
+					  const char *pszParmValue,
+					  char **ptr)
+{
+	static int parm_num = -1;
+	int low_port = -1, high_port = -1;
+	int rc;
+
+	if (parm_num == -1) {
+		parm_num = lpcfg_map_parameter("rpc server dynamic port range");
+		if (parm_num == -1) {
+			return false;
+		}
+	}
+
+	if (pszParmValue == NULL || pszParmValue[0] == '\0') {
+		return false;
+	}
+
+	rc = sscanf(pszParmValue, "%d - %d", &low_port, &high_port);
+	if (rc != 2) {
+		return false;
+	}
+
+	if (low_port > high_port) {
+		return false;
+	}
+
+	if (low_port < SERVER_TCP_PORT_MIN|| high_port > SERVER_TCP_PORT_MAX) {
+		return false;
+	}
+
+	if (!set_variable_helper(lp_ctx->globals->ctx, parm_num, ptr,
+				 "rpc server dynamic port range",
+				 pszParmValue)) {
+		return false;
+	}
+
+	lp_ctx->globals->rpc_low_port = low_port;
+	lp_ctx->globals->rpc_high_port = high_port;
+
+	return true;
+}
+
+bool handle_smb2_max_credits(struct loadparm_context *lp_ctx,
+			     struct loadparm_service *service,
+			     const char *pszParmValue, char **ptr)
+{
+	int value = lp_int(pszParmValue);
+
+	if (value <= 0) {
+		value = DEFAULT_SMB2_MAX_CREDITS;
+	}
+
+	*(int *)ptr = value;
+
+	return true;
+}
+
+bool handle_cups_encrypt(struct loadparm_context *lp_ctx,
+			 struct loadparm_service *service,
+			 const char *pszParmValue, char **ptr)
+{
+	int result = 0;
+#ifdef HAVE_HTTPCONNECTENCRYPT
+	int value = lp_int(pszParmValue);
+
+	switch (value) {
+		case Auto:
+			result = HTTP_ENCRYPT_REQUIRED;
+			break;
+		case true:
+			result = HTTP_ENCRYPT_ALWAYS;
+			break;
+		case false:
+			result = HTTP_ENCRYPT_NEVER;
+			break;
+		default:
+			result = 0;
+			break;
+	}
+#endif
+	*(int *)ptr = result;
+
+	return true;
+}
+
+/***************************************************************************
+ Initialise a copymap.
+***************************************************************************/
+
+/**
+ * Initializes service copymap
+ * Note: pservice *must* be valid TALLOC_CTX
+ */
+void init_copymap(struct loadparm_service *pservice)
+{
+	int i;
+
+	TALLOC_FREE(pservice->copymap);
+
+	pservice->copymap = bitmap_talloc(pservice, num_parameters());
+	if (!pservice->copymap) {
+		DEBUG(0,
+		      ("Couldn't allocate copymap!! (size %d)\n",
+		       (int)num_parameters()));
+	} else {
+		for (i = 0; i < num_parameters(); i++) {
+			bitmap_set(pservice->copymap, i);
+		}
+	}
+}
+
+/**
+ * Process a parametric option
+ */
+static bool lp_do_parameter_parametric(struct loadparm_context *lp_ctx,
+				       struct loadparm_service *service,
+				       const char *pszParmName,
+				       const char *pszParmValue, int flags)
+{
+	struct parmlist_entry **data;
+	char *name;
+	TALLOC_CTX *mem_ctx;
+
+	while (isspace((unsigned char)*pszParmName)) {
+		pszParmName++;
+	}
+
+	name = strlower_talloc(lp_ctx, pszParmName);
+	if (!name) return false;
+
+	if (service == NULL) {
+		data = &lp_ctx->globals->param_opt;
+		/**
+		 * s3 code cannot deal with parametric options stored on the globals ctx.
+		 */
+		if (lp_ctx->s3_fns != NULL) {
+			mem_ctx = NULL;
+		} else {
+			mem_ctx = lp_ctx->globals->ctx;
+		}
+	} else {
+		data = &service->param_opt;
+		mem_ctx = service;
+	}
+
+	set_param_opt(mem_ctx, data, name, pszParmValue, flags);
+
+	talloc_free(name);
+
+	return true;
+}
+
+static bool set_variable_helper(TALLOC_CTX *mem_ctx, int parmnum, void *parm_ptr,
+			 const char *pszParmName, const char *pszParmValue)
+{
+	size_t i;
+
+	/* switch on the type of variable it is */
+	switch (parm_table[parmnum].type)
+	{
+		case P_BOOL: {
+			bool b;
+			if (!set_boolean(pszParmValue, &b)) {
+				DEBUG(0, ("set_variable_helper(%s): value is not "
+					  "boolean!\n", pszParmValue));
+				return false;
+			}
+			*(bool *)parm_ptr = b;
+			}
+			break;
+
+		case P_BOOLREV: {
+			bool b;
+			if (!set_boolean(pszParmValue, &b)) {
+				DEBUG(0, ("set_variable_helper(%s): value is not "
+					  "boolean!\n", pszParmValue));
+				return false;
+			}
+			*(bool *)parm_ptr = !b;
+			}
+			break;
+
+		case P_INTEGER:
+			*(int *)parm_ptr = lp_int(pszParmValue);
+			break;
+
+		case P_CHAR:
+			*(char *)parm_ptr = *pszParmValue;
+			break;
+
+		case P_OCTAL:
+			i = sscanf(pszParmValue, "%o", (int *)parm_ptr);
+			if ( i != 1 ) {
+				DEBUG ( 0, ("Invalid octal number %s\n", pszParmName ));
+				return false;
+			}
+			break;
+
+		case P_BYTES:
+		{
+			uint64_t val;
+			if (conv_str_size_error(pszParmValue, &val)) {
+				if (val <= INT_MAX) {
+					*(int *)parm_ptr = (int)val;
+					break;
+				}
+			}
+
+			DEBUG(0, ("set_variable_helper(%s): value is not "
+			          "a valid size specifier!\n", pszParmValue));
+			return false;
+		}
+
+		case P_CMDLIST:
+			TALLOC_FREE(*(char ***)parm_ptr);
+			*(char ***)parm_ptr = str_list_make_v3(mem_ctx,
+							pszParmValue, NULL);
+			break;
+
+		case P_LIST:
+		{
+			char **new_list = str_list_make_v3(mem_ctx,
+							pszParmValue, NULL);
+			if (new_list == NULL) {
+				break;
+			}
+
+			for (i=0; new_list[i]; i++) {
+				if (*(const char ***)parm_ptr != NULL &&
+				    new_list[i][0] == '+' &&
+				    new_list[i][1])
+				{
+					if (!str_list_check(*(const char ***)parm_ptr,
+							    &new_list[i][1])) {
+						*(const char ***)parm_ptr = str_list_add(*(const char ***)parm_ptr,
+											 &new_list[i][1]);
+					}
+				} else if (*(const char ***)parm_ptr != NULL &&
+					   new_list[i][0] == '-' &&
+					   new_list[i][1])
+				{
+					str_list_remove(*(const char ***)parm_ptr,
+							&new_list[i][1]);
+				} else {
+					if (i != 0) {
+						DEBUG(0, ("Unsupported list syntax for: %s = %s\n",
+							  pszParmName, pszParmValue));
+						return false;
+					}
+					*(char ***)parm_ptr = new_list;
+					break;
+				}
+			}
+			break;
+		}
+
+		case P_STRING:
+			lpcfg_string_set(mem_ctx, (char **)parm_ptr, pszParmValue);
+			break;
+
+		case P_USTRING:
+			lpcfg_string_set_upper(mem_ctx, (char **)parm_ptr, pszParmValue);
+			break;
+
+		case P_ENUM:
+			if (!lp_set_enum_parm(&parm_table[parmnum], pszParmValue, (int*)parm_ptr)) {
+				return false;
+			}
+			break;
+
+	}
+
+	return true;
+
+}
+
+bool handle_name_resolve_order(struct loadparm_context *lp_ctx,
+			       struct loadparm_service *service,
+			       const char *pszParmValue, char **ptr)
+{
+	const char **valid_values = NULL;
+	const char **values_to_set = NULL;
+	int i;
+	bool value_is_valid = false;
+	valid_values = str_list_make_v3_const(NULL,
+					      DEFAULT_NAME_RESOLVE_ORDER,
+					      NULL);
+	if (valid_values == NULL) {
+		DBG_ERR("OOM: failed to make string list from %s\n",
+			DEFAULT_NAME_RESOLVE_ORDER);
+		goto out;
+	}
+	values_to_set = str_list_make_v3_const(lp_ctx->globals->ctx,
+					       pszParmValue,
+					       NULL);
+	if (values_to_set == NULL) {
+		DBG_ERR("OOM: failed to make string list from %s\n",
+			pszParmValue);
+		goto out;
+	}
+	TALLOC_FREE(lp_ctx->globals->name_resolve_order);
+	for (i = 0; values_to_set[i] != NULL; i++) {
+		value_is_valid = str_list_check(valid_values, values_to_set[i]);
+		if (!value_is_valid) {
+			DBG_ERR("WARNING: Ignoring invalid list value '%s' "
+				"for parameter 'name resolve order'\n",
+				values_to_set[i]);
+			break;
+		}
+	}
+out:
+	if (value_is_valid) {
+		lp_ctx->globals->name_resolve_order = values_to_set;
+	} else {
+		TALLOC_FREE(values_to_set);
+	}
+	TALLOC_FREE(valid_values);
+	return value_is_valid;
+}
+
+bool handle_kdc_default_domain_supported_enctypes(struct loadparm_context *lp_ctx,
+						  struct loadparm_service *service,
+						  const char *pszParmValue, char **ptr)
+{
+	char **enctype_list = NULL;
+	char **enctype = NULL;
+	uint32_t result = 0;
+	bool ok = true;
+
+	enctype_list = str_list_make(NULL, pszParmValue, NULL);
+	if (enctype_list == NULL) {
+		DBG_ERR("OOM: failed to make string list from %s\n",
+			pszParmValue);
+		ok = false;
+		goto out;
+	}
+
+	for (enctype = enctype_list; *enctype != NULL; ++enctype) {
+		if (strwicmp(*enctype, "arcfour-hmac-md5") == 0 ||
+		    strwicmp(*enctype, "rc4-hmac") == 0)
+		{
+			result |= KERB_ENCTYPE_RC4_HMAC_MD5;
+		}
+		else if (strwicmp(*enctype, "aes128-cts-hmac-sha1-96") == 0 ||
+			 strwicmp(*enctype, "aes128-cts") == 0)
+		{
+			result |= KERB_ENCTYPE_AES128_CTS_HMAC_SHA1_96;
+		}
+		else if (strwicmp(*enctype, "aes256-cts-hmac-sha1-96") == 0 ||
+			 strwicmp(*enctype, "aes256-cts") == 0)
+		{
+			result |= KERB_ENCTYPE_AES256_CTS_HMAC_SHA1_96;
+		}
+		else if (strwicmp(*enctype, "aes256-cts-hmac-sha1-96-sk") == 0 ||
+			 strwicmp(*enctype, "aes256-cts-sk") == 0)
+		{
+			result |= KERB_ENCTYPE_AES256_CTS_HMAC_SHA1_96_SK;
+		}
+		else {
+			const char *bitstr = *enctype;
+			int base;
+			int error;
+			unsigned long bit;
+
+			/* See if the bit's specified in hexadecimal. */
+			if (bitstr[0] == '0' &&
+			    (bitstr[1] == 'x' || bitstr[2] == 'X'))
+			{
+				base = 16;
+				bitstr += 2;
+			}
+			else {
+				base = 10;
+			}
+
+			bit = smb_strtoul(bitstr, NULL, base, &error, SMB_STR_FULL_STR_CONV);
+			if (error) {
+				DBG_ERR("WARNING: Ignoring invalid value '%s' "
+					"for parameter 'kdc default domain supported enctypes'\n",
+					*enctype);
+				ok = false;
+			} else {
+				result |= bit;
+			}
+		}
+	}
+
+	*(int *)ptr = result;
+out:
+	TALLOC_FREE(enctype_list);
+
+	return ok;
+}
+
+bool handle_kdc_supported_enctypes(struct loadparm_context *lp_ctx,
+				   struct loadparm_service *service,
+				   const char *pszParmValue, char **ptr)
+{
+	char **enctype_list = NULL;
+	char **enctype = NULL;
+	uint32_t result = 0;
+	bool ok = true;
+
+	enctype_list = str_list_make(NULL, pszParmValue, NULL);
+	if (enctype_list == NULL) {
+		DBG_ERR("OOM: failed to make string list from %s\n",
+			pszParmValue);
+		ok = false;
+		goto out;
+	}
+
+	for (enctype = enctype_list; *enctype != NULL; ++enctype) {
+		if (strwicmp(*enctype, "arcfour-hmac-md5") == 0 ||
+		    strwicmp(*enctype, "rc4-hmac") == 0)
+		{
+			result |= KERB_ENCTYPE_RC4_HMAC_MD5;
+		}
+		else if (strwicmp(*enctype, "aes128-cts-hmac-sha1-96") == 0 ||
+			 strwicmp(*enctype, "aes128-cts") == 0)
+		{
+			result |= KERB_ENCTYPE_AES128_CTS_HMAC_SHA1_96;
+		}
+		else if (strwicmp(*enctype, "aes256-cts-hmac-sha1-96") == 0 ||
+			 strwicmp(*enctype, "aes256-cts") == 0)
+		{
+			result |= KERB_ENCTYPE_AES256_CTS_HMAC_SHA1_96;
+		}
+		else {
+			const char *bitstr = *enctype;
+			int base;
+			int error;
+			unsigned long bit;
+
+			/* See if the bit's specified in hexadecimal. */
+			if (bitstr[0] == '0' &&
+			    (bitstr[1] == 'x' || bitstr[2] == 'X'))
+			{
+				base = 16;
+				bitstr += 2;
+			}
+			else {
+				base = 10;
+			}
+
+			bit = smb_strtoul(bitstr, NULL, base, &error, SMB_STR_FULL_STR_CONV);
+			if (error) {
+				DBG_ERR("WARNING: Ignoring invalid value '%s' "
+					"for parameter 'kdc default domain supported enctypes'\n",
+					*enctype);
+				ok = false;
+			} else {
+				result |= bit;
+			}
+		}
+	}
+
+	*(int *)ptr = result;
+out:
+	TALLOC_FREE(enctype_list);
+
+	return ok;
+}
+
+static bool set_variable(TALLOC_CTX *mem_ctx, struct loadparm_service *service,
+			 int parmnum, void *parm_ptr,
+			 const char *pszParmName, const char *pszParmValue,
+			 struct loadparm_context *lp_ctx, bool on_globals)
+{
+	int i;
+	bool ok;
+
+	/* if it is a special case then go ahead */
+	if (parm_table[parmnum].special) {
+		ok = parm_table[parmnum].special(lp_ctx, service, pszParmValue,
+						  (char **)parm_ptr);
+	} else {
+		ok = set_variable_helper(mem_ctx, parmnum, parm_ptr,
+					 pszParmName, pszParmValue);
+	}
+
+	if (!ok) {
+		return false;
+	}
+
+	if (on_globals && (lp_ctx->flags[parmnum] & FLAG_DEFAULT)) {
+		lp_ctx->flags[parmnum] &= ~FLAG_DEFAULT;
+		/* we have to also unset FLAG_DEFAULT on aliases */
+		for (i=parmnum-1;i>=0 && parm_table[i].offset == parm_table[parmnum].offset;i--) {
+			lp_ctx->flags[i] &= ~FLAG_DEFAULT;
+		}
+		for (i=parmnum+1;i<num_parameters() && parm_table[i].offset == parm_table[parmnum].offset;i++) {
+			lp_ctx->flags[i] &= ~FLAG_DEFAULT;
+		}
+	}
+	return true;
+}
+
+
+bool lpcfg_do_global_parameter(struct loadparm_context *lp_ctx,
+			       const char *pszParmName, const char *pszParmValue)
+{
+	int parmnum = lpcfg_map_parameter(pszParmName);
+	void *parm_ptr;
+
+	if (parmnum < 0) {
+		if (strchr(pszParmName, ':')) {
+			return lp_do_parameter_parametric(lp_ctx, NULL, pszParmName, pszParmValue, 0);
+		}
+		DEBUG(0, ("Ignoring unknown parameter \"%s\"\n", pszParmName));
+		return true;
+	}
+
+	/* if the flag has been set on the command line, then don't allow override,
+	   but don't report an error */
+	if (lp_ctx->flags[parmnum] & FLAG_CMDLINE) {
+		return true;
+	}
+
+	if (parm_table[parmnum].flags & FLAG_DEPRECATED) {
+		char *suppress_env = getenv("SAMBA_DEPRECATED_SUPPRESS");
+		bool print_warning = (suppress_env == NULL
+				      || suppress_env[0] == '\0');
+		if (print_warning) {
+			DBG_WARNING("WARNING: The \"%s\" option "
+				    "is deprecated\n",
+				    pszParmName);
+
+		}
+	}
+
+	parm_ptr = lpcfg_parm_ptr(lp_ctx, NULL, &parm_table[parmnum]);
+
+	return set_variable(lp_ctx->globals->ctx, NULL, parmnum, parm_ptr,
+			    pszParmName, pszParmValue, lp_ctx, true);
+}
+
+bool lpcfg_do_service_parameter(struct loadparm_context *lp_ctx,
+				struct loadparm_service *service,
+				const char *pszParmName, const char *pszParmValue)
+{
+	void *parm_ptr;
+	int i;
+	int parmnum = lpcfg_map_parameter(pszParmName);
+
+	if (parmnum < 0) {
+		if (strchr(pszParmName, ':')) {
+			return lp_do_parameter_parametric(lp_ctx, service, pszParmName, pszParmValue, 0);
+		}
+		DEBUG(0, ("Ignoring unknown parameter \"%s\"\n", pszParmName));
+		return true;
+	}
+
+	/* if the flag has been set on the command line, then don't allow override,
+	   but don't report an error */
+	if (lp_ctx->flags[parmnum] & FLAG_CMDLINE) {
+		return true;
+	}
+
+	if (parm_table[parmnum].flags & FLAG_DEPRECATED) {
+		char *suppress_env = getenv("SAMBA_DEPRECATED_SUPPRESS");
+		bool print_warning = (suppress_env == NULL
+				      || suppress_env[0] == '\0');
+		if (print_warning) {
+			DBG_WARNING("WARNING: The \"%s\" option "
+				    "is deprecated\n",
+				    pszParmName);
+
+		}
+	}
+
+	if (parm_table[parmnum].p_class == P_GLOBAL) {
+		DEBUG(0,
+		      ("Global parameter %s found in service section!\n",
+		       pszParmName));
+		return true;
+	}
+	parm_ptr = ((char *)service) + parm_table[parmnum].offset;
+
+	if (!service->copymap)
+		init_copymap(service);
+
+	/* this handles the aliases - set the copymap for other
+	 * entries with the same data pointer */
+	for (i = 0; parm_table[i].label; i++)
+		if (parm_table[i].offset == parm_table[parmnum].offset &&
+		    parm_table[i].p_class == parm_table[parmnum].p_class)
+			bitmap_clear(service->copymap, i);
+
+	return set_variable(service, service, parmnum, parm_ptr, pszParmName,
+			    pszParmValue, lp_ctx, false);
+}
+
+/**
+ * Process a parameter.
+ */
+
+bool lpcfg_do_parameter(const char *pszParmName, const char *pszParmValue,
+			 void *userdata)
+{
+	struct loadparm_context *lp_ctx = (struct loadparm_context *)userdata;
+
+	if (lp_ctx->bInGlobalSection)
+		return lpcfg_do_global_parameter(lp_ctx, pszParmName,
+					      pszParmValue);
+	else
+		return lpcfg_do_service_parameter(lp_ctx, lp_ctx->currentService,
+						  pszParmName, pszParmValue);
+}
+
+/*
+  variable argument do parameter
+*/
+bool lpcfg_do_global_parameter_var(struct loadparm_context *lp_ctx, const char *pszParmName, const char *fmt, ...) PRINTF_ATTRIBUTE(3, 4);
+bool lpcfg_do_global_parameter_var(struct loadparm_context *lp_ctx,
+				const char *pszParmName, const char *fmt, ...)
+{
+	char *s;
+	bool ret;
+	va_list ap;
+
+	va_start(ap, fmt);
+	s = talloc_vasprintf(NULL, fmt, ap);
+	va_end(ap);
+	ret = lpcfg_do_global_parameter(lp_ctx, pszParmName, s);
+	talloc_free(s);
+	return ret;
+}
+
+
+/*
+  set a parameter from the commandline - this is called from command line parameter
+  parsing code. It sets the parameter then marks the parameter as unable to be modified
+  by smb.conf processing
+*/
+bool lpcfg_set_cmdline(struct loadparm_context *lp_ctx, const char *pszParmName,
+		       const char *pszParmValue)
+{
+	int parmnum;
+	int i;
+
+	while (isspace((unsigned char)*pszParmValue)) pszParmValue++;
+
+	parmnum = lpcfg_map_parameter(pszParmName);
+
+	if (parmnum < 0 && strchr(pszParmName, ':')) {
+		/* set a parametric option */
+		bool ok;
+		ok = lp_do_parameter_parametric(lp_ctx, NULL, pszParmName,
+						pszParmValue, FLAG_CMDLINE);
+		if (lp_ctx->s3_fns != NULL) {
+			if (ok) {
+				lp_ctx->s3_fns->store_cmdline(pszParmName, pszParmValue);
+			}
+		}
+		return ok;
+	}
+
+	if (parmnum < 0) {
+		DEBUG(0,("Unknown option '%s'\n", pszParmName));
+		return false;
+	}
+
+	/* reset the CMDLINE flag in case this has been called before */
+	lp_ctx->flags[parmnum] &= ~FLAG_CMDLINE;
+
+	if (!lpcfg_do_global_parameter(lp_ctx, pszParmName, pszParmValue)) {
+		return false;
+	}
+
+	lp_ctx->flags[parmnum] |= FLAG_CMDLINE;
+
+	/* we have to also set FLAG_CMDLINE on aliases */
+	for (i=parmnum-1;
+	     i>=0 && parm_table[i].p_class == parm_table[parmnum].p_class &&
+	     parm_table[i].offset == parm_table[parmnum].offset;
+	     i--) {
+		lp_ctx->flags[i] |= FLAG_CMDLINE;
+	}
+	for (i=parmnum+1;
+	     i<num_parameters() &&
+	     parm_table[i].p_class == parm_table[parmnum].p_class &&
+	     parm_table[i].offset == parm_table[parmnum].offset;
+	     i++) {
+		lp_ctx->flags[i] |= FLAG_CMDLINE;
+	}
+
+	if (lp_ctx->s3_fns != NULL) {
+		lp_ctx->s3_fns->store_cmdline(pszParmName, pszParmValue);
+	}
+
+	return true;
+}
+
+/*
+  set a option from the commandline in 'a=b' format. Use to support --option
+*/
+bool lpcfg_set_option(struct loadparm_context *lp_ctx, const char *option)
+{
+	char *p, *s;
+	bool ret;
+
+	s = talloc_strdup(NULL, option);
+	if (!s) {
+		return false;
+	}
+
+	p = strchr(s, '=');
+	if (!p) {
+		talloc_free(s);
+		return false;
+	}
+
+	*p = 0;
+
+	ret = lpcfg_set_cmdline(lp_ctx, s, p+1);
+	talloc_free(s);
+	return ret;
+}
+
+
+#define BOOLSTR(b) ((b) ? "Yes" : "No")
+
+/**
+ * Print a parameter of the specified type.
+ */
+
+void lpcfg_print_parameter(struct parm_struct *p, void *ptr, FILE * f)
+{
+	/* For the seperation of lists values that we print below */
+	const char *list_sep = ", ";
+	int i;
+	switch (p->type)
+	{
+		case P_ENUM:
+			for (i = 0; p->enum_list[i].name; i++) {
+				if (*(int *)ptr == p->enum_list[i].value) {
+					fprintf(f, "%s",
+						p->enum_list[i].name);
+					break;
+				}
+			}
+			break;
+
+		case P_BOOL:
+			fprintf(f, "%s", BOOLSTR(*(bool *)ptr));
+			break;
+
+		case P_BOOLREV:
+			fprintf(f, "%s", BOOLSTR(!*(bool *)ptr));
+			break;
+
+		case P_INTEGER:
+		case P_BYTES:
+			fprintf(f, "%d", *(int *)ptr);
+			break;
+
+		case P_CHAR:
+			fprintf(f, "%c", *(char *)ptr);
+			break;
+
+		case P_OCTAL: {
+			int val = *(int *)ptr; 
+			if (val == -1) {
+				fprintf(f, "-1");
+			} else {
+				fprintf(f, "0%03o", val);
+			}
+			break;
+		}
+
+		case P_CMDLIST:
+			list_sep = " ";
+
+			FALL_THROUGH;
+		case P_LIST:
+			if ((char ***)ptr && *(char ***)ptr) {
+				char **list = *(char ***)ptr;
+				for (; *list; list++) {
+					/* surround strings with whitespace in double quotes */
+					if (*(list+1) == NULL) {
+						/* last item, no extra separator */
+						list_sep = "";
+					}
+					if ( strchr_m( *list, ' ' ) ) {
+						fprintf(f, "\"%s\"%s", *list, list_sep);
+					} else {
+						fprintf(f, "%s%s", *list, list_sep);
+					}
+				}
+			}
+			break;
+
+		case P_STRING:
+		case P_USTRING:
+			if (*(char **)ptr) {
+				fprintf(f, "%s", *(char **)ptr);
+			}
+			break;
+	}
+}
+
+/**
+ * Check if two parameters are equal.
+ */
+
+static bool lpcfg_equal_parameter(parm_type type, void *ptr1, void *ptr2)
+{
+	switch (type) {
+		case P_BOOL:
+		case P_BOOLREV:
+			return (*((bool *)ptr1) == *((bool *)ptr2));
+
+		case P_INTEGER:
+		case P_ENUM:
+		case P_OCTAL:
+		case P_BYTES:
+			return (*((int *)ptr1) == *((int *)ptr2));
+
+		case P_CHAR:
+			return (*((char *)ptr1) == *((char *)ptr2));
+
+		case P_LIST:
+		case P_CMDLIST:
+			return str_list_equal(*(const char ***)ptr1, *(const char ***)ptr2);
+
+		case P_STRING:
+		case P_USTRING:
+		{
+			char *p1 = *(char **)ptr1, *p2 = *(char **)ptr2;
+			if (p1 && !*p1)
+				p1 = NULL;
+			if (p2 && !*p2)
+				p2 = NULL;
+			return (p1 == p2 || strequal(p1, p2));
+		}
+	}
+	return false;
+}
+
+/**
+ * Process a new section (service).
+ *
+ * At this stage all sections are services.
+ * Later we'll have special sections that permit server parameters to be set.
+ * Returns True on success, False on failure.
+ */
+
+static bool do_section(const char *pszSectionName, void *userdata)
+{
+	struct loadparm_context *lp_ctx = (struct loadparm_context *)userdata;
+	bool bRetval;
+	bool isglobal;
+
+	if (lp_ctx->s3_fns != NULL) {
+		return lp_ctx->s3_fns->do_section(pszSectionName, lp_ctx);
+	}
+
+	isglobal = ((strwicmp(pszSectionName, GLOBAL_NAME) == 0) ||
+			 (strwicmp(pszSectionName, GLOBAL_NAME2) == 0));
+
+	/* if we've just struck a global section, note the fact. */
+	lp_ctx->bInGlobalSection = isglobal;
+
+	/* check for multiple global sections */
+	if (lp_ctx->bInGlobalSection) {
+		DEBUG(4, ("Processing section \"[%s]\"\n", pszSectionName));
+		bRetval = true;
+		goto out;
+	}
+
+	/* if we have a current service, tidy it up before moving on */
+	bRetval = true;
+
+	if (lp_ctx->currentService != NULL)
+		bRetval = lpcfg_service_ok(lp_ctx->currentService);
+
+	/* if all is still well, move to the next record in the services array */
+	if (bRetval) {
+		/* We put this here to avoid an odd message order if messages are */
+		/* issued by the post-processing of a previous section. */
+		DEBUG(4, ("Processing section \"[%s]\"\n", pszSectionName));
+
+		if ((lp_ctx->currentService = lpcfg_add_service(lp_ctx, lp_ctx->sDefault,
+								   pszSectionName))
+		    == NULL) {
+			DEBUG(0, ("Failed to add a new service\n"));
+			bRetval = false;
+			goto out;
+		}
+	}
+out:
+	return bRetval;
+}
+
+
+/**
+ * Determine if a particular base parameter is currently set to the default value.
+ */
+
+static bool is_default(void *base_structure, int i)
+{
+	void *def_ptr = ((char *)base_structure) + parm_table[i].offset;
+	switch (parm_table[i].type) {
+		case P_CMDLIST:
+		case P_LIST:
+			return str_list_equal((const char * const *)parm_table[i].def.lvalue,
+					      *(const char * const **)def_ptr);
+		case P_STRING:
+		case P_USTRING:
+			return strequal(parm_table[i].def.svalue,
+					*(char **)def_ptr);
+		case P_BOOL:
+		case P_BOOLREV:
+			return parm_table[i].def.bvalue ==
+				*(bool *)def_ptr;
+		case P_INTEGER:
+		case P_CHAR:
+		case P_OCTAL:
+		case P_BYTES:
+		case P_ENUM:
+			return parm_table[i].def.ivalue ==
+				*(int *)def_ptr;
+	}
+	return false;
+}
+
+/**
+ *Display the contents of the global structure.
+ */
+
+void lpcfg_dump_globals(struct loadparm_context *lp_ctx, FILE *f,
+			 bool show_defaults)
+{
+	int i;
+	struct parmlist_entry *data;
+
+	fprintf(f, "# Global parameters\n[global]\n");
+
+	for (i = 0; parm_table[i].label; i++) {
+		if (parm_table[i].p_class != P_GLOBAL) {
+			continue;
+		}
+
+		if (parm_table[i].flags & FLAG_SYNONYM) {
+			continue;
+		}
+
+		if (!show_defaults) {
+			if (lp_ctx->flags && (lp_ctx->flags[i] & FLAG_DEFAULT)) {
+				continue;
+			}
+
+			if (is_default(lp_ctx->globals, i)) {
+				continue;
+			}
+		}
+
+		fprintf(f, "\t%s = ", parm_table[i].label);
+		lpcfg_print_parameter(&parm_table[i], lpcfg_parm_ptr(lp_ctx, NULL, &parm_table[i]), f);
+		fprintf(f, "\n");
+	}
+	if (lp_ctx->globals->param_opt != NULL) {
+		for (data = lp_ctx->globals->param_opt; data;
+		     data = data->next) {
+			if (!show_defaults && (data->priority & FLAG_DEFAULT)) {
+				continue;
+			}
+			fprintf(f, "\t%s = %s\n", data->key, data->value);
+		}
+        }
+
+}
+
+/**
+ * Display the contents of a single services record.
+ */
+
+void lpcfg_dump_a_service(struct loadparm_service * pService, struct loadparm_service *sDefault, FILE * f,
+			  unsigned int *flags, bool show_defaults)
+{
+	int i;
+	struct parmlist_entry *data;
+
+	if (pService != sDefault)
+		fprintf(f, "\n[%s]\n", pService->szService);
+
+	for (i = 0; parm_table[i].label; i++) {
+		if (parm_table[i].p_class != P_LOCAL) {
+			continue;
+		}
+
+		if (parm_table[i].flags & FLAG_SYNONYM) {
+			continue;
+		}
+
+		if (*parm_table[i].label == '-') {
+			continue;
+		}
+
+		if (pService == sDefault) {
+			if (!show_defaults) {
+				if (flags && (flags[i] & FLAG_DEFAULT)) {
+					continue;
+				}
+
+				if (is_default(sDefault, i)) {
+					continue;
+				}
+			}
+		} else {
+			bool equal;
+
+			equal = lpcfg_equal_parameter(parm_table[i].type,
+						      ((char *)pService) +
+						      parm_table[i].offset,
+						      ((char *)sDefault) +
+						      parm_table[i].offset);
+			if (equal) {
+				continue;
+			}
+		}
+
+		fprintf(f, "\t%s = ", parm_table[i].label);
+		lpcfg_print_parameter(&parm_table[i],
+				((char *)pService) + parm_table[i].offset, f);
+		fprintf(f, "\n");
+	}
+	if (pService->param_opt != NULL) {
+		for (data = pService->param_opt; data; data = data->next) {
+			if (!show_defaults && (data->priority & FLAG_DEFAULT)) {
+				continue;
+			}
+			fprintf(f, "\t%s = %s\n", data->key, data->value);
+		}
+        }
+}
+
+bool lpcfg_dump_a_parameter(struct loadparm_context *lp_ctx,
+			    struct loadparm_service *service,
+			    const char *parm_name, FILE * f)
+{
+	struct parm_struct *parm;
+	void *ptr;
+	char *local_parm_name;
+	char *parm_opt;
+	const char *parm_opt_value;
+
+	/* check for parametrical option */
+	local_parm_name = talloc_strdup(lp_ctx, parm_name);
+	if (local_parm_name == NULL) {
+		return false;
+	}
+
+	parm_opt = strchr( local_parm_name, ':');
+
+	if (parm_opt) {
+		*parm_opt = '\0';
+		parm_opt++;
+		if (strlen(parm_opt)) {
+			parm_opt_value = lpcfg_parm_string(lp_ctx, service,
+				local_parm_name, parm_opt);
+			if (parm_opt_value) {
+				fprintf(f, "%s\n", parm_opt_value);
+				TALLOC_FREE(local_parm_name);
+				return true;
+			}
+		}
+		TALLOC_FREE(local_parm_name);
+		return false;
+	}
+	TALLOC_FREE(local_parm_name);
+
+	/* parameter is not parametric, search the table */
+	parm = lpcfg_parm_struct(lp_ctx, parm_name);
+	if (!parm) {
+		return false;
+	}
+
+	if (service != NULL && parm->p_class == P_GLOBAL) {
+		return false;
+	}
+
+	ptr = lpcfg_parm_ptr(lp_ctx, service,parm);
+
+	lpcfg_print_parameter(parm, ptr, f);
+	fprintf(f, "\n");
+	return true;
+}
+
+/**
+ * Auto-load some home services.
+ */
+static void lpcfg_add_auto_services(struct loadparm_context *lp_ctx,
+				    const char *str)
+{
+	return;
+}
+
+/***************************************************************************
+ Initialise the sDefault parameter structure for the printer values.
+***************************************************************************/
+
+void init_printer_values(struct loadparm_context *lp_ctx, TALLOC_CTX *ctx,
+			 struct loadparm_service *pService)
+{
+	/* choose defaults depending on the type of printing */
+	switch (pService->printing) {
+		case PRINT_BSD:
+		case PRINT_AIX:
+		case PRINT_LPRNT:
+		case PRINT_LPROS2:
+			lpcfg_string_set(ctx, &pService->lpq_command, "lpq -P'%p'");
+			lpcfg_string_set(ctx, &pService->lprm_command, "lprm -P'%p' %j");
+			lpcfg_string_set(ctx, &pService->print_command, "lpr -r -P'%p' %s");
+			break;
+
+		case PRINT_LPRNG:
+		case PRINT_PLP:
+			lpcfg_string_set(ctx, &pService->lpq_command, "lpq -P'%p'");
+			lpcfg_string_set(ctx, &pService->lprm_command, "lprm -P'%p' %j");
+			lpcfg_string_set(ctx, &pService->print_command, "lpr -r -P'%p' %s");
+			lpcfg_string_set(ctx, &pService->queuepause_command, "lpc stop '%p'");
+			lpcfg_string_set(ctx, &pService->queueresume_command, "lpc start '%p'");
+			lpcfg_string_set(ctx, &pService->lppause_command, "lpc hold '%p' %j");
+			lpcfg_string_set(ctx, &pService->lpresume_command, "lpc release '%p' %j");
+			break;
+
+		case PRINT_CUPS:
+		case PRINT_IPRINT:
+			/* set the lpq command to contain the destination printer
+			   name only.  This is used by cups_queue_get() */
+			lpcfg_string_set(ctx, &pService->lpq_command, "%p");
+			lpcfg_string_set(ctx, &pService->lprm_command, "");
+			lpcfg_string_set(ctx, &pService->print_command, "");
+			lpcfg_string_set(ctx, &pService->lppause_command, "");
+			lpcfg_string_set(ctx, &pService->lpresume_command, "");
+			lpcfg_string_set(ctx, &pService->queuepause_command, "");
+			lpcfg_string_set(ctx, &pService->queueresume_command, "");
+			break;
+
+		case PRINT_SYSV:
+		case PRINT_HPUX:
+			lpcfg_string_set(ctx, &pService->lpq_command, "lpstat -o%p");
+			lpcfg_string_set(ctx, &pService->lprm_command, "cancel %p-%j");
+			lpcfg_string_set(ctx, &pService->print_command, "lp -c -d%p %s; rm %s");
+			lpcfg_string_set(ctx, &pService->queuepause_command, "disable %p");
+			lpcfg_string_set(ctx, &pService->queueresume_command, "enable %p");
+#ifndef HPUX
+			lpcfg_string_set(ctx, &pService->lppause_command, "lp -i %p-%j -H hold");
+			lpcfg_string_set(ctx, &pService->lpresume_command, "lp -i %p-%j -H resume");
+#endif /* HPUX */
+			break;
+
+		case PRINT_QNX:
+			lpcfg_string_set(ctx, &pService->lpq_command, "lpq -P%p");
+			lpcfg_string_set(ctx, &pService->lprm_command, "lprm -P%p %j");
+			lpcfg_string_set(ctx, &pService->print_command, "lp -r -P%p %s");
+			break;
+
+#if defined(DEVELOPER) || defined(ENABLE_SELFTEST)
+
+	case PRINT_TEST:
+	case PRINT_VLP: {
+		const char *tdbfile;
+		TALLOC_CTX *tmp_ctx = talloc_new(ctx);
+		const char *tmp;
+
+		tmp = lpcfg_parm_string(lp_ctx, NULL, "vlp", "tdbfile");
+		if (tmp == NULL) {
+			tmp = "/tmp/vlp.tdb";
+		}
+
+		tdbfile = talloc_asprintf(tmp_ctx, "tdbfile=%s", tmp);
+		if (tdbfile == NULL) {
+			tdbfile="tdbfile=/tmp/vlp.tdb";
+		}
+
+		tmp = talloc_asprintf(tmp_ctx, "vlp %s print %%p %%s",
+				      tdbfile);
+		lpcfg_string_set(ctx, &pService->print_command,
+			   tmp ? tmp : "vlp print %p %s");
+
+		tmp = talloc_asprintf(tmp_ctx, "vlp %s lpq %%p",
+				      tdbfile);
+		lpcfg_string_set(ctx, &pService->lpq_command,
+			   tmp ? tmp : "vlp lpq %p");
+
+		tmp = talloc_asprintf(tmp_ctx, "vlp %s lprm %%p %%j",
+				      tdbfile);
+		lpcfg_string_set(ctx, &pService->lprm_command,
+			   tmp ? tmp : "vlp lprm %p %j");
+
+		tmp = talloc_asprintf(tmp_ctx, "vlp %s lppause %%p %%j",
+				      tdbfile);
+		lpcfg_string_set(ctx, &pService->lppause_command,
+			   tmp ? tmp : "vlp lppause %p %j");
+
+		tmp = talloc_asprintf(tmp_ctx, "vlp %s lpresume %%p %%j",
+				      tdbfile);
+		lpcfg_string_set(ctx, &pService->lpresume_command,
+			   tmp ? tmp : "vlp lpresume %p %j");
+
+		tmp = talloc_asprintf(tmp_ctx, "vlp %s queuepause %%p",
+				      tdbfile);
+		lpcfg_string_set(ctx, &pService->queuepause_command,
+			   tmp ? tmp : "vlp queuepause %p");
+
+		tmp = talloc_asprintf(tmp_ctx, "vlp %s queueresume %%p",
+				      tdbfile);
+		lpcfg_string_set(ctx, &pService->queueresume_command,
+			   tmp ? tmp : "vlp queueresume %p");
+		TALLOC_FREE(tmp_ctx);
+
+		break;
+	}
+#endif /* DEVELOPER */
+
+	}
+}
+
+
+static int lpcfg_destructor(struct loadparm_context *lp_ctx)
+{
+	struct parmlist_entry *data;
+
+	if (lp_ctx->refuse_free) {
+		/* someone is trying to free the
+		   global_loadparm_context.
+		   We can't allow that. */
+		return -1;
+	}
+
+	if (lp_ctx->globals->param_opt != NULL) {
+		struct parmlist_entry *next;
+		for (data = lp_ctx->globals->param_opt; data; data=next) {
+			next = data->next;
+			if (data->priority & FLAG_CMDLINE) continue;
+			DLIST_REMOVE(lp_ctx->globals->param_opt, data);
+			talloc_free(data);
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * Initialise the global parameter structure.
+ *
+ * Note that most callers should use loadparm_init_global() instead
+ */
+struct loadparm_context *loadparm_init(TALLOC_CTX *mem_ctx)
+{
+	int i;
+	char *myname;
+	struct loadparm_context *lp_ctx;
+	struct parmlist_entry *parm;
+	char *logfile;
+
+	lp_ctx = talloc_zero(mem_ctx, struct loadparm_context);
+	if (lp_ctx == NULL)
+		return NULL;
+
+	talloc_set_destructor(lp_ctx, lpcfg_destructor);
+	lp_ctx->bInGlobalSection = true;
+	lp_ctx->globals = talloc_zero(lp_ctx, struct loadparm_global);
+	/* This appears odd, but globals in s3 isn't a pointer */
+	lp_ctx->globals->ctx = lp_ctx->globals;
+	lp_ctx->globals->rpc_low_port = SERVER_TCP_LOW_PORT;
+	lp_ctx->globals->rpc_high_port = SERVER_TCP_HIGH_PORT;
+	lp_ctx->globals->weak_crypto = SAMBA_WEAK_CRYPTO_UNKNOWN;
+	lp_ctx->sDefault = talloc_zero(lp_ctx, struct loadparm_service);
+	lp_ctx->flags = talloc_zero_array(lp_ctx, unsigned int, num_parameters());
+
+	lp_ctx->sDefault->max_print_jobs = 1000;
+	lp_ctx->sDefault->available = true;
+	lp_ctx->sDefault->browseable = true;
+	lp_ctx->sDefault->read_only = true;
+	lp_ctx->sDefault->map_archive = true;
+	lp_ctx->sDefault->strict_locking = true;
+	lp_ctx->sDefault->oplocks = true;
+	lp_ctx->sDefault->create_mask = 0744;
+	lp_ctx->sDefault->force_create_mode = 0000;
+	lp_ctx->sDefault->directory_mask = 0755;
+	lp_ctx->sDefault->force_directory_mode = 0000;
+	lp_ctx->sDefault->aio_read_size = 1;
+	lp_ctx->sDefault->aio_write_size = 1;
+	lp_ctx->sDefault->smbd_search_ask_sharemode = true;
+	lp_ctx->sDefault->smbd_getinfo_ask_sharemode = true;
+	lp_ctx->sDefault->volume_serial_number = -1;
+
+	DEBUG(3, ("Initialising global parameters\n"));
+
+	for (i = 0; parm_table[i].label; i++) {
+		if ((parm_table[i].type == P_STRING ||
+		     parm_table[i].type == P_USTRING) &&
+		    !(lp_ctx->flags[i] & FLAG_CMDLINE)) {
+			TALLOC_CTX *parent_mem;
+			char **r;
+			if (parm_table[i].p_class == P_LOCAL) {
+				parent_mem = lp_ctx->sDefault;
+				r = (char **)(((char *)lp_ctx->sDefault) + parm_table[i].offset);
+			} else {
+				parent_mem = lp_ctx->globals;
+				r = (char **)(((char *)lp_ctx->globals) + parm_table[i].offset);
+			}
+			lpcfg_string_set(parent_mem, r, "");
+		}
+	}
+
+	logfile = talloc_asprintf(lp_ctx, "%s/log.samba", dyn_LOGFILEBASE);
+	lpcfg_do_global_parameter(lp_ctx, "log file", logfile);
+	talloc_free(logfile);
+
+	lpcfg_do_global_parameter(lp_ctx, "log level", "0");
+
+	lpcfg_do_global_parameter(lp_ctx, "syslog", "1");
+	lpcfg_do_global_parameter(lp_ctx, "syslog only", "No");
+	lpcfg_do_global_parameter(lp_ctx, "debug timestamp", "Yes");
+	lpcfg_do_global_parameter(lp_ctx, "debug prefix timestamp", "No");
+	lpcfg_do_global_parameter(lp_ctx, "debug hires timestamp", "Yes");
+	lpcfg_do_global_parameter(lp_ctx, "debug syslog format", "No");
+	lpcfg_do_global_parameter(lp_ctx, "debug pid", "No");
+	lpcfg_do_global_parameter(lp_ctx, "debug uid", "No");
+	lpcfg_do_global_parameter(lp_ctx, "debug class", "No");
+
+	lpcfg_do_global_parameter(lp_ctx, "server role", "auto");
+	lpcfg_do_global_parameter(lp_ctx, "domain logons", "No");
+	lpcfg_do_global_parameter(lp_ctx, "domain master", "Auto");
+
+	/* options that can be set on the command line must be initialised via
+	   the slower lpcfg_do_global_parameter() to ensure that FLAG_CMDLINE is obeyed */
+#ifdef TCP_NODELAY
+	lpcfg_do_global_parameter(lp_ctx, "socket options", "TCP_NODELAY");
+#endif
+	lpcfg_do_global_parameter(lp_ctx, "workgroup", DEFAULT_WORKGROUP);
+	myname = get_myname(lp_ctx);
+	lpcfg_do_global_parameter(lp_ctx, "netbios name", myname);
+	talloc_free(myname);
+	lpcfg_do_global_parameter(lp_ctx,
+				  "name resolve order",
+				  DEFAULT_NAME_RESOLVE_ORDER);
+
+	lpcfg_do_global_parameter(lp_ctx, "fstype", "NTFS");
+
+	lpcfg_do_global_parameter(lp_ctx, "ntvfs handler", "unixuid default");
+	lpcfg_do_global_parameter(lp_ctx, "max connections", "0");
+
+	lpcfg_do_global_parameter(lp_ctx, "dcerpc endpoint servers", "epmapper wkssvc rpcecho samr netlogon lsarpc drsuapi dssetup unixinfo browser eventlog6 backupkey dnsserver");
+	lpcfg_do_global_parameter(lp_ctx, "server services", "s3fs rpc nbt wrepl ldap cldap kdc drepl winbindd ntp_signd kcc dnsupdate dns");
+	lpcfg_do_global_parameter(lp_ctx, "kccsrv:samba_kcc", "true");
+	/* the winbind method for domain controllers is for both RODC
+	   auth forwarding and for trusted domains */
+	lpcfg_do_global_parameter(lp_ctx, "private dir", dyn_PRIVATE_DIR);
+	lpcfg_do_global_parameter(lp_ctx, "binddns dir", dyn_BINDDNS_DIR);
+	lpcfg_do_global_parameter(lp_ctx, "registry:HKEY_LOCAL_MACHINE", "hklm.ldb");
+
+	/* This hive should be dynamically generated by Samba using
+	   data from the sam, but for the moment leave it in a tdb to
+	   keep regedt32 from popping up an annoying dialog. */
+	lpcfg_do_global_parameter(lp_ctx, "registry:HKEY_USERS", "hku.ldb");
+
+	/* using UTF8 by default allows us to support all chars */
+	lpcfg_do_global_parameter(lp_ctx, "unix charset", "UTF-8");
+
+	/* Use codepage 850 as a default for the dos character set */
+	lpcfg_do_global_parameter(lp_ctx, "dos charset", "CP850");
+
+	/*
+	 * Allow the default PASSWD_CHAT to be overridden in local.h.
+	 */
+	lpcfg_do_global_parameter(lp_ctx, "passwd chat", DEFAULT_PASSWD_CHAT);
+
+	lpcfg_do_global_parameter(lp_ctx, "pid directory", dyn_PIDDIR);
+	lpcfg_do_global_parameter(lp_ctx, "lock dir", dyn_LOCKDIR);
+	lpcfg_do_global_parameter(lp_ctx, "state directory", dyn_STATEDIR);
+	lpcfg_do_global_parameter(lp_ctx, "cache directory", dyn_CACHEDIR);
+	lpcfg_do_global_parameter(lp_ctx, "ncalrpc dir", dyn_NCALRPCDIR);
+
+	lpcfg_do_global_parameter(lp_ctx, "nbt client socket address", "0.0.0.0");
+	lpcfg_do_global_parameter_var(lp_ctx, "server string",
+				   "Samba %s", SAMBA_VERSION_STRING);
+
+	lpcfg_do_global_parameter(lp_ctx, "password server", "*");
+
+	lpcfg_do_global_parameter(lp_ctx, "max mux", "50");
+	lpcfg_do_global_parameter(lp_ctx, "max xmit", "16644");
+	lpcfg_do_global_parameter(lp_ctx, "host msdfs", "true");
+
+	lpcfg_do_global_parameter(lp_ctx, "LargeReadwrite", "True");
+	lpcfg_do_global_parameter(lp_ctx, "server min protocol", "SMB2_02");
+	lpcfg_do_global_parameter(lp_ctx, "server max protocol", "SMB3");
+	lpcfg_do_global_parameter(lp_ctx, "client min protocol", "SMB2_02");
+	lpcfg_do_global_parameter(lp_ctx, "client max protocol", "default");
+	lpcfg_do_global_parameter(lp_ctx, "client ipc min protocol", "default");
+	lpcfg_do_global_parameter(lp_ctx, "client ipc max protocol", "default");
+	lpcfg_do_global_parameter(lp_ctx, "security", "AUTO");
+	lpcfg_do_global_parameter(lp_ctx, "EncryptPasswords", "True");
+	lpcfg_do_global_parameter(lp_ctx, "ReadRaw", "True");
+	lpcfg_do_global_parameter(lp_ctx, "WriteRaw", "True");
+	lpcfg_do_global_parameter(lp_ctx, "NullPasswords", "False");
+	lpcfg_do_global_parameter(lp_ctx, "old password allowed period", "60");
+	lpcfg_do_global_parameter(lp_ctx, "ObeyPamRestrictions", "False");
+
+	lpcfg_do_global_parameter(lp_ctx, "TimeServer", "False");
+	lpcfg_do_global_parameter(lp_ctx, "BindInterfacesOnly", "False");
+	lpcfg_do_global_parameter(lp_ctx, "Unicode", "True");
+	lpcfg_do_global_parameter(lp_ctx, "ClientLanManAuth", "False");
+	lpcfg_do_global_parameter(lp_ctx, "ClientNTLMv2Auth", "True");
+	lpcfg_do_global_parameter(lp_ctx, "LanmanAuth", "False");
+	lpcfg_do_global_parameter(lp_ctx, "NTLMAuth", "ntlmv2-only");
+	lpcfg_do_global_parameter(lp_ctx, "NT hash store", "always");
+	lpcfg_do_global_parameter(lp_ctx, "RawNTLMv2Auth", "False");
+	lpcfg_do_global_parameter(lp_ctx, "client use spnego principal", "False");
+
+	lpcfg_do_global_parameter(lp_ctx, "allow dcerpc auth level connect", "False");
+
+	lpcfg_do_global_parameter(lp_ctx, "UnixExtensions", "True");
+
+	lpcfg_do_global_parameter(lp_ctx, "PreferredMaster", "Auto");
+	lpcfg_do_global_parameter(lp_ctx, "LocalMaster", "True");
+
+	lpcfg_do_global_parameter(lp_ctx, "wins support", "False");
+	lpcfg_do_global_parameter(lp_ctx, "dns proxy", "True");
+
+	lpcfg_do_global_parameter(lp_ctx, "winbind separator", "\\");
+	lpcfg_do_global_parameter(lp_ctx, "winbind sealed pipes", "True");
+	lpcfg_do_global_parameter(lp_ctx, "winbind scan trusted domains", "False");
+	lpcfg_do_global_parameter(lp_ctx, "require strong key", "True");
+	lpcfg_do_global_parameter(lp_ctx, "reject md5 servers", "True");
+	lpcfg_do_global_parameter(lp_ctx, "winbindd socket directory", dyn_WINBINDD_SOCKET_DIR);
+	lpcfg_do_global_parameter(lp_ctx, "ntp signd socket directory", dyn_NTP_SIGND_SOCKET_DIR);
+	lpcfg_do_global_parameter_var(lp_ctx, "gpo update command", "%s/samba-gpupdate", dyn_SCRIPTSBINDIR);
+	lpcfg_do_global_parameter_var(lp_ctx, "apply group policies", "False");
+	lpcfg_do_global_parameter_var(lp_ctx, "dns update command", "%s/samba_dnsupdate", dyn_SCRIPTSBINDIR);
+	lpcfg_do_global_parameter_var(lp_ctx, "spn update command", "%s/samba_spnupdate", dyn_SCRIPTSBINDIR);
+	lpcfg_do_global_parameter_var(lp_ctx, "samba kcc command",
+					"%s/samba_kcc", dyn_SCRIPTSBINDIR);
+#ifdef MIT_KDC_PATH
+	lpcfg_do_global_parameter_var(lp_ctx,
+				      "mit kdc command",
+				      MIT_KDC_PATH);
+#endif
+	lpcfg_do_global_parameter(lp_ctx, "template shell", "/bin/false");
+	lpcfg_do_global_parameter(lp_ctx, "template homedir", "/home/%D/%U");
+
+	lpcfg_do_global_parameter(lp_ctx, "client signing", "default");
+	lpcfg_do_global_parameter(lp_ctx, "client ipc signing", "default");
+	lpcfg_do_global_parameter(lp_ctx, "server signing", "default");
+
+	lpcfg_do_global_parameter(lp_ctx, "use mmap", "True");
+
+	lpcfg_do_global_parameter(lp_ctx, "smb ports", "445 139");
+	lpcfg_do_global_parameter_var(lp_ctx, "nbt port", "%d", NBT_NAME_SERVICE_PORT);
+	lpcfg_do_global_parameter_var(lp_ctx, "dgram port", "%d", NBT_DGRAM_SERVICE_PORT);
+	lpcfg_do_global_parameter(lp_ctx, "cldap port", "389");
+	lpcfg_do_global_parameter(lp_ctx, "krb5 port", "88");
+	lpcfg_do_global_parameter(lp_ctx, "kpasswd port", "464");
+	lpcfg_do_global_parameter_var(lp_ctx, "dns port", "%d", DNS_SERVICE_PORT);
+
+	lpcfg_do_global_parameter(lp_ctx, "kdc enable fast", "True");
+
+	lpcfg_do_global_parameter(lp_ctx, "nt status support", "True");
+
+	lpcfg_do_global_parameter(lp_ctx, "max wins ttl", "518400"); /* 6 days */
+	lpcfg_do_global_parameter(lp_ctx, "min wins ttl", "21600");
+
+	lpcfg_do_global_parameter(lp_ctx, "tls enabled", "True");
+	lpcfg_do_global_parameter(lp_ctx, "tls verify peer", "as_strict_as_possible");
+	lpcfg_do_global_parameter(lp_ctx, "tls keyfile", "tls/key.pem");
+	lpcfg_do_global_parameter(lp_ctx, "tls certfile", "tls/cert.pem");
+	lpcfg_do_global_parameter(lp_ctx, "tls cafile", "tls/ca.pem");
+	lpcfg_do_global_parameter(lp_ctx,
+				  "tls priority",
+				  "NORMAL:-VERS-SSL3.0");
+
+	lpcfg_do_global_parameter(lp_ctx, "nsupdate command", "/usr/bin/nsupdate -g");
+
+        lpcfg_do_global_parameter(lp_ctx, "allow dns updates", "secure only");
+	lpcfg_do_global_parameter(lp_ctx, "dns zone scavenging", "False");
+        lpcfg_do_global_parameter(lp_ctx, "dns forwarder", "");
+
+	lpcfg_do_global_parameter(lp_ctx, "algorithmic rid base", "1000");
+
+	lpcfg_do_global_parameter(lp_ctx, "enhanced browsing", "True");
+
+	lpcfg_do_global_parameter(lp_ctx, "winbind nss info", "template");
+
+	lpcfg_do_global_parameter(lp_ctx, "server schannel", "True");
+	lpcfg_do_global_parameter(lp_ctx, "server schannel require seal", "True");
+	lpcfg_do_global_parameter(lp_ctx, "reject md5 clients", "True");
+
+	lpcfg_do_global_parameter(lp_ctx, "short preserve case", "True");
+
+	lpcfg_do_global_parameter(lp_ctx, "max open files", "16384");
+
+	lpcfg_do_global_parameter(lp_ctx, "cups connection timeout", "30");
+
+	lpcfg_do_global_parameter(lp_ctx, "locking", "True");
+
+	lpcfg_do_global_parameter(lp_ctx, "block size", "1024");
+
+	lpcfg_do_global_parameter(lp_ctx, "client use spnego", "True");
+
+	lpcfg_do_global_parameter(lp_ctx, "change notify", "True");
+
+	lpcfg_do_global_parameter(lp_ctx, "name cache timeout", "660");
+
+	lpcfg_do_global_parameter(lp_ctx, "defer sharing violations", "True");
+
+	lpcfg_do_global_parameter(lp_ctx, "ldap replication sleep", "1000");
+
+	lpcfg_do_global_parameter(lp_ctx, "idmap backend", "tdb");
+
+	lpcfg_do_global_parameter(lp_ctx, "enable privileges", "True");
+
+	lpcfg_do_global_parameter_var(lp_ctx, "smb2 max write", "%u", DEFAULT_SMB2_MAX_WRITE);
+
+	lpcfg_do_global_parameter(lp_ctx, "passdb backend", "tdbsam");
+
+	lpcfg_do_global_parameter(lp_ctx, "deadtime", "10080");
+
+	lpcfg_do_global_parameter(lp_ctx, "getwd cache", "True");
+
+	lpcfg_do_global_parameter(lp_ctx, "winbind nested groups", "True");
+
+	lpcfg_do_global_parameter(lp_ctx, "mangled names", "illegal");
+
+	lpcfg_do_global_parameter_var(lp_ctx, "smb2 max credits", "%u", DEFAULT_SMB2_MAX_CREDITS);
+
+	lpcfg_do_global_parameter(lp_ctx, "ldap ssl", "start tls");
+
+	lpcfg_do_global_parameter(lp_ctx, "ldap deref", "auto");
+
+	lpcfg_do_global_parameter(lp_ctx, "lm interval", "60");
+
+	lpcfg_do_global_parameter(lp_ctx, "mangling method", "hash2");
+
+	lpcfg_do_global_parameter(lp_ctx, "hide dot files", "True");
+
+	lpcfg_do_global_parameter(lp_ctx, "browse list", "True");
+
+	lpcfg_do_global_parameter(lp_ctx, "passwd chat timeout", "2");
+
+	lpcfg_do_global_parameter(lp_ctx, "guest account", GUEST_ACCOUNT);
+
+	lpcfg_do_global_parameter(lp_ctx, "client schannel", "True");
+
+	lpcfg_do_global_parameter(lp_ctx, "smb encrypt", "default");
+
+	lpcfg_do_global_parameter(lp_ctx, "max log size", "5000");
+
+	lpcfg_do_global_parameter(lp_ctx, "idmap negative cache time", "120");
+
+	lpcfg_do_global_parameter(lp_ctx, "ldap follow referral", "auto");
+
+	lpcfg_do_global_parameter(lp_ctx, "multicast dns register", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "winbind reconnect delay", "30");
+
+	lpcfg_do_global_parameter(lp_ctx, "winbind request timeout", "60");
+
+	lpcfg_do_global_parameter(lp_ctx, "nt acl support", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "acl check permissions", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "keepalive", "300");
+
+	lpcfg_do_global_parameter(lp_ctx, "smbd profiling level", "off");
+
+	lpcfg_do_global_parameter(lp_ctx, "winbind cache time", "300");
+
+	lpcfg_do_global_parameter(lp_ctx, "level2 oplocks", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "show add printer wizard", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "ldap page size", "1000");
+
+	lpcfg_do_global_parameter(lp_ctx, "kernel share modes", "no");
+
+	lpcfg_do_global_parameter(lp_ctx, "strict locking", "Auto");
+
+	lpcfg_do_global_parameter(lp_ctx, "strict sync", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "map readonly", "no");
+
+	lpcfg_do_global_parameter(lp_ctx, "allow trusted domains", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "default devmode", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "os level", "20");
+
+	lpcfg_do_global_parameter(lp_ctx, "dos filetimes", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "mangling char", "~");
+
+	lpcfg_do_global_parameter(lp_ctx, "printcap cache time", "750");
+
+	lpcfg_do_global_parameter(lp_ctx, "create krb5 conf", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "winbind max clients", "200");
+
+	lpcfg_do_global_parameter(lp_ctx, "acl map full control", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "nt pipe support", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "ldap debug threshold", "10");
+
+	lpcfg_do_global_parameter(lp_ctx, "client ldap sasl wrapping", "sign");
+
+	lpcfg_do_global_parameter(lp_ctx, "mdns name", "netbios");
+
+	lpcfg_do_global_parameter(lp_ctx, "ldap server require strong auth", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "follow symlinks", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "machine password timeout", "604800");
+
+	lpcfg_do_global_parameter(lp_ctx, "ldap connection timeout", "2");
+
+	lpcfg_do_global_parameter(lp_ctx, "winbind expand groups", "0");
+
+	lpcfg_do_global_parameter(lp_ctx, "stat cache", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "lpq cache time", "30");
+
+	lpcfg_do_global_parameter_var(lp_ctx, "smb2 max trans", "%u", DEFAULT_SMB2_MAX_TRANSACT);
+
+	lpcfg_do_global_parameter_var(lp_ctx, "smb2 max read", "%u", DEFAULT_SMB2_MAX_READ);
+
+	lpcfg_do_global_parameter(lp_ctx, "durable handles", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "max stat cache size", "512");
+
+	lpcfg_do_global_parameter(lp_ctx, "ldap passwd sync", "no");
+
+	lpcfg_do_global_parameter(lp_ctx, "kernel change notify", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "max ttl", "259200");
+
+	lpcfg_do_global_parameter(lp_ctx, "blocking locks", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "load printers", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "idmap cache time", "604800");
+
+	lpcfg_do_global_parameter(lp_ctx, "preserve case", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "lm announce", "auto");
+
+	lpcfg_do_global_parameter(lp_ctx, "afs token lifetime", "604800");
+
+	lpcfg_do_global_parameter(lp_ctx, "enable core files", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "winbind max domain connections", "1");
+
+	lpcfg_do_global_parameter(lp_ctx, "case sensitive", "auto");
+
+	lpcfg_do_global_parameter(lp_ctx, "ldap timeout", "15");
+
+	lpcfg_do_global_parameter(lp_ctx, "mangle prefix", "1");
+
+	lpcfg_do_global_parameter(lp_ctx, "posix locking", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "lock spin time", "200");
+
+	lpcfg_do_global_parameter(lp_ctx, "directory name cache size", "100");
+
+	lpcfg_do_global_parameter(lp_ctx, "nmbd bind explicit broadcast", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "init logon delay", "100");
+
+	lpcfg_do_global_parameter(lp_ctx, "usershare owner only", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "-valid", "yes");
+
+	lpcfg_do_global_parameter_var(lp_ctx, "usershare path", "%s/usershares", get_dyn_STATEDIR());
+
+#ifdef DEVELOPER
+	lpcfg_do_global_parameter_var(lp_ctx, "panic action", "/bin/sleep 999999999");
+#endif
+
+	lpcfg_do_global_parameter(lp_ctx, "smb passwd file", get_dyn_SMB_PASSWD_FILE());
+
+	lpcfg_do_global_parameter(lp_ctx, "logon home", "\\\\%N\\%U");
+
+	lpcfg_do_global_parameter(lp_ctx, "logon path", "\\\\%N\\%U\\profile");
+
+	lpcfg_do_global_parameter(lp_ctx, "printjob username", "%U");
+
+	lpcfg_do_global_parameter(lp_ctx, "aio max threads", "100");
+
+	lpcfg_do_global_parameter(lp_ctx, "smb2 leases", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "server multi channel support", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "kerberos encryption types", "all");
+
+	lpcfg_do_global_parameter(lp_ctx,
+				  "rpc server dynamic port range",
+				  "49152-65535");
+
+	lpcfg_do_global_parameter(lp_ctx, "prefork children", "4");
+	lpcfg_do_global_parameter(lp_ctx, "prefork backoff increment", "10");
+	lpcfg_do_global_parameter(lp_ctx, "prefork maximum backoff", "120");
+
+	lpcfg_do_global_parameter(lp_ctx, "check parent directory delete on close", "no");
+
+	lpcfg_do_global_parameter(lp_ctx, "ea support", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "store dos attributes", "yes");
+
+	lpcfg_do_global_parameter(lp_ctx, "debug encryption", "no");
+
+	lpcfg_do_global_parameter(lp_ctx, "spotlight backend", "noindex");
+
+	lpcfg_do_global_parameter(
+		lp_ctx, "ldap max anonymous request size", "256000");
+	lpcfg_do_global_parameter(
+		lp_ctx, "ldap max authenticated request size", "16777216");
+	lpcfg_do_global_parameter(
+		lp_ctx, "ldap max search request size", "256000");
+
+	/* Async DNS query timeout in seconds. */
+	lpcfg_do_global_parameter(lp_ctx, "async dns timeout", "10");
+
+	lpcfg_do_global_parameter(lp_ctx,
+				  "client smb encrypt",
+				  "default");
+
+	lpcfg_do_global_parameter(lp_ctx,
+				  "client use kerberos",
+				  "desired");
+
+	lpcfg_do_global_parameter(lp_ctx,
+				  "client protection",
+				  "default");
+
+	lpcfg_do_global_parameter(lp_ctx,
+				  "smbd max xattr size",
+				  "65536");
+
+	lpcfg_do_global_parameter(lp_ctx,
+				  "acl flag inherited canonicalization",
+				  "yes");
+
+	lpcfg_do_global_parameter(lp_ctx,
+				  "winbind use krb5 enterprise principals",
+				  "yes");
+
+	lpcfg_do_global_parameter(lp_ctx,
+				  "client smb3 signing algorithms",
+				  DEFAULT_SMB3_SIGNING_ALGORITHMS);
+	lpcfg_do_global_parameter(lp_ctx,
+				  "server smb3 signing algorithms",
+				  DEFAULT_SMB3_SIGNING_ALGORITHMS);
+
+	lpcfg_do_global_parameter(lp_ctx,
+				  "client smb3 encryption algorithms",
+				  DEFAULT_SMB3_ENCRYPTION_ALGORITHMS);
+	lpcfg_do_global_parameter(lp_ctx,
+				  "server smb3 encryption algorithms",
+				  DEFAULT_SMB3_ENCRYPTION_ALGORITHMS);
+
+	lpcfg_do_global_parameter(lp_ctx,
+				  "min domain uid",
+				  "1000");
+
+	lpcfg_do_global_parameter(lp_ctx,
+				  "rpc start on demand helpers",
+				  "yes");
+
+	for (i = 0; parm_table[i].label; i++) {
+		if (!(lp_ctx->flags[i] & FLAG_CMDLINE)) {
+			lp_ctx->flags[i] |= FLAG_DEFAULT;
+		}
+	}
+
+	for (parm=lp_ctx->globals->param_opt; parm; parm=parm->next) {
+		if (!(parm->priority & FLAG_CMDLINE)) {
+			parm->priority |= FLAG_DEFAULT;
+		}
+	}
+
+	for (parm=lp_ctx->sDefault->param_opt; parm; parm=parm->next) {
+		if (!(parm->priority & FLAG_CMDLINE)) {
+			parm->priority |= FLAG_DEFAULT;
+		}
+	}
+
+	return lp_ctx;
+}
+
+/**
+ * Initialise the global parameter structure.
+ */
+struct loadparm_context *loadparm_init_global(bool load_default)
+{
+	if (global_loadparm_context == NULL) {
+		global_loadparm_context = loadparm_init(NULL);
+	}
+	if (global_loadparm_context == NULL) {
+		return NULL;
+	}
+	global_loadparm_context->global = true;
+	if (load_default && !global_loadparm_context->loaded) {
+		lpcfg_load_default(global_loadparm_context);
+	}
+	global_loadparm_context->refuse_free = true;
+	return global_loadparm_context;
+}
+
+/**
+ * Initialise the global parameter structure.
+ */
+struct loadparm_context *loadparm_init_s3(TALLOC_CTX *mem_ctx, 
+					  const struct loadparm_s3_helpers *s3_fns)
+{
+	struct loadparm_context *loadparm_context = talloc_zero(mem_ctx, struct loadparm_context);
+	if (!loadparm_context) {
+		return NULL;
+	}
+	loadparm_context->s3_fns = s3_fns;
+	loadparm_context->globals = s3_fns->globals;
+	loadparm_context->flags = s3_fns->flags;
+
+	return loadparm_context;
+}
+
+const char *lpcfg_configfile(struct loadparm_context *lp_ctx)
+{
+	return lp_ctx->szConfigFile;
+}
+
+const char *lp_default_path(void)
+{
+    if (getenv("SMB_CONF_PATH"))
+        return getenv("SMB_CONF_PATH");
+    else
+        return dyn_CONFIGFILE;
+}
+
+/**
+ * Update the internal state of a loadparm context after settings 
+ * have changed.
+ */
+static bool lpcfg_update(struct loadparm_context *lp_ctx)
+{
+	struct debug_settings settings;
+	int max_protocol, min_protocol;
+	TALLOC_CTX *tmp_ctx;
+	const struct loadparm_substitution *lp_sub =
+		lpcfg_noop_substitution();
+
+	tmp_ctx = talloc_new(lp_ctx);
+	if (tmp_ctx == NULL) {
+		return false;
+	}
+
+	lpcfg_add_auto_services(lp_ctx, lpcfg_auto_services(lp_ctx, lp_sub, tmp_ctx));
+
+	if (!lp_ctx->globals->wins_server_list && lp_ctx->globals->we_are_a_wins_server) {
+		lpcfg_do_global_parameter(lp_ctx, "wins server", "127.0.0.1");
+	}
+
+	if (!lp_ctx->global) {
+		TALLOC_FREE(tmp_ctx);
+		return true;
+	}
+
+	panic_action = lp_ctx->globals->panic_action;
+
+	reload_charcnv(lp_ctx);
+
+	ZERO_STRUCT(settings);
+	/* Add any more debug-related smb.conf parameters created in
+	 * future here */
+	settings.timestamp_logs = lp_ctx->globals->timestamp_logs;
+	settings.debug_prefix_timestamp = lp_ctx->globals->debug_prefix_timestamp;
+	settings.debug_hires_timestamp = lp_ctx->globals->debug_hires_timestamp;
+	settings.debug_syslog_format = lp_ctx->globals->debug_syslog_format;
+	settings.debug_pid = lp_ctx->globals->debug_pid;
+	settings.debug_uid = lp_ctx->globals->debug_uid;
+	settings.debug_class = lp_ctx->globals->debug_class;
+	settings.max_log_size = lp_ctx->globals->max_log_size;
+	debug_set_settings(&settings, lp_ctx->globals->logging,
+			   lp_ctx->globals->syslog,
+			   lp_ctx->globals->syslog_only);
+
+	/* FIXME: This is a bit of a hack, but we can't use a global, since 
+	 * not everything that uses lp also uses the socket library */
+	if (lpcfg_parm_bool(lp_ctx, NULL, "socket", "testnonblock", false)) {
+		setenv("SOCKET_TESTNONBLOCK", "1", 1);
+	} else {
+		unsetenv("SOCKET_TESTNONBLOCK");
+	}
+
+	/* Check if command line max protocol < min protocol, if so
+	 * report a warning to the user.
+	 */
+	max_protocol = lpcfg_client_max_protocol(lp_ctx);
+	min_protocol = lpcfg_client_min_protocol(lp_ctx);
+	if (lpcfg_client_max_protocol(lp_ctx) < lpcfg_client_min_protocol(lp_ctx)) {
+		const char *max_protocolp, *min_protocolp;
+		max_protocolp = lpcfg_get_smb_protocol(max_protocol);
+		min_protocolp = lpcfg_get_smb_protocol(min_protocol);
+		DBG_ERR("Max protocol %s is less than min protocol %s.\n",
+			max_protocolp, min_protocolp);
+	}
+
+	TALLOC_FREE(tmp_ctx);
+	return true;
+}
+
+bool lpcfg_load_default(struct loadparm_context *lp_ctx)
+{
+    const char *path;
+
+    path = lp_default_path();
+
+    if (!file_exist(path)) {
+	    /* We allow the default smb.conf file to not exist, 
+	     * basically the equivalent of an empty file. */
+	    return lpcfg_update(lp_ctx);
+    }
+
+    return lpcfg_load(lp_ctx, path);
+}
+
+/**
+ * Load the services array from the services file.
+ *
+ * Return True on success, False on failure.
+ */
+static bool lpcfg_load_internal(struct loadparm_context *lp_ctx,
+				const char *filename, bool set_global)
+{
+	char *n2;
+	bool bRetval;
+
+	if (lp_ctx->szConfigFile != NULL) {
+		talloc_free(discard_const_p(char, lp_ctx->szConfigFile));
+		lp_ctx->szConfigFile = NULL;
+	}
+
+	lp_ctx->szConfigFile = talloc_strdup(lp_ctx, filename);
+
+	if (lp_ctx->s3_fns) {
+		return lp_ctx->s3_fns->load(filename);
+	}
+
+	lp_ctx->bInGlobalSection = true;
+	n2 = standard_sub_basic(lp_ctx, lp_ctx->szConfigFile);
+	DEBUG(2, ("lpcfg_load: refreshing parameters from %s\n", n2));
+
+	add_to_file_list(lp_ctx, &lp_ctx->file_lists, lp_ctx->szConfigFile, n2);
+
+	/* We get sections first, so have to start 'behind' to make up */
+	lp_ctx->currentService = NULL;
+	bRetval = pm_process(n2, do_section, lpcfg_do_parameter, lp_ctx);
+
+	/* finish up the last section */
+	DEBUG(4, ("pm_process() returned %s\n", BOOLSTR(bRetval)));
+	if (bRetval)
+		if (lp_ctx->currentService != NULL)
+			bRetval = lpcfg_service_ok(lp_ctx->currentService);
+
+	bRetval = bRetval && lpcfg_update(lp_ctx);
+
+	/* we do this unconditionally, so that it happens even
+	   for a missing smb.conf */
+	reload_charcnv(lp_ctx);
+
+	if (bRetval == true && set_global) {
+		/* set this up so that any child python tasks will
+		   find the right smb.conf */
+		setenv("SMB_CONF_PATH", filename, 1);
+
+		/* set the context used by the lp_*() function
+		   varients */
+		global_loadparm_context = lp_ctx;
+		lp_ctx->loaded = true;
+	}
+
+	return bRetval;
+}
+
+bool lpcfg_load_no_global(struct loadparm_context *lp_ctx, const char *filename)
+{
+    return lpcfg_load_internal(lp_ctx, filename, false);
+}
+
+bool lpcfg_load(struct loadparm_context *lp_ctx, const char *filename)
+{
+    return lpcfg_load_internal(lp_ctx, filename, true);
+}
+
+/**
+ * Return the max number of services.
+ */
+
+int lpcfg_numservices(struct loadparm_context *lp_ctx)
+{
+	if (lp_ctx->s3_fns) {
+		return lp_ctx->s3_fns->get_numservices();
+	}
+
+	return lp_ctx->iNumServices;
+}
+
+/**
+ * Display the contents of the services array in human-readable form.
+ */
+
+void lpcfg_dump(struct loadparm_context *lp_ctx, FILE *f, bool show_defaults,
+	     int maxtoprint)
+{
+	int iService;
+
+	if (lp_ctx->s3_fns) {
+		lp_ctx->s3_fns->dump(f, show_defaults, maxtoprint);
+		return;
+	}
+
+	lpcfg_dump_globals(lp_ctx, f, show_defaults);
+
+	lpcfg_dump_a_service(lp_ctx->sDefault, lp_ctx->sDefault, f, lp_ctx->flags, show_defaults);
+
+	for (iService = 0; iService < maxtoprint; iService++)
+		lpcfg_dump_one(f, show_defaults, lp_ctx->services[iService], lp_ctx->sDefault);
+}
+
+/**
+ * Display the contents of one service in human-readable form.
+ */
+void lpcfg_dump_one(FILE *f, bool show_defaults, struct loadparm_service *service, struct loadparm_service *sDefault)
+{
+	if (service != NULL) {
+		if (service->szService[0] == '\0')
+			return;
+		lpcfg_dump_a_service(service, sDefault, f, NULL, show_defaults);
+	}
+}
+
+struct loadparm_service *lpcfg_servicebynum(struct loadparm_context *lp_ctx,
+					    int snum)
+{
+	if (lp_ctx->s3_fns) {
+		return lp_ctx->s3_fns->get_servicebynum(snum);
+	}
+
+	return lp_ctx->services[snum];
+}
+
+struct loadparm_service *lpcfg_service(struct loadparm_context *lp_ctx,
+				    const char *service_name)
+{
+	int iService;
+        char *serviceName;
+
+	if (lp_ctx->s3_fns) {
+		return lp_ctx->s3_fns->get_service(service_name);
+	}
+
+	for (iService = lp_ctx->iNumServices - 1; iService >= 0; iService--) {
+		if (lp_ctx->services[iService] &&
+		    lp_ctx->services[iService]->szService) {
+			/*
+			 * The substitution here is used to support %U is
+			 * service names
+			 */
+			serviceName = standard_sub_basic(
+					lp_ctx->services[iService],
+					lp_ctx->services[iService]->szService);
+			if (strequal(serviceName, service_name)) {
+				talloc_free(serviceName);
+				return lp_ctx->services[iService];
+			}
+			talloc_free(serviceName);
+		}
+	}
+
+	DEBUG(7,("lpcfg_servicenumber: couldn't find %s\n", service_name));
+	return NULL;
+}
+
+const char *lpcfg_servicename(const struct loadparm_service *service)
+{
+	return service ? lpcfg_string((const char *)service->szService) : NULL;
+}
+
+struct smb_iconv_handle *lpcfg_iconv_handle(struct loadparm_context *lp_ctx)
+{
+	if (lp_ctx == NULL) {
+		return get_iconv_handle();
+	}
+	return lp_ctx->iconv_handle;
+}
+
+_PUBLIC_ void reload_charcnv(struct loadparm_context *lp_ctx)
+{
+	if (!lp_ctx->global) {
+		return;
+	}
+
+	lp_ctx->iconv_handle =
+		reinit_iconv_handle(lp_ctx,
+				    lpcfg_dos_charset(lp_ctx),
+				    lpcfg_unix_charset(lp_ctx));
+	if (lp_ctx->iconv_handle == NULL) {
+		smb_panic("reinit_iconv_handle failed");
+	}
+}
+
+_PUBLIC_ char *lpcfg_tls_keyfile(TALLOC_CTX *mem_ctx, struct loadparm_context *lp_ctx)
+{
+	return lpcfg_private_path(mem_ctx, lp_ctx, lpcfg__tls_keyfile(lp_ctx));
+}
+
+_PUBLIC_ char *lpcfg_tls_certfile(TALLOC_CTX *mem_ctx, struct loadparm_context *lp_ctx)
+{
+	return lpcfg_private_path(mem_ctx, lp_ctx, lpcfg__tls_certfile(lp_ctx));
+}
+
+_PUBLIC_ char *lpcfg_tls_cafile(TALLOC_CTX *mem_ctx, struct loadparm_context *lp_ctx)
+{
+	return lpcfg_private_path(mem_ctx, lp_ctx, lpcfg__tls_cafile(lp_ctx));
+}
+
+_PUBLIC_ char *lpcfg_tls_crlfile(TALLOC_CTX *mem_ctx, struct loadparm_context *lp_ctx)
+{
+	return lpcfg_private_path(mem_ctx, lp_ctx, lpcfg__tls_crlfile(lp_ctx));
+}
+
+_PUBLIC_ char *lpcfg_tls_dhpfile(TALLOC_CTX *mem_ctx, struct loadparm_context *lp_ctx)
+{
+	return lpcfg_private_path(mem_ctx, lp_ctx, lpcfg__tls_dhpfile(lp_ctx));
+}
+
+struct gensec_settings *lpcfg_gensec_settings(TALLOC_CTX *mem_ctx, struct loadparm_context *lp_ctx)
+{
+	struct gensec_settings *settings = talloc_zero(mem_ctx, struct gensec_settings);
+	if (settings == NULL)
+		return NULL;
+	SMB_ASSERT(lp_ctx != NULL);
+	settings->lp_ctx = talloc_reference(settings, lp_ctx);
+	settings->target_hostname = lpcfg_parm_string(lp_ctx, NULL, "gensec", "target_hostname");
+	return settings;
+}
+
+int lpcfg_server_role(struct loadparm_context *lp_ctx)
+{
+	int domain_master = lpcfg__domain_master(lp_ctx);
+
+	return lp_find_server_role(lpcfg__server_role(lp_ctx),
+				   lpcfg__security(lp_ctx),
+				   lpcfg__domain_logons(lp_ctx),
+				   (domain_master == true) ||
+				   (domain_master == Auto));
+}
+
+int lpcfg_security(struct loadparm_context *lp_ctx)
+{
+	return lp_find_security(lpcfg__server_role(lp_ctx),
+				lpcfg__security(lp_ctx));
+}
+
+int lpcfg_client_max_protocol(struct loadparm_context *lp_ctx)
+{
+	int client_max_protocol = lpcfg__client_max_protocol(lp_ctx);
+	if (client_max_protocol == PROTOCOL_DEFAULT) {
+		return PROTOCOL_LATEST;
+	}
+	return client_max_protocol;
+}
+
+int lpcfg_client_ipc_min_protocol(struct loadparm_context *lp_ctx)
+{
+	int client_ipc_min_protocol = lpcfg__client_ipc_min_protocol(lp_ctx);
+	if (client_ipc_min_protocol == PROTOCOL_DEFAULT) {
+		client_ipc_min_protocol = lpcfg_client_min_protocol(lp_ctx);
+	}
+	if (client_ipc_min_protocol < PROTOCOL_NT1) {
+		return PROTOCOL_NT1;
+	}
+	return client_ipc_min_protocol;
+}
+
+int lpcfg_client_ipc_max_protocol(struct loadparm_context *lp_ctx)
+{
+	int client_ipc_max_protocol = lpcfg__client_ipc_max_protocol(lp_ctx);
+	if (client_ipc_max_protocol == PROTOCOL_DEFAULT) {
+		return PROTOCOL_LATEST;
+	}
+	if (client_ipc_max_protocol < PROTOCOL_NT1) {
+		return PROTOCOL_NT1;
+	}
+	return client_ipc_max_protocol;
+}
+
+int lpcfg_client_ipc_signing(struct loadparm_context *lp_ctx)
+{
+	int client_ipc_signing = lpcfg__client_ipc_signing(lp_ctx);
+	if (client_ipc_signing == SMB_SIGNING_DEFAULT) {
+		return SMB_SIGNING_REQUIRED;
+	}
+	return client_ipc_signing;
+}
+
+enum credentials_use_kerberos lpcfg_client_use_kerberos(struct loadparm_context *lp_ctx)
+{
+	if (lpcfg_weak_crypto(lp_ctx) == SAMBA_WEAK_CRYPTO_DISALLOWED) {
+		return CRED_USE_KERBEROS_REQUIRED;
+	}
+
+	return lpcfg__client_use_kerberos(lp_ctx);
+}
+
+bool lpcfg_server_signing_allowed(struct loadparm_context *lp_ctx, bool *mandatory)
+{
+	bool allowed = true;
+	enum smb_signing_setting signing_setting = lpcfg_server_signing(lp_ctx);
+
+	*mandatory = false;
+
+	if (signing_setting == SMB_SIGNING_DEFAULT) {
+		/*
+		 * If we are a domain controller, SMB signing is
+		 * really important, as it can prevent a number of
+		 * attacks on communications between us and the
+		 * clients
+		 *
+		 * However, it really sucks (no sendfile, CPU
+		 * overhead) performance-wise when used on a
+		 * file server, so disable it by default
+		 * on non-DCs
+		 */
+
+		if (lpcfg_server_role(lp_ctx) >= ROLE_ACTIVE_DIRECTORY_DC) {
+			signing_setting = SMB_SIGNING_REQUIRED;
+		} else {
+			signing_setting = SMB_SIGNING_OFF;
+		}
+	}
+
+	switch (signing_setting) {
+	case SMB_SIGNING_REQUIRED:
+		*mandatory = true;
+		break;
+	case SMB_SIGNING_DESIRED:
+	case SMB_SIGNING_IF_REQUIRED:
+		break;
+	case SMB_SIGNING_OFF:
+		allowed = false;
+		break;
+	case SMB_SIGNING_DEFAULT:
+	case SMB_SIGNING_IPC_DEFAULT:
+		smb_panic(__location__);
+		break;
+	}
+
+	return allowed;
+}
+
+int lpcfg_tdb_hash_size(struct loadparm_context *lp_ctx, const char *name)
+{
+	const char *base;
+
+	if (name == NULL) {
+		return 0;
+	}
+
+	base = strrchr_m(name, '/');
+	if (base != NULL) {
+		base += 1;
+	} else {
+		base = name;
+	}
+	return lpcfg_parm_int(lp_ctx, NULL, "tdb_hashsize", base, 0);
+
+}
+
+int lpcfg_tdb_flags(struct loadparm_context *lp_ctx, int tdb_flags)
+{
+	if (!lpcfg_use_mmap(lp_ctx)) {
+		tdb_flags |= TDB_NOMMAP;
+	}
+	return tdb_flags;
+}
+
+/*
+ * Do not allow LanMan auth if unless NTLMv1 is also allowed
+ *
+ * This also ensures it is disabled if NTLM is totally disabled
+ */
+bool lpcfg_lanman_auth(struct loadparm_context *lp_ctx)
+{
+	enum ntlm_auth_level ntlm_auth_level = lpcfg_ntlm_auth(lp_ctx);
+
+	if (ntlm_auth_level == NTLM_AUTH_ON) {
+		return lpcfg__lanman_auth(lp_ctx);
+	} else {
+		return false;
+	}
+}
+
+static char *lpcfg_noop_substitution_fn(
+			TALLOC_CTX *mem_ctx,
+			const struct loadparm_substitution *lp_sub,
+			const char *raw_value,
+			void *private_data)
+{
+	return talloc_strdup(mem_ctx, raw_value);
+}
+
+static const struct loadparm_substitution global_noop_substitution = {
+	.substituted_string_fn = lpcfg_noop_substitution_fn,
+};
+
+const struct loadparm_substitution *lpcfg_noop_substitution(void)
+{
+	return &global_noop_substitution;
+}
+
+char *lpcfg_substituted_string(TALLOC_CTX *mem_ctx,
+			       const struct loadparm_substitution *lp_sub,
+			       const char *raw_value)
+{
+	return lp_sub->substituted_string_fn(mem_ctx,
+					     lp_sub,
+					     raw_value,
+					     lp_sub->private_data);
+}
+
+/**
+ * @brief Parse a string value of a given parameter to its integer enum value.
+ *
+ * @param[in]  param_name    The parameter name (e.g. 'client smb encrypt')
+ *
+ * @param[in]  param_value   The parameter value (e.g. 'required').
+ *
+ * @return The integer value of the enum the param_value matches or INT32_MIN
+ * on error.
+ */
+int32_t lpcfg_parse_enum_vals(const char *param_name,
+			      const char *param_value)
+{
+	struct parm_struct *parm = NULL;
+	int32_t ret = INT32_MIN;
+	bool ok;
+
+	parm = lpcfg_parm_struct(NULL, param_name);
+	if (parm == NULL) {
+		return INT32_MIN;
+	}
+
+	ok = lp_set_enum_parm(parm, param_value, &ret);
+	if (!ok) {
+		return INT32_MIN;
+	}
+
+	return ret;
+}
diff --git a/selftest/target/Samba4.pm b/selftest/target/Samba4.pm
index 5cbc5cc..7033146 100755
--- a/selftest/target/Samba4.pm
+++ b/selftest/target/Samba4.pm
@@ -782,7 +782,7 @@ sub provision_raw_step1($$)
 	wins support = yes
 	server role = $ctx->{server_role}
 	server services = +echo $services
-        dcerpc endpoint servers = +winreg +srvsvc
+        dcerpc endpoint servers = +winreg +srvsvc +rpcecho
 	notify:inotify = false
 	ldb:nosync = true
 	ldap server require strong auth = yes
diff --git a/selftest/target/Samba4.pm.orig b/selftest/target/Samba4.pm.orig
new file mode 100755
index 0000000..5cbc5cc
--- /dev/null
+++ b/selftest/target/Samba4.pm.orig
@@ -0,0 +1,3662 @@
+#!/usr/bin/perl
+# Bootstrap Samba and run a number of tests against it.
+# Copyright (C) 2005-2007 Jelmer Vernooij <jelmer@samba.org>
+# Published under the GNU GPL, v3 or later.
+
+# NOTE: Refer to the README for more details about the various testenvs,
+# and tips about adding new testenvs.
+
+package Samba4;
+
+use strict;
+use warnings;
+use Cwd qw(abs_path);
+use FindBin qw($RealBin);
+use POSIX;
+use SocketWrapper;
+use target::Samba;
+use target::Samba3;
+use Archive::Tar;
+
+sub new($$$$$) {
+	my ($classname, $SambaCtx, $bindir, $srcdir, $server_maxtime) = @_;
+
+	my $self = {
+		vars => {},
+		SambaCtx => $SambaCtx,
+		bindir => $bindir,
+		srcdir => $srcdir,
+		server_maxtime => $server_maxtime,
+		target3 => new Samba3($SambaCtx, $bindir, $srcdir, $server_maxtime)
+	};
+	bless $self;
+	return $self;
+}
+
+sub scriptdir_path($$) {
+	my ($self, $path) = @_;
+	return "$self->{srcdir}/source4/scripting/$path";
+}
+
+sub check_or_start($$$)
+{
+        my ($self, $env_vars, $process_model) = @_;
+	my $STDIN_READER;
+
+	my $env_ok = $self->check_env($env_vars);
+	if ($env_ok) {
+		return $env_vars->{SAMBA_PID};
+	} elsif (defined($env_vars->{SAMBA_PID})) {
+		warn("SAMBA PID $env_vars->{SAMBA_PID} is not running (died)");
+		return undef;
+	}
+
+	# use a pipe for stdin in the child processes. This allows
+	# those processes to monitor the pipe for EOF to ensure they
+	# exit when the test script exits
+	pipe($STDIN_READER, $env_vars->{STDIN_PIPE});
+
+	# build up the command to run samba
+	my @preargs = ();
+	my @optargs = ();
+	if (defined($ENV{SAMBA_OPTIONS})) {
+		@optargs = split(/ /, $ENV{SAMBA_OPTIONS});
+	}
+	if(defined($ENV{SAMBA_VALGRIND})) {
+		@preargs = split(/ /,$ENV{SAMBA_VALGRIND});
+	}
+
+	if (defined($process_model)) {
+		push @optargs, ("-M", $process_model);
+	}
+	my $binary = Samba::bindir_path($self, "samba");
+	my @full_cmd = (@preargs, $binary, "-i",
+			"--no-process-group", "--maximum-runtime=$self->{server_maxtime}",
+			$env_vars->{CONFIGURATION}, @optargs);
+
+	# the samba process takes some additional env variables (compared to s3)
+	my $samba_envs = Samba::get_env_for_process("samba", $env_vars);
+	if (defined($ENV{MITKRB5})) {
+		$samba_envs->{KRB5_KDC_PROFILE} = $env_vars->{MITKDC_CONFIG};
+	}
+
+	# fork a child process and exec() samba
+	my $daemon_ctx = {
+		NAME => "samba",
+		BINARY_PATH => $binary,
+		FULL_CMD => [ @full_cmd ],
+		LOG_FILE => $env_vars->{SAMBA_TEST_LOG},
+		TEE_STDOUT => 1,
+		PCAP_FILE => "env-$ENV{ENVNAME}-samba",
+		ENV_VARS => $samba_envs,
+	};
+	my $pid = Samba::fork_and_exec($self, $env_vars, $daemon_ctx, $STDIN_READER);
+
+	$env_vars->{SAMBA_PID} = $pid;
+
+	# close the parent's read-end of the pipe
+	close($STDIN_READER);
+
+	if ($self->wait_for_start($env_vars) != 0) {
+	    warn("Samba $pid failed to start up");
+	    return undef;
+	}
+
+	return $pid;
+}
+
+sub wait_for_start($$)
+{
+	my ($self, $testenv_vars) = @_;
+	my $count = 0;
+	my $ret = 0;
+
+	if (not $self->check_env($testenv_vars)) {
+	    warn("unable to confirm Samba $testenv_vars->{SAMBA_PID} is running");
+	    return -1;
+	}
+
+	# This will return quickly when things are up, but be slow if we
+	# need to wait for (eg) SSL init
+	my $nmblookup =  Samba::bindir_path($self, "nmblookup4");
+
+	do {
+		$ret = system("$nmblookup $testenv_vars->{CONFIGURATION} $testenv_vars->{SERVER}");
+		if ($ret != 0) {
+			sleep(1);
+		} else {
+			system("$nmblookup $testenv_vars->{CONFIGURATION} -U $testenv_vars->{SERVER_IP} $testenv_vars->{SERVER}");
+			system("$nmblookup $testenv_vars->{CONFIGURATION} $testenv_vars->{NETBIOSNAME}");
+			system("$nmblookup $testenv_vars->{CONFIGURATION} -U $testenv_vars->{SERVER_IP} $testenv_vars->{NETBIOSNAME}");
+			system("$nmblookup $testenv_vars->{CONFIGURATION} $testenv_vars->{NETBIOSNAME}");
+			system("$nmblookup $testenv_vars->{CONFIGURATION} -U $testenv_vars->{SERVER_IP} $testenv_vars->{NETBIOSNAME}");
+			system("$nmblookup $testenv_vars->{CONFIGURATION} $testenv_vars->{SERVER}");
+			system("$nmblookup $testenv_vars->{CONFIGURATION} -U $testenv_vars->{SERVER_IP} $testenv_vars->{SERVER}");
+			system("$nmblookup $testenv_vars->{CONFIGURATION} $testenv_vars->{NETBIOSNAME}");
+			system("$nmblookup $testenv_vars->{CONFIGURATION} -U $testenv_vars->{SERVER_IP} $testenv_vars->{NETBIOSNAME}");
+			system("$nmblookup $testenv_vars->{CONFIGURATION} $testenv_vars->{NETBIOSNAME}");
+			system("$nmblookup $testenv_vars->{CONFIGURATION} -U $testenv_vars->{SERVER_IP} $testenv_vars->{NETBIOSNAME}");
+		}
+		$count++;
+	} while ($ret != 0 && $count < 20);
+	if ($count == 20) {
+		teardown_env($self, $testenv_vars);
+		warn("nbt not reachable after 20 retries\n");
+		return -1;
+	}
+
+	# Ensure we have the first RID Set before we start tests.  This makes the tests more reliable.
+	if ($testenv_vars->{SERVER_ROLE} eq "domain controller") {
+		print "waiting for working LDAP and a RID Set to be allocated\n";
+		my $ldbsearch = Samba::bindir_path($self, "ldbsearch");
+		my $count = 0;
+		my $base_dn = "DC=".join(",DC=", split(/\./, $testenv_vars->{REALM}));
+
+		my $search_dn = $base_dn;
+		if ($testenv_vars->{NETBIOSNAME} ne "RODC") {
+			# TODO currently no check for actual rIDAllocationPool
+			$search_dn = "cn=RID Set,cn=$testenv_vars->{NETBIOSNAME},ou=domain controllers,$base_dn";
+		}
+		my $max_wait = 60;
+
+		# Add hosts file for name lookups
+		my $cmd = $self->get_cmd_env_vars($testenv_vars);
+
+		$cmd .= "$ldbsearch ";
+		$cmd .= "$testenv_vars->{CONFIGURATION} ";
+		$cmd .= "-H ldap://$testenv_vars->{SERVER} ";
+		$cmd .= "-U$testenv_vars->{USERNAME}%$testenv_vars->{PASSWORD} ";
+		$cmd .= "--scope base ";
+		$cmd .= "-b '$search_dn' ";
+		while (system("$cmd >/dev/null") != 0) {
+			$count++;
+			if ($count > $max_wait) {
+				teardown_env($self, $testenv_vars);
+				warn("Timed out ($max_wait sec) waiting for working LDAP and a RID Set to be allocated by $testenv_vars->{NETBIOSNAME} PID $testenv_vars->{SAMBA_PID}");
+				return -1;
+			}
+			print "Waiting for working LDAP...\n";
+			sleep(1);
+		}
+	}
+
+	my $wbinfo =  Samba::bindir_path($self, "wbinfo");
+
+	$count = 0;
+	do {
+		my $cmd = "NSS_WRAPPER_PASSWD=$testenv_vars->{NSS_WRAPPER_PASSWD} ";
+		$cmd .= "NSS_WRAPPER_GROUP=$testenv_vars->{NSS_WRAPPER_GROUP} ";
+		$cmd .= "SELFTEST_WINBINDD_SOCKET_DIR=$testenv_vars->{SELFTEST_WINBINDD_SOCKET_DIR} ";
+		$cmd .= "$wbinfo -P";
+		$ret = system($cmd);
+
+		if ($ret != 0) {
+			sleep(1);
+		}
+		$count++;
+	} while ($ret != 0 && $count < 20);
+	if ($count == 20) {
+		teardown_env($self, $testenv_vars);
+		warn("winbind not reachable after 20 retries\n");
+		return -1;
+	}
+
+	# Ensure we registered all our names
+	if ($testenv_vars->{SERVER_ROLE} eq "domain controller") {
+		my $max_wait = 120;
+		my $dns_update_cache = "$testenv_vars->{PRIVATEDIR}/dns_update_cache";
+		print "Waiting for $dns_update_cache to be created.\n";
+		$count = 0;
+		while (not -e $dns_update_cache) {
+			$count++;
+			if ($count > $max_wait) {
+				teardown_env($self, $testenv_vars);
+				warn("Timed out ($max_wait sec) waiting for $dns_update_cache PID $testenv_vars->{SAMBA_PID}");
+				return -1;
+			}
+			print "Waiting for $dns_update_cache to be created...\n";
+			sleep(1);
+		}
+		print "Waiting for $dns_update_cache to be filled.\n";
+		$count = 0;
+		while ((-s "$dns_update_cache") == 0) {
+			$count++;
+			if ($count > $max_wait) {
+				teardown_env($self, $testenv_vars);
+				warn("Timed out ($max_wait sec) waiting for $dns_update_cache PID $testenv_vars->{SAMBA_PID}");
+				return -1;
+			}
+			print "Waiting for $dns_update_cache to be filled...\n";
+			sleep(1);
+		}
+	}
+
+	print $self->getlog_env($testenv_vars);
+
+	print "READY ($testenv_vars->{SAMBA_PID})\n";
+
+	return 0
+}
+
+sub write_ldb_file($$$)
+{
+	my ($self, $file, $ldif_in) = @_;
+
+	my $ldbadd =  Samba::bindir_path($self, "ldbadd");
+	open(my $ldif, "|$ldbadd -H $file > /dev/null")
+	    or die "Failed to run $ldbadd: $!";
+	print $ldif $ldif_in;
+	close($ldif);
+
+	unless ($? == 0) {
+	    warn("$ldbadd failed: $?");
+	    return undef;
+	}
+	return 1;
+}
+
+sub add_wins_config($$)
+{
+	my ($self, $privatedir) = @_;
+	my $client_ip = Samba::get_ipv4_addr("client");
+
+	return $self->write_ldb_file("$privatedir/wins_config.ldb", "
+dn: name=TORTURE_11,CN=PARTNERS
+objectClass: wreplPartner
+name: TORTURE_11
+address: $client_ip
+pullInterval: 0
+pushChangeCount: 0
+type: 0x3
+");
+}
+
+sub setup_dns_hub_internal($$$)
+{
+	my ($self, $hostname, $prefix) = @_;
+	my $STDIN_READER;
+
+	unless(-d $prefix or mkdir($prefix, 0777)) {
+		warn("Unable to create $prefix");
+		return undef;
+	}
+	my $prefix_abs = abs_path($prefix);
+
+	die ("prefix=''") if $prefix_abs eq "";
+	die ("prefix='/'") if $prefix_abs eq "/";
+
+	unless (system("rm -rf $prefix_abs/*") == 0) {
+		warn("Unable to clean up");
+	}
+
+	my $env = undef;
+	$env->{NETBIOSNAME} = $hostname;
+
+	$env->{SERVER_IP} = Samba::get_ipv4_addr($hostname);
+	$env->{SERVER_IPV6} = Samba::get_ipv6_addr($hostname);
+	$env->{SOCKET_WRAPPER_DEFAULT_IFACE} = Samba::get_interface($hostname);
+	$env->{DNS_HUB_LOG} = "$prefix_abs/dns_hub.log";
+	$env->{RESOLV_CONF} = "$prefix_abs/resolv.conf";
+	$env->{TESTENV_DIR} = $prefix_abs;
+
+	my $ctx = undef;
+	$ctx->{resolv_conf} = $env->{RESOLV_CONF};
+	$ctx->{dns_ipv4} = $env->{SERVER_IP};
+	$ctx->{dns_ipv6} = $env->{SERVER_IPV6};
+	Samba::mk_resolv_conf($ctx);
+
+	my @preargs = ();
+	my @args = ();
+	if (!defined($ENV{PYTHON})) {
+	    push (@preargs, "env");
+	    push (@preargs, "python");
+	} else {
+	    push (@preargs, $ENV{PYTHON});
+	}
+	my $binary = "$self->{srcdir}/selftest/target/dns_hub.py";
+	push (@args, "$self->{server_maxtime}");
+	push (@args, "$env->{SERVER_IP},$env->{SERVER_IPV6}");
+	push (@args, Samba::realm_to_ip_mappings());
+	my @full_cmd = (@preargs, $binary, @args);
+
+	my $daemon_ctx = {
+		NAME => "dnshub",
+		BINARY_PATH => $binary,
+		FULL_CMD => [ @full_cmd ],
+		LOG_FILE => $env->{DNS_HUB_LOG},
+		TEE_STDOUT => 1,
+		PCAP_FILE => "env-$ENV{ENVNAME}-dns_hub",
+		ENV_VARS => {},
+	};
+
+	# use a pipe for stdin in the child processes. This allows
+	# those processes to monitor the pipe for EOF to ensure they
+	# exit when the test script exits
+	pipe($STDIN_READER, $env->{STDIN_PIPE});
+
+	my $pid = Samba::fork_and_exec($self, $env, $daemon_ctx, $STDIN_READER);
+
+	$env->{SAMBA_PID} = $pid;
+	$env->{KRB5_CONFIG} = "$prefix_abs/no_krb5.conf";
+
+	# close the parent's read-end of the pipe
+	close($STDIN_READER);
+
+	return $env;
+}
+
+sub setup_dns_hub
+{
+	my ($self, $prefix) = @_;
+
+	my $hostname = "rootdnsforwarder";
+
+	unless(-d $prefix or mkdir($prefix, 0777)) {
+		warn("Unable to create $prefix");
+		return undef;
+	}
+	my $env = $self->setup_dns_hub_internal("$hostname", "$prefix/$hostname");
+
+	$self->{dns_hub_env} = $env;
+
+	return $env;
+}
+
+sub get_dns_hub_env($)
+{
+	my ($self, $prefix) = @_;
+
+	if (defined($self->{dns_hub_env})) {
+	        return $self->{dns_hub_env};
+	}
+
+	die("get_dns_hub_env() not setup 'dns_hub_env'");
+	return undef;
+}
+
+sub return_env_value
+{
+	my ($env, $overwrite, $key) = @_;
+
+	if (defined($overwrite) and defined($overwrite->{$key})) {
+		return $overwrite->{$key};
+	}
+
+	if (defined($env->{$key})) {
+		return $env->{$key};
+	}
+
+	return undef;
+}
+
+# Returns the environmental variables that we pass to samba-tool commands
+sub get_cmd_env_vars
+{
+	my ($self, $givenenv, $overwrite) = @_;
+
+	my @keys = (
+		"NSS_WRAPPER_HOSTS",
+		"SOCKET_WRAPPER_DEFAULT_IFACE",
+		"RESOLV_CONF",
+		"RESOLV_WRAPPER_CONF",
+		"RESOLV_WRAPPER_HOSTS",
+		"GNUTLS_FORCE_FIPS_MODE",
+		"OPENSSL_FORCE_FIPS_MODE",
+		"KRB5_CONFIG",
+		"KRB5_CCACHE",
+		"GNUPGHOME",
+	);
+
+	my $localenv = undef;
+	foreach my $key (@keys) {
+		my $v = return_env_value($givenenv, $overwrite, $key);
+		$localenv->{$key} = $v if defined($v);
+	}
+
+	my $cmd_env = "NSS_WRAPPER_HOSTS='$localenv->{NSS_WRAPPER_HOSTS}' ";
+	$cmd_env .= "SOCKET_WRAPPER_DEFAULT_IFACE=\"$localenv->{SOCKET_WRAPPER_DEFAULT_IFACE}\" ";
+	if (defined($localenv->{RESOLV_WRAPPER_CONF})) {
+		$cmd_env .= "RESOLV_WRAPPER_CONF=\"$localenv->{RESOLV_WRAPPER_CONF}\" ";
+	} else {
+		$cmd_env .= "RESOLV_WRAPPER_HOSTS=\"$localenv->{RESOLV_WRAPPER_HOSTS}\" ";
+	}
+	if (defined($localenv->{GNUTLS_FORCE_FIPS_MODE})) {
+		$cmd_env .= "GNUTLS_FORCE_FIPS_MODE=$localenv->{GNUTLS_FORCE_FIPS_MODE} ";
+	}
+	if (defined($localenv->{OPENSSL_FORCE_FIPS_MODE})) {
+		$cmd_env .= "OPENSSL_FORCE_FIPS_MODE=$localenv->{OPENSSL_FORCE_FIPS_MODE} ";
+	}
+	$cmd_env .= "KRB5_CONFIG=\"$localenv->{KRB5_CONFIG}\" ";
+	$cmd_env .= "KRB5CCNAME=\"$localenv->{KRB5_CCACHE}\" ";
+	$cmd_env .= "RESOLV_CONF=\"$localenv->{RESOLV_CONF}\" ";
+	$cmd_env .= "GNUPGHOME=\"$localenv->{GNUPGHOME}\" ";
+
+	return $cmd_env;
+}
+
+# Sets up a forest trust namespace.
+# (Note this is different to kernel namespaces, setup by the
+# USE_NAMESPACES=1 option)
+sub setup_namespaces
+{
+	my ($self, $localenv, $upn_array, $spn_array) = @_;
+
+	@{$upn_array} = [] unless defined($upn_array);
+	my $upn_args = "";
+	foreach my $upn (@{$upn_array}) {
+		$upn_args .= " --add-upn-suffix=$upn";
+	}
+
+	@{$spn_array} = [] unless defined($spn_array);
+	my $spn_args = "";
+	foreach my $spn (@{$spn_array}) {
+		$spn_args .= " --add-spn-suffix=$spn";
+	}
+
+	my $samba_tool =  Samba::bindir_path($self, "samba-tool");
+
+	my $cmd_env = $self->get_cmd_env_vars($localenv);
+
+	my $cmd_config = " $localenv->{CONFIGURATION}";
+
+	my $namespaces = $cmd_env;
+	$namespaces .= " $samba_tool domain trust namespaces $upn_args $spn_args";
+	$namespaces .= $cmd_config;
+	unless (system($namespaces) == 0) {
+		warn("Failed to add namespaces \n$namespaces");
+		return -1;
+	}
+
+	return 0;
+}
+
+sub setup_trust($$$$$)
+{
+	my ($self, $localenv, $remoteenv, $type, $extra_args) = @_;
+
+	$localenv->{TRUST_SERVER} = $remoteenv->{SERVER};
+	$localenv->{TRUST_SERVER_IP} = $remoteenv->{SERVER_IP};
+	$localenv->{TRUST_DNSNAME} = $remoteenv->{DNSNAME};
+
+	$localenv->{TRUST_USERNAME} = $remoteenv->{USERNAME};
+	$localenv->{TRUST_PASSWORD} = $remoteenv->{PASSWORD};
+	$localenv->{TRUST_DOMAIN} = $remoteenv->{DOMAIN};
+	$localenv->{TRUST_REALM} = $remoteenv->{REALM};
+	$localenv->{TRUST_DOMSID} = $remoteenv->{DOMSID};
+
+	# Add trusted domain realms to krb5.conf
+	Samba::append_krb5_conf_trust_realms($localenv);
+
+	my $samba_tool =  Samba::bindir_path($self, "samba-tool");
+
+	# setup the trust
+	my $cmd_env = $self->get_cmd_env_vars($localenv);
+
+	my $cmd_config = " $localenv->{CONFIGURATION}";
+	my $cmd_creds = $cmd_config;
+	$cmd_creds .= " -U$localenv->{TRUST_DOMAIN}\\\\$localenv->{TRUST_USERNAME}\%$localenv->{TRUST_PASSWORD}";
+
+	my $create = $cmd_env;
+	$create .= " $samba_tool domain trust create --type=${type} $localenv->{TRUST_REALM}";
+	$create .= " $extra_args";
+	$create .= $cmd_creds;
+	unless (system($create) == 0) {
+		warn("Failed to create trust \n$create");
+		return undef;
+	}
+
+	my $groupname = "g_$localenv->{TRUST_DOMAIN}";
+	my $groupadd = $cmd_env;
+	$groupadd .= " $samba_tool group add '$groupname' --group-scope=Domain $cmd_config";
+	unless (system($groupadd) == 0) {
+		warn("Failed to create group \n$groupadd");
+		return undef;
+	}
+	my $groupmem = $cmd_env;
+	$groupmem .= " $samba_tool group addmembers '$groupname' '$localenv->{TRUST_DOMSID}-513' $cmd_config";
+	unless (system($groupmem) == 0) {
+		warn("Failed to add group member \n$groupmem");
+		return undef;
+	}
+
+	return $localenv
+}
+
+sub provision_raw_prepare($$$$$$$$$$$$$$)
+{
+	my ($self,
+	    $prefix,
+	    $server_role,
+	    $hostname,
+	    $domain,
+	    $realm,
+	    $samsid,
+	    $functional_level,
+	    $password,
+	    $kdc_ipv4,
+	    $kdc_ipv6,
+	    $force_fips_mode,
+	    $extra_provision_options) = @_;
+	my $ctx;
+	my $python_cmd = "";
+	if (defined $ENV{PYTHON}) {
+		$python_cmd = $ENV{PYTHON} . " ";
+	}
+	$ctx->{python} = $python_cmd;
+	my $netbiosname = uc($hostname);
+
+	unless(-d $prefix or mkdir($prefix, 0777)) {
+		warn("Unable to create $prefix");
+		return undef;
+	}
+	my $prefix_abs = abs_path($prefix);
+
+	die ("prefix=''") if $prefix_abs eq "";
+	die ("prefix='/'") if $prefix_abs eq "/";
+
+	unless (system("rm -rf $prefix_abs/*") == 0) {
+		warn("Unable to clean up");
+	}
+
+	
+	my $swiface = Samba::get_interface($hostname);
+
+	$ctx->{prefix} = $prefix;
+	$ctx->{prefix_abs} = $prefix_abs;
+
+	$ctx->{server_role} = $server_role;
+	$ctx->{hostname} = $hostname;
+	$ctx->{netbiosname} = $netbiosname;
+	$ctx->{swiface} = $swiface;
+	$ctx->{password} = $password;
+	$ctx->{kdc_ipv4} = $kdc_ipv4;
+	$ctx->{kdc_ipv6} = $kdc_ipv6;
+	$ctx->{force_fips_mode} = $force_fips_mode;
+	$ctx->{krb5_ccname} = "$prefix_abs/krb5cc_%{uid}";
+	if ($functional_level eq "2000") {
+		$ctx->{supported_enctypes} = "arcfour-hmac-md5 des-cbc-md5 des-cbc-crc";
+	}
+
+#
+# Set smbd log level here.
+#
+	$ctx->{server_loglevel} =$ENV{SERVER_LOG_LEVEL} || 1;
+	$ctx->{username} = "Administrator";
+	$ctx->{domain} = $domain;
+	$ctx->{realm} = uc($realm);
+	$ctx->{dnsname} = lc($realm);
+	$ctx->{samsid} = $samsid;
+
+	$ctx->{functional_level} = $functional_level;
+
+	my $unix_name = ($ENV{USER} or $ENV{LOGNAME} or `whoami`);
+	chomp $unix_name;
+	$ctx->{unix_name} = $unix_name;
+	$ctx->{unix_uid} = $>;
+	my @mygid = split(" ", $();
+	$ctx->{unix_gid} = $mygid[0];
+	$ctx->{unix_gids_str} = $);
+	@{$ctx->{unix_gids}} = split(" ", $ctx->{unix_gids_str});
+
+	$ctx->{etcdir} = "$prefix_abs/etc";
+	$ctx->{piddir} = "$prefix_abs/pid";
+	$ctx->{smb_conf} = "$ctx->{etcdir}/smb.conf";
+	$ctx->{krb5_conf} = "$ctx->{etcdir}/krb5.conf";
+	$ctx->{krb5_ccache} = "$prefix_abs/krb5_ccache";
+	$ctx->{mitkdc_conf} = "$ctx->{etcdir}/mitkdc.conf";
+	$ctx->{gnupghome} = "$prefix_abs/gnupg";
+	$ctx->{privatedir} = "$prefix_abs/private";
+	$ctx->{binddnsdir} = "$prefix_abs/bind-dns";
+	$ctx->{ncalrpcdir} = "$prefix_abs/ncalrpc";
+	$ctx->{lockdir} = "$prefix_abs/lockdir";
+	$ctx->{logdir} = "$prefix_abs/logs";
+	$ctx->{statedir} = "$prefix_abs/statedir";
+	$ctx->{cachedir} = "$prefix_abs/cachedir";
+	$ctx->{winbindd_socket_dir} = "$prefix_abs/wbsock";
+	$ctx->{ntp_signd_socket_dir} = "$prefix_abs/ntp_signd_socket";
+	$ctx->{nsswrap_passwd} = "$ctx->{etcdir}/passwd";
+	$ctx->{nsswrap_group} = "$ctx->{etcdir}/group";
+	$ctx->{nsswrap_hosts} = "$ENV{SELFTEST_PREFIX}/hosts";
+	$ctx->{nsswrap_hostname} = "$ctx->{hostname}.$ctx->{dnsname}";
+	if ($ENV{SAMBA_DNS_FAKING}) {
+		$ctx->{dns_host_file} = "$ENV{SELFTEST_PREFIX}/dns_host_file";
+		$ctx->{samba_dnsupdate} = "$ENV{SRCDIR_ABS}/source4/scripting/bin/samba_dnsupdate --configfile=$ctx->{smb_conf} --all-interfaces --use-file=$ctx->{dns_host_file}";
+		$ctx->{samba_dnsupdate} = $python_cmd .  $ctx->{samba_dnsupdate};
+	} else {
+	        $ctx->{samba_dnsupdate} = "$ENV{SRCDIR_ABS}/source4/scripting/bin/samba_dnsupdate --configfile=$ctx->{smb_conf} --all-interfaces";
+		$ctx->{samba_dnsupdate} = $python_cmd .  $ctx->{samba_dnsupdate};
+		$ctx->{use_resolv_wrapper} = 1;
+	}
+
+	my $dns_hub = $self->get_dns_hub_env();
+	$ctx->{resolv_conf} = $dns_hub->{RESOLV_CONF};
+
+	$ctx->{tlsdir} = "$ctx->{privatedir}/tls";
+
+	$ctx->{ipv4} = Samba::get_ipv4_addr($hostname);
+	$ctx->{ipv6} = Samba::get_ipv6_addr($hostname);
+
+	push(@{$ctx->{directories}}, $ctx->{privatedir});
+	push(@{$ctx->{directories}}, $ctx->{binddnsdir});
+	push(@{$ctx->{directories}}, $ctx->{etcdir});
+	push(@{$ctx->{directories}}, $ctx->{piddir});
+	push(@{$ctx->{directories}}, $ctx->{lockdir});
+	push(@{$ctx->{directories}}, $ctx->{logdir});
+	push(@{$ctx->{directories}}, $ctx->{statedir});
+	push(@{$ctx->{directories}}, $ctx->{cachedir});
+
+	$ctx->{smb_conf_extra_options} = "";
+
+	my @provision_options = ();
+	push (@provision_options, "GNUPGHOME=\"$ctx->{gnupghome}\"");
+	push (@provision_options, "KRB5_CONFIG=\"$ctx->{krb5_conf}\"");
+	push (@provision_options, "KRB5CCNAME=\"$ctx->{krb5_ccache}\"");
+	push (@provision_options, "NSS_WRAPPER_PASSWD=\"$ctx->{nsswrap_passwd}\"");
+	push (@provision_options, "NSS_WRAPPER_GROUP=\"$ctx->{nsswrap_group}\"");
+	push (@provision_options, "NSS_WRAPPER_HOSTS=\"$ctx->{nsswrap_hosts}\"");
+	push (@provision_options, "NSS_WRAPPER_HOSTNAME=\"$ctx->{nsswrap_hostname}\"");
+	if (defined($ctx->{use_resolv_wrapper})) {
+		push (@provision_options, "RESOLV_WRAPPER_CONF=\"$ctx->{resolv_conf}\"");
+		push (@provision_options, "RESOLV_CONF=\"$ctx->{resolv_conf}\"");
+	} else {
+		push (@provision_options, "RESOLV_WRAPPER_HOSTS=\"$ctx->{dns_host_file}\"");
+	}
+	if (defined($ctx->{force_fips_mode})) {
+		push (@provision_options, "GNUTLS_FORCE_FIPS_MODE=1");
+		push (@provision_options, "OPENSSL_FORCE_FIPS_MODE=1");
+	}
+
+	if (defined($ENV{GDB_PROVISION})) {
+		push (@provision_options, "gdb --args");
+		if (!defined($ENV{PYTHON})) {
+		    push (@provision_options, "env");
+		    push (@provision_options, "python");
+		}
+	}
+	if (defined($ENV{VALGRIND_PROVISION})) {
+		push (@provision_options, "valgrind");
+		if (!defined($ENV{PYTHON})) {
+		    push (@provision_options, "env");
+		    push (@provision_options, "python");
+		}
+	}
+
+	my $samba_tool =  Samba::bindir_path($self, "samba-tool");
+
+	push (@provision_options, $samba_tool);
+	push (@provision_options, "domain");
+	push (@provision_options, "provision");
+	push (@provision_options, "--configfile=$ctx->{smb_conf}");
+	push (@provision_options, "--host-name=$ctx->{hostname}");
+	push (@provision_options, "--host-ip=$ctx->{ipv4}");
+	push (@provision_options, "--quiet");
+	push (@provision_options, "--domain=$ctx->{domain}");
+	push (@provision_options, "--realm=$ctx->{realm}");
+	if (defined($ctx->{samsid})) {
+		push (@provision_options, "--domain-sid=$ctx->{samsid}");
+	}
+	push (@provision_options, "--adminpass=$ctx->{password}");
+	push (@provision_options, "--krbtgtpass=krbtgt$ctx->{password}");
+	push (@provision_options, "--machinepass=machine$ctx->{password}");
+	push (@provision_options, "--root=$ctx->{unix_name}");
+	push (@provision_options, "--server-role=\"$ctx->{server_role}\"");
+	push (@provision_options, "--function-level=\"$ctx->{functional_level}\"");
+
+	@{$ctx->{provision_options}} = @provision_options;
+
+	if (defined($extra_provision_options)) {
+		push (@{$ctx->{provision_options}}, @{$extra_provision_options});
+	}
+
+	return $ctx;
+}
+
+sub has_option
+{
+	my ($self, $keyword, @options_list) = @_;
+
+	# convert the options-list to a hash-map for easy keyword lookup
+	my %options_dict = map { $_ => 1 } @options_list;
+
+	return exists $options_dict{$keyword};
+}
+
+#
+# Step1 creates the basic configuration
+#
+sub provision_raw_step1($$)
+{
+	my ($self, $ctx) = @_;
+
+	mkdir($_, 0777) foreach (@{$ctx->{directories}});
+
+	##
+	## lockdir and piddir must be 0755
+	##
+	chmod 0755, $ctx->{lockdir};
+	chmod 0755, $ctx->{piddir};
+
+	unless (open(CONFFILE, ">$ctx->{smb_conf}")) {
+		warn("can't open $ctx->{smb_conf}$?");
+		return undef;
+	}
+
+	Samba::copy_gnupg_home($ctx);
+	Samba::prepare_keyblobs($ctx);
+	my $crlfile = "$ctx->{tlsdir}/crl.pem";
+	$crlfile = "" unless -e ${crlfile};
+
+	# work out which file server to use. Default to source3 smbd (s3fs),
+	# unless the source4 NTVFS (smb) file server has been specified
+	my $services = "-smb +s3fs";
+	if ($self->has_option("--use-ntvfs", @{$ctx->{provision_options}})) {
+		$services = "+smb -s3fs";
+	}
+
+	my $interfaces = Samba::get_interfaces_config($ctx->{netbiosname});
+
+	print CONFFILE "
+[global]
+	netbios name = $ctx->{netbiosname}
+	posix:eadb = $ctx->{statedir}/eadb.tdb
+	workgroup = $ctx->{domain}
+	realm = $ctx->{realm}
+	private dir = $ctx->{privatedir}
+	binddns dir = $ctx->{binddnsdir}
+	pid directory = $ctx->{piddir}
+	ncalrpc dir = $ctx->{ncalrpcdir}
+	lock dir = $ctx->{lockdir}
+	state directory = $ctx->{statedir}
+	cache directory = $ctx->{cachedir}
+	winbindd socket directory = $ctx->{winbindd_socket_dir}
+	ntp signd socket directory = $ctx->{ntp_signd_socket_dir}
+	winbind separator = /
+	interfaces = $interfaces
+	tls dh params file = $ctx->{tlsdir}/dhparms.pem
+	tls crlfile = ${crlfile}
+	tls verify peer = no_check
+	panic action = $RealBin/gdb_backtrace \%d
+	smbd:suicide mode = yes
+	smbd:FSCTL_SMBTORTURE = yes
+	smbd:validate_oplock_types = yes
+	wins support = yes
+	server role = $ctx->{server_role}
+	server services = +echo $services
+        dcerpc endpoint servers = +winreg +srvsvc
+	notify:inotify = false
+	ldb:nosync = true
+	ldap server require strong auth = yes
+	log file = $ctx->{logdir}/log.\%m
+	log level = $ctx->{server_loglevel}
+	lanman auth = Yes
+	ntlm auth = Yes
+	client min protocol = SMB2_02
+	server min protocol = SMB2_02
+	mangled names = yes
+	dns update command = $ctx->{samba_dnsupdate}
+	spn update command = $ctx->{python} $ENV{SRCDIR_ABS}/source4/scripting/bin/samba_spnupdate --configfile $ctx->{smb_conf}
+	gpo update command = $ctx->{python} $ENV{SRCDIR_ABS}/source4/scripting/bin/samba-gpupdate --configfile $ctx->{smb_conf} --target=Computer
+	samba kcc command = $ctx->{python} $ENV{SRCDIR_ABS}/source4/scripting/bin/samba_kcc
+	dreplsrv:periodic_startup_interval = 0
+	dsdb:schema update allowed = yes
+
+        vfs objects = dfs_samba4 acl_xattr fake_acls xattr_tdb streams_depot
+
+        idmap_ldb:use rfc2307=yes
+	winbind enum users = yes
+	winbind enum groups = yes
+
+        rpc server port:netlogon = 1026
+	include system krb5 conf = no
+
+";
+
+	print CONFFILE "
+
+	# Begin extra options
+	$ctx->{smb_conf_extra_options}
+	# End extra options
+";
+	close(CONFFILE);
+
+        #Default the KDC IP to the server's IP
+	if (not defined($ctx->{kdc_ipv4})) {
+		$ctx->{kdc_ipv4} = $ctx->{ipv4};
+	}
+	if (not defined($ctx->{kdc_ipv6})) {
+		$ctx->{kdc_ipv6} = $ctx->{ipv6};
+	}
+
+	Samba::mk_krb5_conf($ctx);
+	Samba::mk_mitkdc_conf($ctx, abs_path(Samba::bindir_path($self, "shared")));
+
+	open(PWD, ">$ctx->{nsswrap_passwd}");
+	if ($ctx->{unix_uid} != 0) {
+		print PWD "root:x:0:0:root gecos:$ctx->{prefix_abs}:/bin/false\n";
+	}
+	print PWD "$ctx->{unix_name}:x:$ctx->{unix_uid}:65531:$ctx->{unix_name} gecos:$ctx->{prefix_abs}:/bin/false\n";
+	print PWD "nobody:x:65534:65533:nobody gecos:$ctx->{prefix_abs}:/bin/false
+pdbtest:x:65533:65533:pdbtest gecos:$ctx->{prefix_abs}:/bin/false
+pdbtest2:x:65532:65533:pdbtest gecos:$ctx->{prefix_abs}:/bin/false
+pdbtest3:x:65531:65533:pdbtest gecos:$ctx->{prefix_abs}:/bin/false
+pdbtest4:x:65530:65533:pdbtest gecos:$ctx->{prefix_abs}:/bin/false
+";
+	close(PWD);
+        my $uid_rfc2307test = 65533;
+
+	open(GRP, ">$ctx->{nsswrap_group}");
+	if ($ctx->{unix_gid} != 0) {
+		print GRP "root:x:0:\n";
+	}
+	print GRP "$ctx->{unix_name}:x:$ctx->{unix_gid}:\n";
+	print GRP "wheel:x:10:
+users:x:65531:
+nobody:x:65533:
+nogroup:x:65534:nobody
+";
+	close(GRP);
+        my $gid_rfc2307test = 65532;
+
+	my $hostname = lc($ctx->{hostname});
+	open(HOSTS, ">>$ctx->{nsswrap_hosts}");
+	if ($hostname eq "localdc") {
+		print HOSTS "$ctx->{ipv4} ${hostname}.$ctx->{dnsname} $ctx->{dnsname} ${hostname}\n";
+		print HOSTS "$ctx->{ipv6} ${hostname}.$ctx->{dnsname} $ctx->{dnsname} ${hostname}\n";
+	} else {
+		print HOSTS "$ctx->{ipv4} ${hostname}.$ctx->{dnsname} ${hostname}\n";
+		print HOSTS "$ctx->{ipv6} ${hostname}.$ctx->{dnsname} ${hostname}\n";
+	}
+	close(HOSTS);
+
+	my $configuration = "--configfile=$ctx->{smb_conf}";
+
+#Ensure the config file is valid before we start
+	my $testparm = Samba::bindir_path($self, "samba-tool") . " testparm";
+	if (system("$testparm $configuration -v --suppress-prompt >/dev/null 2>&1") != 0) {
+		system("$testparm -v --suppress-prompt $configuration >&2");
+		warn("Failed to create a valid smb.conf configuration $testparm!");
+		return undef;
+	}
+	unless (system("($testparm $configuration -v --suppress-prompt --parameter-name=\"netbios name\" --section-name=global 2> /dev/null | grep -i \"^$ctx->{netbiosname}\" ) >/dev/null 2>&1") == 0) {
+		warn("Failed to create a valid smb.conf configuration! $testparm $configuration -v --suppress-prompt --parameter-name=\"netbios name\" --section-name=global");
+		return undef;
+	}
+
+	# Return the environment variables for the new testenv DC.
+	# Note that we have SERVER_X and DC_SERVER_X variables (which have the same
+	# value initially). In a 2 DC setup, $DC_SERVER_X will always be the PDC.
+	my $ret = {
+		GNUPGHOME => $ctx->{gnupghome},
+		KRB5_CONFIG => $ctx->{krb5_conf},
+		KRB5_CCACHE => $ctx->{krb5_ccache},
+		MITKDC_CONFIG => $ctx->{mitkdc_conf},
+		PIDDIR => $ctx->{piddir},
+		SERVER => $ctx->{hostname},
+		DC_SERVER => $ctx->{hostname},
+		SERVER_IP => $ctx->{ipv4},
+		DC_SERVER_IP => $ctx->{ipv4},
+		SERVER_IPV6 => $ctx->{ipv6},
+		DC_SERVER_IPV6 => $ctx->{ipv6},
+		NETBIOSNAME => $ctx->{netbiosname},
+		DC_NETBIOSNAME => $ctx->{netbiosname},
+		DOMAIN => $ctx->{domain},
+		USERNAME => $ctx->{username},
+		DC_USERNAME => $ctx->{username},
+		REALM => $ctx->{realm},
+		DNSNAME => $ctx->{dnsname},
+		SAMSID => $ctx->{samsid},
+		PASSWORD => $ctx->{password},
+		DC_PASSWORD => $ctx->{password},
+		LDAPDIR => $ctx->{ldapdir},
+		LDAP_INSTANCE => $ctx->{ldap_instance},
+		SELFTEST_WINBINDD_SOCKET_DIR => $ctx->{winbindd_socket_dir},
+		NCALRPCDIR => $ctx->{ncalrpcdir},
+		LOCKDIR => $ctx->{lockdir},
+		STATEDIR => $ctx->{statedir},
+		CACHEDIR => $ctx->{cachedir},
+		PRIVATEDIR => $ctx->{privatedir},
+		BINDDNSDIR => $ctx->{binddnsdir},
+		SERVERCONFFILE => $ctx->{smb_conf},
+		TESTENV_DIR => $ctx->{prefix_abs},
+		CONFIGURATION => $configuration,
+		SOCKET_WRAPPER_DEFAULT_IFACE => $ctx->{swiface},
+		NSS_WRAPPER_PASSWD => $ctx->{nsswrap_passwd},
+		NSS_WRAPPER_GROUP => $ctx->{nsswrap_group},
+		NSS_WRAPPER_HOSTS => $ctx->{nsswrap_hosts},
+		NSS_WRAPPER_HOSTNAME => $ctx->{nsswrap_hostname},
+		SAMBA_TEST_FIFO => "$ctx->{prefix}/samba_test.fifo",
+		SAMBA_TEST_LOG => "$ctx->{prefix}/samba_test.log",
+		SAMBA_TEST_LOG_POS => 0,
+		NSS_WRAPPER_MODULE_SO_PATH => Samba::nss_wrapper_winbind_so_path($self),
+		NSS_WRAPPER_MODULE_FN_PREFIX => "winbind",
+                LOCAL_PATH => $ctx->{share},
+                UID_RFC2307TEST => $uid_rfc2307test,
+                GID_RFC2307TEST => $gid_rfc2307test,
+                SERVER_ROLE => $ctx->{server_role},
+	        RESOLV_CONF => $ctx->{resolv_conf},
+	};
+
+	if (defined($ctx->{use_resolv_wrapper})) {
+	        $ret->{RESOLV_WRAPPER_CONF} = $ctx->{resolv_conf};
+	} else {
+		$ret->{RESOLV_WRAPPER_HOSTS} = $ctx->{dns_host_file};
+	}
+	if (defined($ctx->{force_fips_mode})) {
+		$ret->{GNUTLS_FORCE_FIPS_MODE} = "1",
+		$ret->{OPENSSL_FORCE_FIPS_MODE} = "1",
+	}
+
+	if ($ctx->{server_role} eq "domain controller") {
+		$ret->{DOMSID} = $ret->{SAMSID};
+	}
+
+	return $ret;
+}
+
+#
+# Step2 runs the provision script
+#
+sub provision_raw_step2($$$)
+{
+	my ($self, $ctx, $ret) = @_;
+
+	my $ldif;
+
+	my $provision_cmd = join(" ", @{$ctx->{provision_options}});
+	unless (system($provision_cmd) == 0) {
+		warn("Unable to provision: \n$provision_cmd\n");
+		return undef;
+	}
+
+	my $cmd_env = $self->get_cmd_env_vars($ret);
+
+	my $testallowed_account = "testallowed";
+	my $samba_tool_cmd = ${cmd_env};
+	$samba_tool_cmd .= Samba::bindir_path($self, "samba-tool")
+	    . " user create --configfile=$ctx->{smb_conf} $testallowed_account $ctx->{password}";
+	unless (system($samba_tool_cmd) == 0) {
+		warn("Unable to add testallowed user: \n$samba_tool_cmd\n");
+		return undef;
+	}
+
+	my $srv_account = "srv_account";
+	$samba_tool_cmd = ${cmd_env};
+	$samba_tool_cmd .= Samba::bindir_path($self, "samba-tool")
+	    . " user create --configfile=$ctx->{smb_conf} $srv_account $ctx->{password}";
+	unless (system($samba_tool_cmd) == 0) {
+		warn("Unable to add $srv_account user: \n$samba_tool_cmd\n");
+		return undef;
+	}
+
+	$samba_tool_cmd = ${cmd_env};
+	$samba_tool_cmd .= Samba::bindir_path($self, "samba-tool")
+	    . " spn add HOST/$srv_account --configfile=$ctx->{smb_conf} $srv_account";
+	unless (system($samba_tool_cmd) == 0) {
+		warn("Unable to add spn for $srv_account: \n$samba_tool_cmd\n");
+		return undef;
+	}
+
+	my $ldbmodify = ${cmd_env};
+	$ldbmodify .= Samba::bindir_path($self, "ldbmodify");
+	$ldbmodify .=  " --configfile=$ctx->{smb_conf}";
+	my $base_dn = "DC=".join(",DC=", split(/\./, $ctx->{realm}));
+
+	if ($ctx->{server_role} ne "domain controller") {
+		$base_dn = "DC=$ctx->{netbiosname}";
+	}
+
+	my $user_dn = "cn=$testallowed_account,cn=users,$base_dn";
+	$testallowed_account = "testallowed account";
+	open($ldif, "|$ldbmodify -H $ctx->{privatedir}/sam.ldb")
+	    or die "Failed to run $ldbmodify: $!";
+	print $ldif "dn: $user_dn
+changetype: modify
+replace: samAccountName
+samAccountName: $testallowed_account
+-
+";
+	close($ldif);
+	unless ($? == 0) {
+	    warn("$ldbmodify failed: $?");
+	    return undef;
+	}
+
+	open($ldif, "|$ldbmodify -H $ctx->{privatedir}/sam.ldb")
+            or die "Failed to run $ldbmodify: $!";
+	print $ldif "dn: $user_dn
+changetype: modify
+replace: userPrincipalName
+userPrincipalName: testallowed upn\@$ctx->{realm}
+replace: servicePrincipalName
+servicePrincipalName: host/testallowed
+-	    
+";
+	close($ldif);
+	unless ($? == 0) {
+	    warn("$ldbmodify failed: $?");
+	    return undef;
+	}
+
+	$samba_tool_cmd = ${cmd_env};
+	$samba_tool_cmd .= Samba::bindir_path($self, "samba-tool")
+	    . " user create --configfile=$ctx->{smb_conf} testdenied $ctx->{password}";
+	unless (system($samba_tool_cmd) == 0) {
+		warn("Unable to add testdenied user: \n$samba_tool_cmd\n");
+		return undef;
+	}
+
+	$user_dn = "cn=testdenied,cn=users,$base_dn";
+        open($ldif, "|$ldbmodify -H $ctx->{privatedir}/sam.ldb")
+            or die "Failed to run $ldbmodify: $!";
+        print $ldif "dn: $user_dn
+changetype: modify
+replace: userPrincipalName
+userPrincipalName: testdenied_upn\@$ctx->{realm}.upn
+-	    
+";
+	close($ldif);
+	unless ($? == 0) {
+	    warn("$ldbmodify failed: $?");
+	    return undef;
+	}
+
+	$samba_tool_cmd = ${cmd_env};
+	$samba_tool_cmd .= Samba::bindir_path($self, "samba-tool")
+	    . " user create --configfile=$ctx->{smb_conf} testupnspn $ctx->{password}";
+	unless (system($samba_tool_cmd) == 0) {
+		warn("Unable to add testupnspn user: \n$samba_tool_cmd\n");
+		return undef;
+	}
+
+	$user_dn = "cn=testupnspn,cn=users,$base_dn";
+        open($ldif, "|$ldbmodify -H $ctx->{privatedir}/sam.ldb")
+            or die "Failed to run $ldbmodify: $!";
+        print $ldif "dn: $user_dn
+changetype: modify
+replace: userPrincipalName
+userPrincipalName: http/testupnspn.$ctx->{dnsname}\@$ctx->{realm}
+replace: servicePrincipalName
+servicePrincipalName: http/testupnspn.$ctx->{dnsname}
+-
+";
+	close($ldif);
+	unless ($? == 0) {
+	    warn("$ldbmodify failed: $?");
+	    return undef;
+	}
+
+	$samba_tool_cmd = ${cmd_env};
+	$samba_tool_cmd .= Samba::bindir_path($self, "samba-tool")
+	    . " group addmembers --configfile=$ctx->{smb_conf} 'Allowed RODC Password Replication Group' '$testallowed_account'";
+	unless (system($samba_tool_cmd) == 0) {
+		warn("Unable to add '$testallowed_account' user to 'Allowed RODC Password Replication Group': \n$samba_tool_cmd\n");
+		return undef;
+	}
+
+	# Create to users alice and bob!
+	my $user_account_array = ["alice", "bob", "jane", "joe"];
+
+	foreach my $user_account (@{$user_account_array}) {
+		my $samba_tool_cmd = ${cmd_env};
+
+		$samba_tool_cmd .= Samba::bindir_path($self, "samba-tool")
+		    . " user create --configfile=$ctx->{smb_conf} $user_account Secret007";
+		unless (system($samba_tool_cmd) == 0) {
+			warn("Unable to create user: $user_account\n$samba_tool_cmd\n");
+			return undef;
+		}
+	}
+
+	my $group_array = ["Samba Users"];
+
+	foreach my $group (@{$group_array}) {
+		my $samba_tool_cmd = ${cmd_env};
+
+		$samba_tool_cmd .= Samba::bindir_path($self, "samba-tool")
+		    . " group add --configfile=$ctx->{smb_conf} \"$group\"";
+		unless (system($samba_tool_cmd) == 0) {
+			warn("Unable to create group: $group\n$samba_tool_cmd\n");
+			return undef;
+		}
+	}
+
+	# Add user joe to group "Samba Users"
+	my $group = "Samba Users";
+	my $user_account = "joe";
+
+	$samba_tool_cmd = ${cmd_env};
+	$samba_tool_cmd .= Samba::bindir_path($self, "samba-tool")
+	    . " group addmembers --configfile=$ctx->{smb_conf} \"$group\" $user_account";
+	unless (system($samba_tool_cmd) == 0) {
+		warn("Unable to add " . $user_account . "to group group : $group\n$samba_tool_cmd\n");
+		return undef;
+	}
+
+	$group = "Samba Users";
+	$user_account = "joe";
+
+	$samba_tool_cmd = ${cmd_env};
+	$samba_tool_cmd .= Samba::bindir_path($self, "samba-tool")
+	    . " user setprimarygroup --configfile=$ctx->{smb_conf} $user_account \"$group\"";
+	unless (system($samba_tool_cmd) == 0) {
+		warn("Unable to set primary group of user: $user_account\n$samba_tool_cmd\n");
+		return undef;
+	}
+
+	# Change the userPrincipalName for jane
+	$user_dn = "cn=jane,cn=users,$base_dn";
+
+	open($ldif, "|$ldbmodify -H $ctx->{privatedir}/sam.ldb")
+            or die "Failed to run $ldbmodify: $!";
+        print $ldif "dn: $user_dn
+changetype: modify
+replace: userPrincipalName
+userPrincipalName: jane.doe\@$ctx->{realm}
+-
+";
+	close($ldif);
+	unless ($? == 0) {
+	    warn("$ldbmodify failed: $?");
+	    return undef;
+	}
+
+	return $ret;
+}
+
+sub provision($$$$$$$$$$$)
+{
+	my ($self,
+	    $prefix,
+	    $server_role,
+	    $hostname,
+	    $domain,
+	    $realm,
+	    $functional_level,
+	    $password,
+	    $kdc_ipv4,
+	    $kdc_ipv6,
+	    $force_fips_mode,
+	    $extra_smbconf_options,
+	    $extra_smbconf_shares,
+	    $extra_provision_options) = @_;
+
+	my $samsid = Samba::random_domain_sid();
+
+	my $ctx = $self->provision_raw_prepare($prefix, $server_role,
+					       $hostname,
+					       $domain, $realm,
+					       $samsid,
+					       $functional_level,
+					       $password,
+					       $kdc_ipv4,
+					       $kdc_ipv6,
+					       $force_fips_mode,
+					       $extra_provision_options);
+
+	$ctx->{share} = "$ctx->{prefix_abs}/share";
+	push(@{$ctx->{directories}}, "$ctx->{share}");
+	push(@{$ctx->{directories}}, "$ctx->{share}/test1");
+	push(@{$ctx->{directories}}, "$ctx->{share}/test2");
+
+	# precreate directories for printer drivers
+	push(@{$ctx->{directories}}, "$ctx->{share}/W32X86");
+	push(@{$ctx->{directories}}, "$ctx->{share}/x64");
+	push(@{$ctx->{directories}}, "$ctx->{share}/WIN40");
+
+	my $msdfs = "no";
+	$msdfs = "yes" if ($server_role eq "domain controller");
+	$ctx->{smb_conf_extra_options} = "
+
+	max xmit = 32K
+	server max protocol = SMB2
+	host msdfs = $msdfs
+	lanman auth = yes
+
+	# fruit:copyfile is a global option
+	fruit:copyfile = yes
+
+	$extra_smbconf_options
+
+[tmp]
+	path = $ctx->{share}
+	read only = no
+	posix:sharedelay = 100000
+	posix:oplocktimeout = 3
+	posix:writetimeupdatedelay = 500000
+
+[xcopy_share]
+	path = $ctx->{share}
+	read only = no
+	posix:sharedelay = 100000
+	posix:oplocktimeout = 3
+	posix:writetimeupdatedelay = 500000
+	create mask = 777
+	force create mode = 777
+
+[posix_share]
+	path = $ctx->{share}
+	read only = no
+	create mask = 0777
+	force create mode = 0
+	directory mask = 0777
+	force directory mode = 0
+
+[test1]
+	path = $ctx->{share}/test1
+	read only = no
+	posix:sharedelay = 100000
+	posix:oplocktimeout = 3
+	posix:writetimeupdatedelay = 500000
+
+[test2]
+	path = $ctx->{share}/test2
+	read only = no
+	posix:sharedelay = 100000
+	posix:oplocktimeout = 3
+	posix:writetimeupdatedelay = 500000
+
+[cifs]
+	path = $ctx->{share}/_ignore_cifs_
+	read only = no
+	ntvfs handler = cifs
+	cifs:server = $ctx->{netbiosname}
+	cifs:share = tmp
+	cifs:use-s4u2proxy = yes
+	# There is no username specified here, instead the client is expected
+	# to log in with kerberos, and the serverwill use delegated credentials.
+	# Or the server tries s4u2self/s4u2proxy to impersonate the client
+
+[simple]
+	path = $ctx->{share}
+	read only = no
+	ntvfs handler = simple
+
+[sysvol]
+	path = $ctx->{statedir}/sysvol
+	read only = no
+
+[netlogon]
+	path = $ctx->{statedir}/sysvol/$ctx->{dnsname}/scripts
+	read only = no
+
+[cifsposix]
+	copy = simple
+	ntvfs handler = cifsposix
+
+[vfs_fruit]
+	path = $ctx->{share}
+	vfs objects = catia fruit streams_xattr acl_xattr
+	ea support = yes
+	fruit:resource = file
+	fruit:metadata = netatalk
+	fruit:locking = netatalk
+	fruit:encoding = native
+
+[xattr]
+	path = $ctx->{share}
+        # This can be used for testing real fs xattr stuff
+	vfs objects = streams_xattr acl_xattr
+
+$extra_smbconf_shares
+";
+
+	my $ret = $self->provision_raw_step1($ctx);
+	unless (defined $ret) {
+		return undef;
+	}
+
+	return $self->provision_raw_step2($ctx, $ret);
+}
+
+# For multi-DC testenvs, we want $DC_SERVER to always be the PDC (i.e. the
+# original DC) in the testenv. $SERVER is always the joined DC that we are
+# actually running the test against
+sub set_pdc_env_vars
+{
+	my ($self, $env, $dcvars) = @_;
+
+	$env->{DC_SERVER} = $dcvars->{DC_SERVER};
+	$env->{DC_SERVER_IP} = $dcvars->{DC_SERVER_IP};
+	$env->{DC_SERVER_IPV6} = $dcvars->{DC_SERVER_IPV6};
+	$env->{DC_SERVERCONFFILE} = $dcvars->{SERVERCONFFILE};
+	$env->{DC_NETBIOSNAME} = $dcvars->{DC_NETBIOSNAME};
+	$env->{DC_USERNAME} = $dcvars->{DC_USERNAME};
+	$env->{DC_PASSWORD} = $dcvars->{DC_PASSWORD};
+}
+
+sub provision_s4member($$$$$)
+{
+	my ($self, $prefix, $dcvars, $hostname, $more_conf) = @_;
+	print "PROVISIONING MEMBER...\n";
+	my $extra_smb_conf = "
+        passdb backend = samba_dsdb
+winbindd:use external pipes = true
+
+# the source4 smb server doesn't allow signing by default
+server signing = enabled
+raw NTLMv2 auth = yes
+
+# override the new SMB2 only default
+client min protocol = CORE
+server min protocol = LANMAN1
+";
+	if ($more_conf) {
+		$extra_smb_conf = $extra_smb_conf . $more_conf . "\n";
+	}
+	my $extra_provision_options = ["--use-ntvfs"];
+	my $ret = $self->provision($prefix,
+				   "member server",
+				   $hostname,
+				   $dcvars->{DOMAIN},
+				   $dcvars->{REALM},
+				   "2008",
+				   "locMEMpass3",
+				   $dcvars->{SERVER_IP},
+				   $dcvars->{SERVER_IPV6},
+				   undef,
+				   $extra_smb_conf, "",
+				   $extra_provision_options);
+	unless ($ret) {
+		return undef;
+	}
+
+	my $samba_tool =  Samba::bindir_path($self, "samba-tool");
+	my $cmd = $self->get_cmd_env_vars($ret);
+	$cmd .= "$samba_tool domain join $ret->{CONFIGURATION} $dcvars->{REALM} --experimental-s4-member member";
+	$cmd .= " -U$dcvars->{DC_USERNAME}\%$dcvars->{DC_PASSWORD}";
+	$cmd .= " --machinepass=machine$ret->{PASSWORD}";
+
+	unless (system($cmd) == 0) {
+		warn("Join failed\n$cmd");
+		return undef;
+	}
+
+	$ret->{DOMSID} = $dcvars->{DOMSID};
+	$self->set_pdc_env_vars($ret, $dcvars);
+
+	return $ret;
+}
+
+sub provision_rpc_proxy($$$)
+{
+	my ($self, $prefix, $dcvars) = @_;
+	print "PROVISIONING RPC PROXY...\n";
+
+	my $extra_smbconf_options = "
+        passdb backend = samba_dsdb
+
+	# rpc_proxy
+	dcerpc_remote:binding = ncacn_ip_tcp:$dcvars->{SERVER}
+	dcerpc endpoint servers = epmapper, remote
+	dcerpc_remote:interfaces = rpcecho
+	dcerpc_remote:allow_anonymous_fallback = yes
+	# override the new SMB2 only default
+	client min protocol = CORE
+	server min protocol = LANMAN1
+[cifs_to_dc]
+	path = /tmp/_ignore_cifs_to_dc_/_none_
+	read only = no
+	ntvfs handler = cifs
+	cifs:server = $dcvars->{SERVER}
+	cifs:share = cifs
+	cifs:use-s4u2proxy = yes
+	# There is no username specified here, instead the client is expected
+	# to log in with kerberos, and the serverwill use delegated credentials.
+	# Or the server tries s4u2self/s4u2proxy to impersonate the client
+
+";
+
+	my $extra_provision_options = ["--use-ntvfs"];
+	my $ret = $self->provision($prefix,
+				   "member server",
+				   "localrpcproxy",
+				   $dcvars->{DOMAIN},
+				   $dcvars->{REALM},
+				   "2008",
+				   "locRPCproxypass4",
+				   $dcvars->{SERVER_IP},
+				   $dcvars->{SERVER_IPV6},
+				   undef,
+				   $extra_smbconf_options, "",
+				   $extra_provision_options);
+	unless ($ret) {
+		return undef;
+	}
+
+	my $samba_tool =  Samba::bindir_path($self, "samba-tool");
+
+	# The joind runs in the context of the rpc_proxy/member for now
+	my $cmd = $self->get_cmd_env_vars($ret);
+	$cmd .= "$samba_tool domain join $ret->{CONFIGURATION} $dcvars->{REALM} --experimental-s4-member member";
+	$cmd .= " -U$dcvars->{DC_USERNAME}\%$dcvars->{DC_PASSWORD}";
+	$cmd .= " --machinepass=machine$ret->{PASSWORD}";
+
+	unless (system($cmd) == 0) {
+		warn("Join failed\n$cmd");
+		return undef;
+	}
+
+	# Prepare a context of the DC, but using the local CCACHE.
+	my $overwrite = undef;
+	$overwrite->{KRB5_CCACHE} = $ret->{KRB5_CCACHE};
+	my $dc_cmd_env = $self->get_cmd_env_vars($dcvars, $overwrite);
+
+	# Setting up delegation runs in the context of the DC for now
+	$cmd = $dc_cmd_env;
+	$cmd .= "$samba_tool delegation for-any-protocol '$ret->{NETBIOSNAME}\$' on";
+        $cmd .= " $dcvars->{CONFIGURATION}";
+        print $cmd;
+
+	unless (system($cmd) == 0) {
+		warn("Delegation failed\n$cmd");
+		return undef;
+	}
+
+	# Setting up delegation runs in the context of the DC for now
+	$cmd = $dc_cmd_env;
+	$cmd .= "$samba_tool delegation add-service '$ret->{NETBIOSNAME}\$' cifs/$dcvars->{SERVER}";
+        $cmd .= " $dcvars->{CONFIGURATION}";
+
+	unless (system($cmd) == 0) {
+		warn("Delegation failed\n$cmd");
+		return undef;
+	}
+
+	$ret->{DOMSID} = $dcvars->{DOMSID};
+	$self->set_pdc_env_vars($ret, $dcvars);
+
+	return $ret;
+}
+
+sub provision_promoted_dc($$$)
+{
+	my ($self, $prefix, $dcvars) = @_;
+	print "PROVISIONING PROMOTED DC...\n";
+
+	# We do this so that we don't run the provision.  That's the job of 'samba-tool domain dcpromo'.
+	my $ctx = $self->provision_raw_prepare($prefix, "domain controller",
+					       "promotedvdc",
+					       $dcvars->{DOMAIN},
+					       $dcvars->{REALM},
+					       $dcvars->{SAMSID},
+					       "2008",
+					       $dcvars->{PASSWORD},
+					       $dcvars->{SERVER_IP},
+					       $dcvars->{SERVER_IPV6});
+
+	$ctx->{smb_conf_extra_options} = "
+	max xmit = 32K
+	server max protocol = SMB2
+
+        ntlm auth = ntlmv2-only
+
+	kdc force enable rc4 weak session keys = yes
+
+[sysvol]
+	path = $ctx->{statedir}/sysvol
+	read only = yes
+
+[netlogon]
+	path = $ctx->{statedir}/sysvol/$ctx->{dnsname}/scripts
+	read only = no
+
+";
+
+	my $ret = $self->provision_raw_step1($ctx);
+	unless ($ret) {
+		return undef;
+	}
+
+	my $samba_tool =  Samba::bindir_path($self, "samba-tool");
+	my $cmd = $self->get_cmd_env_vars($ret);
+	$cmd .= "$samba_tool domain join $ret->{CONFIGURATION} $dcvars->{REALM} --experimental-s4-member MEMBER --realm=$dcvars->{REALM}";
+	$cmd .= " -U$dcvars->{DC_USERNAME}\%$dcvars->{DC_PASSWORD}";
+	$cmd .= " --machinepass=machine$ret->{PASSWORD}";
+
+	unless (system($cmd) == 0) {
+		warn("Join failed\n$cmd");
+		return undef;
+	}
+
+	$samba_tool =  Samba::bindir_path($self, "samba-tool");
+	$cmd = $self->get_cmd_env_vars($ret);
+	$cmd .= "$samba_tool domain dcpromo $ret->{CONFIGURATION} $dcvars->{REALM} DC --realm=$dcvars->{REALM}";
+	$cmd .= " -U$dcvars->{DC_USERNAME}\%$dcvars->{DC_PASSWORD}";
+	$cmd .= " --machinepass=machine$ret->{PASSWORD} --dns-backend=BIND9_DLZ";
+
+	unless (system($cmd) == 0) {
+		warn("Join failed\n$cmd");
+		return undef;
+	}
+
+	$self->set_pdc_env_vars($ret, $dcvars);
+
+	return $ret;
+}
+
+sub provision_vampire_dc($$$)
+{
+	my ($self, $prefix, $dcvars, $fl) = @_;
+	print "PROVISIONING VAMPIRE DC @ FL $fl...\n";
+	my $name = "localvampiredc";
+	my $extra_conf = "";
+
+	if ($fl == "2000") {
+		$name = "vampire2000dc";
+	} else {
+		$extra_conf = "drs: immediate link sync = yes
+                       drs: max link sync = 250";
+	}
+
+	# We do this so that we don't run the provision.  That's the job of 'net vampire'.
+	my $ctx = $self->provision_raw_prepare($prefix, "domain controller",
+					       $name,
+					       $dcvars->{DOMAIN},
+					       $dcvars->{REALM},
+					       $dcvars->{DOMSID},
+					       $fl,
+					       $dcvars->{PASSWORD},
+					       $dcvars->{SERVER_IP},
+					       $dcvars->{SERVER_IPV6});
+
+	$ctx->{smb_conf_extra_options} = "
+	max xmit = 32K
+	server max protocol = SMB2
+
+        ntlm auth = mschapv2-and-ntlmv2-only
+	$extra_conf
+
+[sysvol]
+	path = $ctx->{statedir}/sysvol
+	read only = yes
+
+[netlogon]
+	path = $ctx->{statedir}/sysvol/$ctx->{dnsname}/scripts
+	read only = no
+
+";
+
+	my $ret = $self->provision_raw_step1($ctx);
+	unless ($ret) {
+		return undef;
+	}
+
+	my $samba_tool =  Samba::bindir_path($self, "samba-tool");
+	my $cmd = $self->get_cmd_env_vars($ret);
+	$cmd .= "$samba_tool domain join $ret->{CONFIGURATION} $dcvars->{REALM} DC --realm=$dcvars->{REALM}";
+	$cmd .= " -U$dcvars->{DC_USERNAME}\%$dcvars->{DC_PASSWORD} --domain-critical-only";
+	$cmd .= " --machinepass=machine$ret->{PASSWORD}";
+	$cmd .= " --backend-store=mdb";
+
+	unless (system($cmd) == 0) {
+		warn("Join failed\n$cmd");
+		return undef;
+	}
+
+	$self->set_pdc_env_vars($ret, $dcvars);
+	$ret->{DC_REALM} = $dcvars->{DC_REALM};
+
+	return $ret;
+}
+
+sub provision_ad_dc_ntvfs($$$)
+{
+	my ($self, $prefix, $extra_provision_options) = @_;
+
+	# We keep the old 'winbind' name here in server services to
+	# ensure upgrades which used that name still work with the now
+	# alias.
+
+	print "PROVISIONING AD DC (NTVFS)...\n";
+        my $extra_conf_options = "netbios aliases = localDC1-a
+        server services = +winbind -winbindd
+	ldap server require strong auth = allow_sasl_over_tls
+	raw NTLMv2 auth = yes
+	lsa over netlogon = yes
+        rpc server port = 1027
+        auth event notification = true
+	dsdb event notification = true
+	dsdb password event notification = true
+	dsdb group change notification = true
+	# override the new SMB2 only default
+	client min protocol = CORE
+	server min protocol = LANMAN1
+
+	CVE_2020_1472:warn_about_unused_debug_level = 3
+	CVE_2022_38023:warn_about_unused_debug_level = 3
+	allow nt4 crypto:torturetest\$ = yes
+	server reject md5 schannel:schannel2\$ = no
+	server reject md5 schannel:schannel3\$ = no
+	server reject md5 schannel:schannel8\$ = no
+	server reject md5 schannel:schannel9\$ = no
+	server reject md5 schannel:torturetest\$ = no
+	server reject md5 schannel:tests4u2proxywk\$ = no
+	server reject md5 schannel:tests4u2selfbdc\$ = no
+	server reject md5 schannel:tests4u2selfwk\$ = no
+	server reject md5 schannel:torturepacbdc\$ = no
+	server reject md5 schannel:torturepacwksta\$ = no
+	server require schannel:schannel0\$ = no
+	server require schannel:schannel1\$ = no
+	server require schannel:schannel2\$ = no
+	server require schannel:schannel3\$ = no
+	server require schannel:schannel4\$ = no
+	server require schannel:schannel5\$ = no
+	server require schannel:schannel6\$ = no
+	server require schannel:schannel7\$ = no
+	server require schannel:schannel8\$ = no
+	server require schannel:schannel9\$ = no
+	server require schannel:schannel10\$ = no
+	server require schannel:schannel11\$ = no
+	server require schannel:torturetest\$ = no
+	server schannel require seal:schannel0\$ = no
+	server schannel require seal:schannel1\$ = no
+	server schannel require seal:schannel2\$ = no
+	server schannel require seal:schannel3\$ = no
+	server schannel require seal:schannel4\$ = no
+	server schannel require seal:schannel5\$ = no
+	server schannel require seal:schannel6\$ = no
+	server schannel require seal:schannel7\$ = no
+	server schannel require seal:schannel8\$ = no
+	server schannel require seal:schannel9\$ = no
+	server schannel require seal:schannel10\$ = no
+	server schannel require seal:schannel11\$ = no
+	server schannel require seal:torturetest\$ = no
+
+	# needed for 'samba.tests.auth_log' tests
+	server require schannel:LOCALDC\$ = no
+	server schannel require seal:LOCALDC\$ = no
+	";
+	push (@{$extra_provision_options}, "--use-ntvfs");
+	my $ret = $self->provision($prefix,
+				   "domain controller",
+				   "localdc",
+				   "SAMBADOMAIN",
+				   "samba.example.com",
+				   "2008",
+				   "locDCpass1",
+				   undef,
+				   undef,
+				   undef,
+				   $extra_conf_options,
+				   "",
+				   $extra_provision_options);
+	unless ($ret) {
+		return undef;
+	}
+
+	unless($self->add_wins_config("$prefix/private")) {
+		warn("Unable to add wins configuration");
+		return undef;
+	}
+	$ret->{NETBIOSALIAS} = "localdc1-a";
+	$ret->{DC_REALM} = $ret->{REALM};
+
+	return $ret;
+}
+
+sub provision_fl2000dc($$)
+{
+	my ($self, $prefix) = @_;
+
+	print "PROVISIONING DC WITH FOREST LEVEL 2000...\n";
+	my $extra_conf_options = "
+	kdc enable fast = no
+	spnego:simulate_w2k=yes
+	ntlmssp_server:force_old_spnego=yes
+
+	CVE_2022_38023:warn_about_unused_debug_level = 3
+	server reject md5 schannel:tests4u2proxywk\$ = no
+	server reject md5 schannel:tests4u2selfbdc\$ = no
+	server reject md5 schannel:tests4u2selfwk\$ = no
+	server reject md5 schannel:torturepacbdc\$ = no
+	server reject md5 schannel:torturepacwksta\$ = no
+";
+	my $extra_provision_options = ["--base-schema=2008_R2"];
+	# This environment uses plain text secrets
+	# i.e. secret attributes are not encrypted on disk.
+	# This allows testing of the --plaintext-secrets option for
+	# provision
+	push (@{$extra_provision_options}, "--plaintext-secrets");
+	my $ret = $self->provision($prefix,
+				   "domain controller",
+				   "dc5",
+				   "SAMBA2000",
+				   "samba2000.example.com",
+				   "2000",
+				   "locDCpass5",
+				   undef,
+				   undef,
+				   undef,
+				   $extra_conf_options,
+				   "",
+				   $extra_provision_options);
+	unless ($ret) {
+		return undef;
+	}
+
+	unless($self->add_wins_config("$prefix/private")) {
+		warn("Unable to add wins configuration");
+		return undef;
+	}
+	$ret->{DC_REALM} = $ret->{REALM};
+
+	return $ret;
+}
+
+sub provision_fl2003dc($$$)
+{
+	my ($self, $prefix, $dcvars) = @_;
+	my $ip_addr1 = Samba::get_ipv4_addr("fakednsforwarder1");
+	my $ip_addr2 = Samba::get_ipv6_addr("fakednsforwarder2");
+
+	print "PROVISIONING DC WITH FOREST LEVEL 2003...\n";
+	my $extra_conf_options = "
+	allow dns updates = nonsecure and secure
+
+	kdc enable fast = no
+	dcesrv:header signing = no
+	dcesrv:max auth states = 0
+
+	dns forwarder = $ip_addr1 [$ip_addr2]:54
+
+	CVE_2022_38023:warn_about_unused_debug_level = 3
+	server reject md5 schannel:tests4u2proxywk\$ = no
+	server reject md5 schannel:tests4u2selfbdc\$ = no
+	server reject md5 schannel:tests4u2selfwk\$ = no
+	server reject md5 schannel:torturepacbdc\$ = no
+	server reject md5 schannel:torturepacwksta\$ = no
+";
+
+	my $extra_provision_options = ["--base-schema=2008_R2"];
+	my $ret = $self->provision($prefix,
+				   "domain controller",
+				   "dc6",
+				   "SAMBA2003",
+				   "samba2003.example.com",
+				   "2003",
+				   "locDCpass6",
+				   undef,
+				   undef,
+				   undef,
+				   $extra_conf_options,
+				   "",
+				   $extra_provision_options);
+	unless (defined $ret) {
+		return undef;
+	}
+
+	$ret->{DNS_FORWARDER1} = $ip_addr1;
+	$ret->{DNS_FORWARDER2} = $ip_addr2;
+
+	my @samba_tool_options;
+	push (@samba_tool_options, Samba::bindir_path($self, "samba-tool"));
+	push (@samba_tool_options, "domain");
+	push (@samba_tool_options, "passwordsettings");
+	push (@samba_tool_options, "set");
+	push (@samba_tool_options, "--configfile=$ret->{SERVERCONFFILE}");
+	push (@samba_tool_options, "--min-pwd-age=0");
+	push (@samba_tool_options, "--history-length=1");
+
+	my $samba_tool_cmd = join(" ", @samba_tool_options);
+
+	unless (system($samba_tool_cmd) == 0) {
+		warn("Unable to set min password age to 0: \n$samba_tool_cmd\n");
+		return undef;
+	}
+
+	unless($self->add_wins_config("$prefix/private")) {
+		warn("Unable to add wins configuration");
+		return undef;
+	}
+
+	return $ret;
+}
+
+sub provision_fl2008r2dc($$$)
+{
+	my ($self, $prefix, $dcvars) = @_;
+
+	print "PROVISIONING DC WITH FOREST LEVEL 2008r2...\n";
+        my $extra_conf_options = "
+	ldap server require strong auth = no
+        # delay by 10 seconds, 10^7 usecs
+	ldap_server:delay_expire_disconnect = 10000
+
+	CVE_2022_38023:warn_about_unused_debug_level = 3
+	server reject md5 schannel:tests4u2proxywk\$ = no
+	server reject md5 schannel:tests4u2selfbdc\$ = no
+	server reject md5 schannel:tests4u2selfwk\$ = no
+	server reject md5 schannel:torturepacbdc\$ = no
+	server reject md5 schannel:torturepacwksta\$ = no
+";
+	my $extra_provision_options = ["--base-schema=2008_R2"];
+	my $ret = $self->provision($prefix,
+				   "domain controller",
+				   "dc7",
+				   "SAMBA2008R2",
+				   "samba2008R2.example.com",
+				   "2008_R2",
+				   "locDCpass7",
+				   undef,
+				   undef,
+				   undef,
+				   $extra_conf_options,
+				   "",
+				   $extra_provision_options);
+	unless (defined $ret) {
+		return undef;
+	}
+
+	unless ($self->add_wins_config("$prefix/private")) {
+		warn("Unable to add wins configuration");
+		return undef;
+	}
+	$ret->{DC_REALM} = $ret->{REALM};
+
+	return $ret;
+}
+
+
+sub provision_rodc($$$)
+{
+	my ($self, $prefix, $dcvars) = @_;
+	print "PROVISIONING RODC...\n";
+
+	# We do this so that we don't run the provision.  That's the job of 'net join RODC'.
+	my $ctx = $self->provision_raw_prepare($prefix, "domain controller",
+					       "rodc",
+					       $dcvars->{DOMAIN},
+					       $dcvars->{REALM},
+					       $dcvars->{DOMSID},
+					       "2008",
+					       $dcvars->{PASSWORD},
+					       $dcvars->{SERVER_IP},
+					       $dcvars->{SERVER_IPV6});
+	unless ($ctx) {
+		return undef;
+	}
+
+	$ctx->{share} = "$ctx->{prefix_abs}/share";
+	push(@{$ctx->{directories}}, "$ctx->{share}");
+
+	$ctx->{smb_conf_extra_options} = "
+	max xmit = 32K
+	server max protocol = SMB2
+	password server = $dcvars->{DC_SERVER}
+
+[sysvol]
+	path = $ctx->{statedir}/sysvol
+	read only = yes
+
+[netlogon]
+	path = $ctx->{statedir}/sysvol/$ctx->{dnsname}/scripts
+	read only = yes
+
+[tmp]
+	path = $ctx->{share}
+	read only = no
+	posix:sharedelay = 10000
+	posix:oplocktimeout = 3
+	posix:writetimeupdatedelay = 50000
+
+";
+
+	my $ret = $self->provision_raw_step1($ctx);
+	unless ($ret) {
+		return undef;
+	}
+
+	my $samba_tool =  Samba::bindir_path($self, "samba-tool");
+	my $cmd = $self->get_cmd_env_vars($ret);
+	$cmd .= "$samba_tool domain join $ret->{CONFIGURATION} $dcvars->{REALM} RODC";
+	$cmd .= " -U$dcvars->{DC_USERNAME}\%$dcvars->{DC_PASSWORD}";
+	$cmd .= " --server=$dcvars->{DC_SERVER}";
+
+	unless (system($cmd) == 0) {
+		warn("RODC join failed\n$cmd");
+		return undef;
+	}
+
+        # This ensures deterministic behaviour for tests that want to have the 'testallowed account'
+        # user password verified on the RODC
+	my $testallowed_account = "testallowed account";
+	$cmd = $self->get_cmd_env_vars($ret);
+	$cmd .= "$samba_tool rodc preload '$testallowed_account' $ret->{CONFIGURATION}";
+	$cmd .= " --server=$dcvars->{DC_SERVER}";
+
+	unless (system($cmd) == 0) {
+		warn("RODC join failed\n$cmd");
+		return undef;
+	}
+
+	# we overwrite the kdc after the RODC join
+	# so that use the RODC as kdc and test
+	# the proxy code
+	$ctx->{kdc_ipv4} = $ret->{SERVER_IP};
+	$ctx->{kdc_ipv6} = $ret->{SERVER_IPV6};
+	Samba::mk_krb5_conf($ctx);
+	Samba::mk_mitkdc_conf($ctx, abs_path(Samba::bindir_path($self, "shared")));
+
+	$self->set_pdc_env_vars($ret, $dcvars);
+
+	return $ret;
+}
+
+sub read_config_h($)
+{
+	my ($name) = @_;
+	my %ret;
+	open(LF, "<$name") or die("unable to read $name: $!");
+	while (<LF>) {
+		chomp;
+		next if not (/^#define /);
+		if (/^#define (.*?)[ \t]+(.*?)$/) {
+			$ret{$1} = $2;
+			next;
+		}
+		if (/^#define (.*?)[ \t]+$/) {
+			$ret{$1} = 1;;
+			next;
+		}
+	}
+	close(LF);
+	return \%ret;
+}
+
+sub provision_ad_dc($$$$$$$)
+{
+	my ($self,
+	    $prefix,
+	    $hostname,
+	    $domain,
+	    $realm,
+	    $force_fips_mode,
+	    $smbconf_args,
+	    $extra_provision_options) = @_;
+
+	my $prefix_abs = abs_path($prefix);
+
+	my $bindir_abs = abs_path($self->{bindir});
+	my $lockdir="$prefix_abs/lockdir";
+        my $conffile="$prefix_abs/etc/smb.conf";
+
+	my $require_mutexes = "dbwrap_tdb_require_mutexes:* = yes";
+	if ($ENV{SELFTEST_DONT_REQUIRE_TDB_MUTEX_SUPPORT} // '' eq "1") {
+		$require_mutexes = "";
+	}
+
+	my $config_h = {};
+
+	if (defined($ENV{CONFIG_H})) {
+		$config_h = read_config_h($ENV{CONFIG_H});
+	}
+
+	my $password_hash_gpg_key_ids = "password hash gpg key ids = 4952E40301FAB41A";
+	$password_hash_gpg_key_ids = "" unless defined($config_h->{HAVE_GPGME});
+
+	my $extra_smbconf_options = "
+        xattr_tdb:file = $prefix_abs/statedir/xattr.tdb
+
+	dbwrap_tdb_mutexes:* = yes
+	${require_mutexes}
+
+	${password_hash_gpg_key_ids}
+
+	kernel oplocks = no
+	kernel change notify = no
+	smb2 leases = no
+	smb2 disable oplock break retry = yes
+	server multi channel support = yes
+
+	logging = file
+	printing = bsd
+	printcap name = /dev/null
+
+	max protocol = SMB3
+	read only = no
+
+	smbd:sharedelay = 100000
+	smbd:writetimeupdatedelay = 500000
+	create mask = 755
+	dos filemode = yes
+	check parent directory delete on close = yes
+
+        dcerpc endpoint servers = -winreg -srvsvc
+
+	printcap name = /dev/null
+
+	addprinter command = $ENV{SRCDIR_ABS}/source3/script/tests/printing/modprinter.pl -a -s $conffile --
+	deleteprinter command = $ENV{SRCDIR_ABS}/source3/script/tests/printing/modprinter.pl -d -s $conffile --
+
+	printing = vlp
+	print command = $bindir_abs/vlp tdbfile=$lockdir/vlp.tdb print %p %s
+	lpq command = $bindir_abs/vlp tdbfile=$lockdir/vlp.tdb lpq %p
+	lp rm command = $bindir_abs/vlp tdbfile=$lockdir/vlp.tdb lprm %p %j
+	lp pause command = $bindir_abs/vlp tdbfile=$lockdir/vlp.tdb lppause %p %j
+	lp resume command = $bindir_abs/vlp tdbfile=$lockdir/vlp.tdb lpresume %p %j
+	queue pause command = $bindir_abs/vlp tdbfile=$lockdir/vlp.tdb queuepause %p
+	queue resume command = $bindir_abs/vlp tdbfile=$lockdir/vlp.tdb queueresume %p
+	lpq cache time = 0
+	print notify backchannel = yes
+
+	CVE_2020_1472:warn_about_unused_debug_level = 3
+	CVE_2022_38023:warn_about_unused_debug_level = 3
+	CVE_2022_38023:error_debug_level = 2
+	server reject md5 schannel:schannel2\$ = no
+	server reject md5 schannel:schannel3\$ = no
+	server reject md5 schannel:schannel8\$ = no
+	server reject md5 schannel:schannel9\$ = no
+	server reject md5 schannel:torturetest\$ = no
+	server reject md5 schannel:tests4u2proxywk\$ = no
+	server reject md5 schannel:tests4u2selfbdc\$ = no
+	server reject md5 schannel:tests4u2selfwk\$ = no
+	server reject md5 schannel:torturepacbdc\$ = no
+	server reject md5 schannel:torturepacwksta\$ = no
+	server reject md5 schannel:samlogontest\$ = no
+	server require schannel:schannel0\$ = no
+	server require schannel:schannel1\$ = no
+	server require schannel:schannel2\$ = no
+	server require schannel:schannel3\$ = no
+	server require schannel:schannel4\$ = no
+	server require schannel:schannel5\$ = no
+	server require schannel:schannel6\$ = no
+	server require schannel:schannel7\$ = no
+	server require schannel:schannel8\$ = no
+	server require schannel:schannel9\$ = no
+	server require schannel:schannel10\$ = no
+	server require schannel:schannel11\$ = no
+	server require schannel:torturetest\$ = no
+	server schannel require seal:schannel0\$ = no
+	server schannel require seal:schannel1\$ = no
+	server schannel require seal:schannel2\$ = no
+	server schannel require seal:schannel3\$ = no
+	server schannel require seal:schannel4\$ = no
+	server schannel require seal:schannel5\$ = no
+	server schannel require seal:schannel6\$ = no
+	server schannel require seal:schannel7\$ = no
+	server schannel require seal:schannel8\$ = no
+	server schannel require seal:schannel9\$ = no
+	server schannel require seal:schannel10\$ = no
+	server schannel require seal:schannel11\$ = no
+	server schannel require seal:torturetest\$ = no
+
+	auth event notification = true
+	dsdb event notification = true
+	dsdb password event notification = true
+	dsdb group change notification = true
+        $smbconf_args
+";
+
+	my $extra_smbconf_shares = "
+
+[tmpenc]
+	copy = tmp
+	smb encrypt = required
+
+[tmpcase]
+	copy = tmp
+	case sensitive = yes
+
+[tmpguest]
+	copy = tmp
+        guest ok = yes
+
+[hideunread]
+	copy = tmp
+	hide unreadable = yes
+
+[durable]
+	copy = tmp
+	kernel share modes = no
+	kernel oplocks = no
+	posix locking = no
+
+[print\$]
+	copy = tmp
+
+[print1]
+	copy = tmp
+	printable = yes
+
+[print2]
+	copy = print1
+[print3]
+	copy = print1
+[print4]
+	copy = print1
+	guest ok = yes
+[lp]
+	copy = print1
+";
+
+	push (@{$extra_provision_options}, "--backend-store=mdb");
+	print "PROVISIONING AD DC...\n";
+	my $ret = $self->provision($prefix,
+				   "domain controller",
+				   $hostname,
+				   $domain,
+				   $realm,
+				   "2008",
+				   "locDCpass1",
+				   undef,
+				   undef,
+				   $force_fips_mode,
+				   $extra_smbconf_options,
+				   $extra_smbconf_shares,
+				   $extra_provision_options);
+	unless (defined $ret) {
+		return undef;
+	}
+
+	unless($self->add_wins_config("$prefix/private")) {
+		warn("Unable to add wins configuration");
+		return undef;
+	}
+
+	return $ret;
+}
+
+sub provision_chgdcpass($$)
+{
+	my ($self, $prefix) = @_;
+
+	print "PROVISIONING CHGDCPASS...\n";
+	# This environment disallows the use of this password
+	# (and also removes the default AD complexity checks)
+	my $unacceptable_password = "Paword-widk3Dsle32jxdBdskldsk55klASKQ";
+
+	# This environment also sets some settings that are unusual,
+	# to test specific behaviours.  In particular, this
+	# environment fails to correctly support DRSUAPI_DRS_GET_ANC
+	# like Samba before 4.5 and DRSUAPI_DRS_GET_TGT before 4.8
+	#
+	# Additionally, disabling DRSUAPI_DRS_GET_TGT causes all links
+	# to be sent last (in the final chunk), which is like Samba
+	# before 4.8.
+
+	my $extra_smb_conf = "
+	check password script = $self->{srcdir}/selftest/checkpassword_arg1.sh ${unacceptable_password}
+	allow dcerpc auth level connect:lsarpc = yes
+	dcesrv:max auth states = 8
+        drs:broken_samba_4.5_get_anc_emulation = true
+        drs:get_tgt_support = false
+";
+	my $extra_provision_options = ["--dns-backend=BIND9_DLZ"];
+	my $ret = $self->provision($prefix,
+				   "domain controller",
+				   "chgdcpass",
+				   "CHDCDOMAIN",
+				   "chgdcpassword.samba.example.com",
+				   "2008",
+				   "chgDCpass1",
+				   undef,
+				   undef,
+				   undef,
+				   $extra_smb_conf,
+				   "",
+				   $extra_provision_options);
+	unless (defined $ret) {
+		return undef;
+	}
+
+	unless($self->add_wins_config("$prefix/private")) {
+		warn("Unable to add wins configuration");
+		return undef;
+	}
+	
+	# Remove secrets.tdb from this environment to test that we
+	# still start up on systems without the new matching
+	# secrets.tdb records.
+	unless (unlink("$ret->{PRIVATEDIR}/secrets.tdb") || unlink("$ret->{PRIVATEDIR}/secrets.ntdb")) {
+		warn("Unable to remove $ret->{PRIVATEDIR}/secrets.tdb added during provision");
+		return undef;
+	}
+
+	$ret->{UNACCEPTABLE_PASSWORD} = $unacceptable_password;
+
+	return $ret;
+}
+
+sub teardown_env_terminate($$)
+{
+	my ($self, $envvars) = @_;
+	my $pid;
+
+	# This should cause samba to terminate gracefully
+	my $smbcontrol = Samba::bindir_path($self, "smbcontrol");
+	my $cmd = "";
+	$cmd .= "$smbcontrol samba shutdown $envvars->{CONFIGURATION}";
+	my $ret = system($cmd);
+	if ($ret != 0) {
+		warn "'$cmd' failed with '$ret'\n";
+	}
+
+	# This should cause samba to terminate gracefully
+	close($envvars->{STDIN_PIPE});
+
+	$pid = $envvars->{SAMBA_PID};
+	my $count = 0;
+	my $childpid;
+
+	# This should give it time to write out the gcov data
+	until ($count > 15) {
+	    if (Samba::cleanup_child($pid, "samba") != 0) {
+		return;
+	    }
+	    sleep(1);
+	    $count++;
+	}
+
+	# After 15 Seconds, work out why this thing is still alive
+	warn "server process $pid took more than $count seconds to exit, showing backtrace:\n";
+	system("$self->{srcdir}/selftest/gdb_backtrace $pid");
+
+	until ($count > 30) {
+	    if (Samba::cleanup_child($pid, "samba") != 0) {
+		return;
+	    }
+	    sleep(1);
+	    $count++;
+	}
+
+	if (kill(0, $pid)) {
+	    warn "server process $pid took more than $count seconds to exit, sending SIGTERM\n";
+	    kill "TERM", $pid;
+	}
+
+	until ($count > 40) {
+	    if (Samba::cleanup_child($pid, "samba") != 0) {
+		return;
+	    }
+	    sleep(1);
+	    $count++;
+	}
+	# If it is still around, kill it
+	if (kill(0, $pid)) {
+	    warn "server process $pid took more than $count seconds to exit, killing\n with SIGKILL\n";
+	    kill 9, $pid;
+	}
+	return;
+}
+
+sub teardown_env($$)
+{
+	my ($self, $envvars) = @_;
+	teardown_env_terminate($self, $envvars);
+
+	print $self->getlog_env($envvars);
+
+	return;
+}
+
+sub getlog_env($$)
+{
+	my ($self, $envvars) = @_;
+	my $title = "SAMBA LOG of: $envvars->{NETBIOSNAME} pid $envvars->{SAMBA_PID}\n";
+	my $out = $title;
+
+	open(LOG, "<$envvars->{SAMBA_TEST_LOG}");
+
+	seek(LOG, $envvars->{SAMBA_TEST_LOG_POS}, SEEK_SET);
+	while (<LOG>) {
+		$out .= $_;
+	}
+	$envvars->{SAMBA_TEST_LOG_POS} = tell(LOG);
+	close(LOG);
+
+	return "" if $out eq $title;
+
+	return $out;
+}
+
+sub check_env($$)
+{
+	my ($self, $envvars) = @_;
+	my $samba_pid = $envvars->{SAMBA_PID};
+
+	if (not defined($samba_pid)) {
+	    return 0;
+	} elsif ($samba_pid > 0) {
+	    my $childpid = Samba::cleanup_child($samba_pid, "samba");
+
+	    if ($childpid == 0) {
+		return 1;
+	    }
+	    return 0;
+	} else {
+	    return 1;
+	}
+}
+
+# Declare the environments Samba4 makes available.
+# To be set up, they will be called as
+#   samba4->setup_$envname($self, $path, $dep_1_vars, $dep_2_vars, ...)
+# The interdependencies between the testenvs are declared below. Some testenvs
+# are dependent on another testenv running first, e.g. vampire_dc is dependent
+# on ad_dc_ntvfs because vampire_dc joins ad_dc_ntvfs's domain. All DCs are
+# dependent on dns_hub, which handles resolving DNS queries for the realm.
+%Samba4::ENV_DEPS = (
+	# name               => [dep_1, dep_2, ...],
+	dns_hub              => [],
+	ad_dc_ntvfs          => ["dns_hub"],
+	ad_dc_fips           => ["dns_hub"],
+	ad_dc                => ["dns_hub"],
+	ad_dc_smb1           => ["dns_hub"],
+	ad_dc_smb1_done      => ["ad_dc_smb1"],
+	ad_dc_no_nss         => ["dns_hub"],
+	ad_dc_no_ntlm        => ["dns_hub"],
+
+	fl2008r2dc           => ["ad_dc"],
+	fl2003dc             => ["ad_dc"],
+	fl2000dc             => ["ad_dc"],
+
+	vampire_2000_dc      => ["fl2000dc"],
+	vampire_dc           => ["ad_dc_ntvfs"],
+	promoted_dc          => ["ad_dc_ntvfs"],
+
+	rodc                 => ["ad_dc_ntvfs"],
+	rpc_proxy            => ["ad_dc_ntvfs"],
+	chgdcpass            => ["dns_hub"],
+
+	s4member_dflt_domain => ["ad_dc_ntvfs"],
+	s4member             => ["ad_dc_ntvfs"],
+
+	# envs that test the server process model
+	proclimitdc          => ["dns_hub"],
+	preforkrestartdc     => ["dns_hub"],
+
+	# backup/restore testenvs
+	backupfromdc         => ["dns_hub"],
+	customdc             => ["dns_hub"],
+	restoredc            => ["backupfromdc"],
+	renamedc             => ["backupfromdc"],
+	offlinebackupdc      => ["backupfromdc"],
+	labdc                => ["backupfromdc"],
+
+	# aliases in order to split autbuild tasks
+	fl2008dc             => ["ad_dc"],
+	ad_dc_default        => ["ad_dc"],
+	ad_dc_default_smb1   => ["ad_dc_smb1"],
+	ad_dc_default_smb1_done   => ["ad_dc_default_smb1"],
+	ad_dc_slowtests      => ["ad_dc"],
+	ad_dc_backup         => ["ad_dc"],
+
+	schema_dc      => ["dns_hub"],
+	schema_pair_dc => ["schema_dc"],
+
+	none                 => [],
+);
+
+%Samba4::ENV_DEPS_POST = (
+	schema_dc => ["schema_pair_dc"],
+);
+
+sub return_alias_env
+{
+	my ($self, $path, $env) = @_;
+
+	# just an alias
+	return $env;
+}
+
+sub setup_fl2008dc
+{
+	my ($self, $path) = @_;
+
+	my $extra_args = ["--base-schema=2008_R2"];
+	my $env = $self->provision_ad_dc_ntvfs($path, $extra_args);
+	if (defined $env) {
+	        if (not defined($self->check_or_start($env, "standard"))) {
+		    warn("Failed to start fl2008dc");
+		        return undef;
+		}
+	}
+	return $env;
+}
+
+sub setup_ad_dc_default
+{
+	my ($self, $path, $dep_env) = @_;
+	return $self->return_alias_env($path, $dep_env)
+}
+
+sub setup_ad_dc_default_smb1
+{
+	my ($self, $path, $dep_env) = @_;
+	return $self->return_alias_env($path, $dep_env)
+}
+
+sub setup_ad_dc_default_smb1_done
+{
+	my ($self, $path, $dep_env) = @_;
+	return $self->return_alias_env($path, $dep_env)
+}
+
+sub setup_ad_dc_slowtests
+{
+	my ($self, $path, $dep_env) = @_;
+	return $self->return_alias_env($path, $dep_env)
+}
+
+sub setup_ad_dc_backup
+{
+	my ($self, $path, $dep_env) = @_;
+	return $self->return_alias_env($path, $dep_env)
+}
+
+sub setup_s4member
+{
+	my ($self, $path, $dc_vars) = @_;
+
+	my $env = $self->provision_s4member($path, $dc_vars, "s4member");
+
+	if (defined $env) {
+	        if (not defined($self->check_or_start($env, "standard"))) {
+		        return undef;
+		}
+	}
+
+	return $env;
+}
+
+sub setup_s4member_dflt_domain
+{
+	my ($self, $path, $dc_vars) = @_;
+
+	my $env = $self->provision_s4member($path, $dc_vars, "s4member_dflt",
+					    "winbind use default domain = yes");
+
+	if (defined $env) {
+	        if (not defined($self->check_or_start($env, "standard"))) {
+		        return undef;
+		}
+	}
+
+	return $env;
+}
+
+sub setup_rpc_proxy
+{
+	my ($self, $path, $dc_vars) = @_;
+
+	my $env = $self->provision_rpc_proxy($path, $dc_vars);
+
+	if (defined $env) {
+	        if (not defined($self->check_or_start($env, "standard"))) {
+		        return undef;
+		}
+	}
+	return $env;
+}
+
+sub setup_ad_dc_ntvfs
+{
+	my ($self, $path) = @_;
+
+	my $env = $self->provision_ad_dc_ntvfs($path, undef);
+	if (defined $env) {
+	        if (not defined($self->check_or_start($env, "standard"))) {
+		    warn("Failed to start ad_dc_ntvfs");
+		        return undef;
+		}
+	}
+	return $env;
+}
+
+sub setup_chgdcpass
+{
+	my ($self, $path) = @_;
+
+	my $env = $self->provision_chgdcpass($path);
+	if (defined $env) {
+	        if (not defined($self->check_or_start($env, "standard"))) {
+		        return undef;
+		}
+	}
+	return $env;
+}
+
+sub setup_fl2000dc
+{
+	my ($self, $path, $dc_vars) = @_;
+
+	my $env = $self->provision_fl2000dc($path);
+	if (defined $env) {
+	        if (not defined($self->check_or_start($env, "standard"))) {
+		        return undef;
+		}
+
+		$env = $self->setup_trust($env, $dc_vars, "external", "--no-aes-keys --direction=outgoing");
+	}
+
+	return $env;
+}
+
+sub setup_fl2003dc
+{
+	my ($self, $path, $dc_vars) = @_;
+
+	my $env = $self->provision_fl2003dc($path);
+
+	if (defined $env) {
+	        if (not defined($self->check_or_start($env, "standard"))) {
+		        return undef;
+		}
+
+		$env = $self->setup_trust($env, $dc_vars, "external", "--no-aes-keys");
+	}
+	return $env;
+}
+
+sub setup_fl2008r2dc
+{
+	my ($self, $path, $dc_vars) = @_;
+
+	my $env = $self->provision_fl2008r2dc($path);
+
+	if (defined $env) {
+	        if (not defined($self->check_or_start($env, "standard"))) {
+		        return undef;
+		}
+
+		my $upn_array = ["$env->{REALM}.upn"];
+		my $spn_array = ["$env->{REALM}.spn"];
+
+		if ($self->setup_namespaces($env, $upn_array, $spn_array) != 0) {
+			return undef;
+		}
+
+		$env = $self->setup_trust($env, $dc_vars, "forest", "");
+	}
+
+	return $env;
+}
+
+sub setup_vampire_dc
+{
+	return setup_generic_vampire_dc(@_, "2008");
+}
+
+sub setup_vampire_2000_dc
+{
+	return setup_generic_vampire_dc(@_, "2000");
+}
+
+sub setup_generic_vampire_dc
+{
+	my ($self, $path, $dc_vars, $fl) = @_;
+
+	my $env = $self->provision_vampire_dc($path, $dc_vars, $fl);
+
+	if (defined $env) {
+	        if (not defined($self->check_or_start($env, "single"))) {
+		        return undef;
+		}
+
+		# force replicated DC to update repsTo/repsFrom
+		# for vampired partitions
+		my $samba_tool =  Samba::bindir_path($self, "samba-tool");
+
+		# as 'vampired' dc may add data in its local replica
+		# we need to synchronize data between DCs
+		my $base_dn = "DC=".join(",DC=", split(/\./, $dc_vars->{REALM}));
+		my $cmd = $self->get_cmd_env_vars($env);
+		$cmd .= " $samba_tool drs replicate $env->{DC_SERVER} $env->{SERVER}";
+		$cmd .= " $dc_vars->{CONFIGURATION}";
+		$cmd .= " -U$dc_vars->{DC_USERNAME}\%$dc_vars->{DC_PASSWORD}";
+		# replicate Configuration NC
+		my $cmd_repl = "$cmd \"CN=Configuration,$base_dn\"";
+		unless(system($cmd_repl) == 0) {
+			warn("Failed to replicate\n$cmd_repl");
+			return undef;
+		}
+		# replicate Default NC
+		$cmd_repl = "$cmd \"$base_dn\"";
+		unless(system($cmd_repl) == 0) {
+			warn("Failed to replicate\n$cmd_repl");
+			return undef;
+		}
+
+		# Pull in a full set of changes from the main DC
+		$base_dn = "DC=".join(",DC=", split(/\./, $dc_vars->{REALM}));
+		$cmd = $self->get_cmd_env_vars($env);
+		$cmd .= " $samba_tool drs replicate $env->{SERVER} $env->{DC_SERVER}";
+		$cmd .= " $dc_vars->{CONFIGURATION}";
+		$cmd .= " -U$dc_vars->{DC_USERNAME}\%$dc_vars->{DC_PASSWORD}";
+		# replicate Configuration NC
+		$cmd_repl = "$cmd \"CN=Configuration,$base_dn\"";
+		unless(system($cmd_repl) == 0) {
+			warn("Failed to replicate\n$cmd_repl");
+			return undef;
+		}
+		# replicate Default NC
+		$cmd_repl = "$cmd \"$base_dn\"";
+		unless(system($cmd_repl) == 0) {
+			warn("Failed to replicate\n$cmd_repl");
+			return undef;
+		}
+	}
+
+	return $env;
+}
+
+sub setup_promoted_dc
+{
+	my ($self, $path, $dc_vars) = @_;
+
+	my $env = $self->provision_promoted_dc($path, $dc_vars);
+
+	if (defined $env) {
+	        if (not defined($self->check_or_start($env, "single"))) {
+		        return undef;
+		}
+
+		# force source and replicated DC to update repsTo/repsFrom
+		# for vampired partitions
+		my $samba_tool =  Samba::bindir_path($self, "samba-tool");
+		my $cmd = $self->get_cmd_env_vars($env);
+		# as 'vampired' dc may add data in its local replica
+		# we need to synchronize data between DCs
+		my $base_dn = "DC=".join(",DC=", split(/\./, $dc_vars->{REALM}));
+		$cmd .= " $samba_tool drs replicate $env->{DC_SERVER} $env->{SERVER}";
+		$cmd .= " $dc_vars->{CONFIGURATION}";
+		$cmd .= " -U$dc_vars->{DC_USERNAME}\%$dc_vars->{DC_PASSWORD}";
+		# replicate Configuration NC
+		my $cmd_repl = "$cmd \"CN=Configuration,$base_dn\"";
+		unless(system($cmd_repl) == 0) {
+			warn("Failed to replicate\n$cmd_repl");
+			return undef;
+		}
+		# replicate Default NC
+		$cmd_repl = "$cmd \"$base_dn\"";
+		unless(system($cmd_repl) == 0) {
+			warn("Failed to replicate\n$cmd_repl");
+			return undef;
+		}
+	}
+
+	return $env;
+}
+
+sub setup_rodc
+{
+	my ($self, $path, $dc_vars) = @_;
+
+	my $env = $self->provision_rodc($path, $dc_vars);
+
+	unless ($env) {
+		return undef;
+	}
+
+	if (not defined($self->check_or_start($env, "standard"))) {
+	    return undef;
+	}
+
+	my $samba_tool =  Samba::bindir_path($self, "samba-tool");
+	my $cmd = $self->get_cmd_env_vars($env);
+
+	my $base_dn = "DC=".join(",DC=", split(/\./, $dc_vars->{REALM}));
+	$cmd .= " $samba_tool drs replicate $env->{SERVER} $env->{DC_SERVER}";
+	$cmd .= " $dc_vars->{CONFIGURATION}";
+	$cmd .= " -U$dc_vars->{DC_USERNAME}\%$dc_vars->{DC_PASSWORD}";
+	# replicate Configuration NC
+	my $cmd_repl = "$cmd \"CN=Configuration,$base_dn\"";
+	unless(system($cmd_repl) == 0) {
+	    warn("Failed to replicate\n$cmd_repl");
+	    return undef;
+	}
+	# replicate Default NC
+	$cmd_repl = "$cmd \"$base_dn\"";
+	unless(system($cmd_repl) == 0) {
+	    warn("Failed to replicate\n$cmd_repl");
+	    return undef;
+	}
+
+	return $env;
+}
+
+sub _setup_ad_dc
+{
+	my ($self, $path, $conf_opts, $server, $dom) = @_;
+
+	# If we didn't build with ADS, pretend this env was never available
+	if (not $self->{target3}->have_ads()) {
+	       return "UNKNOWN";
+	}
+
+	if (!defined($conf_opts)) {
+		$conf_opts = "";
+	}
+	if (!defined($server)) {
+		$server = "addc";
+	}
+	if (!defined($dom)) {
+		$dom = "addom.samba.example.com";
+	}
+	my $env = $self->provision_ad_dc($path, $server, "ADDOMAIN",
+					 $dom,
+					 undef,
+					 $conf_opts,
+					 undef);
+	unless ($env) {
+		return undef;
+	}
+
+	if (not defined($self->check_or_start($env, "prefork"))) {
+	    return undef;
+	}
+
+	my $upn_array = ["$env->{REALM}.upn"];
+	my $spn_array = ["$env->{REALM}.spn"];
+
+	if ($self->setup_namespaces($env, $upn_array, $spn_array) != 0) {
+		return undef;
+	}
+
+	return $env;
+}
+
+sub setup_ad_dc
+{
+	my ($self, $path) = @_;
+	return _setup_ad_dc($self, $path, undef, undef, undef);
+}
+
+sub setup_ad_dc_smb1
+{
+	my ($self, $path) = @_;
+	my $conf_opts = "
+[global]
+	client min protocol = CORE
+	server min protocol = LANMAN1
+
+	# needed for 'samba.tests.auth_log' tests
+	server require schannel:ADDCSMB1\$ = no
+	server schannel require seal:ADDCSMB1\$ = no
+";
+	return _setup_ad_dc($self, $path, $conf_opts, "addcsmb1", "addom2.samba.example.com");
+}
+
+sub setup_ad_dc_smb1_done
+{
+	my ($self, $path, $dep_env) = @_;
+	return $self->return_alias_env($path, $dep_env);
+}
+
+sub setup_ad_dc_no_nss
+{
+	my ($self, $path) = @_;
+
+	# If we didn't build with ADS, pretend this env was never available
+	if (not $self->{target3}->have_ads()) {
+	       return "UNKNOWN";
+	}
+
+	my $env = $self->provision_ad_dc($path,
+					 "addc_no_nss",
+					 "ADNONSSDOMAIN",
+					 "adnonssdom.samba.example.com",
+					 undef,
+					 "",
+					 undef);
+	unless ($env) {
+		return undef;
+	}
+
+	$env->{NSS_WRAPPER_MODULE_SO_PATH} = undef;
+	$env->{NSS_WRAPPER_MODULE_FN_PREFIX} = undef;
+
+	if (not defined($self->check_or_start($env, "single"))) {
+	    return undef;
+	}
+
+	my $upn_array = ["$env->{REALM}.upn"];
+	my $spn_array = ["$env->{REALM}.spn"];
+
+	if ($self->setup_namespaces($env, $upn_array, $spn_array) != 0) {
+		return undef;
+	}
+
+	return $env;
+}
+
+sub setup_ad_dc_no_ntlm
+{
+	my ($self, $path) = @_;
+
+	# If we didn't build with ADS, pretend this env was never available
+	if (not $self->{target3}->have_ads()) {
+	       return "UNKNOWN";
+	}
+
+	my $env = $self->provision_ad_dc($path,
+					 "addc_no_ntlm",
+					 "ADNONTLMDOMAIN",
+					 "adnontlmdom.samba.example.com",
+					 undef,
+					 "ntlm auth = disabled\nnt hash store = never",
+					 undef);
+	unless ($env) {
+		return undef;
+	}
+
+	if (not defined($self->check_or_start($env, "prefork"))) {
+	    return undef;
+	}
+
+	my $upn_array = ["$env->{REALM}.upn"];
+	my $spn_array = ["$env->{REALM}.spn"];
+
+	if ($self->setup_namespaces($env, $upn_array, $spn_array) != 0) {
+		return undef;
+	}
+
+	return $env;
+}
+
+sub setup_ad_dc_fips
+{
+	my ($self, $path) = @_;
+
+	# If we didn't build with ADS, pretend this env was never available
+	if (not $self->{target3}->have_ads()) {
+	       return "UNKNOWN";
+	}
+
+	my $env = $self->provision_ad_dc($path,
+					 "fipsdc",
+					 "FIPSDOMAIN",
+					 "fips.samba.example.com",
+					 1,
+					 "",
+					 undef);
+	unless ($env) {
+		return undef;
+	}
+
+	if (not defined($self->check_or_start($env, "prefork"))) {
+	    return undef;
+	}
+
+	my $upn_array = ["$env->{REALM}.upn"];
+	my $spn_array = ["$env->{REALM}.spn"];
+
+	if ($self->setup_namespaces($env, $upn_array, $spn_array) != 0) {
+		return undef;
+	}
+
+	return $env;
+}
+
+#
+# AD DC test environment used solely to test pre-fork process restarts.
+# As processes get killed off and restarted it should not be used for other
+sub setup_preforkrestartdc
+{
+	my ($self, $path) = @_;
+
+	# If we didn't build with ADS, pretend this env was never available
+	if (not $self->{target3}->have_ads()) {
+	       return "UNKNOWN";
+	}
+
+	# note DC name must be <= 15 chars so we use 'prockill' instead of
+	# 'preforkrestart'
+	my $env = $self->provision_ad_dc($path,
+					 "prockilldc",
+					 "PROCKILLDOMAIN",
+					 "prockilldom.samba.example.com",
+					 undef,
+					 "prefork backoff increment = 5\nprefork maximum backoff=10",
+					 undef);
+	unless ($env) {
+		return undef;
+	}
+
+        # We treat processes in this environment cruelly, sometimes
+        # sending them SIGSEGV signals. We don't need gdb_backtrace
+        # dissecting these fake crashes in precise detail.
+        $env->{PLEASE_NO_GDB_BACKTRACE} = '1';
+
+	$env->{NSS_WRAPPER_MODULE_SO_PATH} = undef;
+	$env->{NSS_WRAPPER_MODULE_FN_PREFIX} = undef;
+
+	if (not defined($self->check_or_start($env, "prefork"))) {
+	    return undef;
+	}
+
+	my $upn_array = ["$env->{REALM}.upn"];
+	my $spn_array = ["$env->{REALM}.spn"];
+
+	if ($self->setup_namespaces($env, $upn_array, $spn_array) != 0) {
+		return undef;
+	}
+
+	return $env;
+}
+
+#
+# ad_dc test environment used solely to test standard process model connection
+# process limits. As the limit is set artificially low it should not be used
+# for other tests.
+sub setup_proclimitdc
+{
+	my ($self, $path) = @_;
+
+	# If we didn't build with ADS, pretend this env was never available
+	if (not $self->{target3}->have_ads()) {
+	       return "UNKNOWN";
+	}
+
+	my $env = $self->provision_ad_dc($path,
+					 "proclimitdc",
+					 "PROCLIMITDOM",
+					 "proclimit.samba.example.com",
+					 undef,
+					 "max smbd processes = 20",
+					 undef);
+	unless ($env) {
+		return undef;
+	}
+
+	$env->{NSS_WRAPPER_MODULE_SO_PATH} = undef;
+	$env->{NSS_WRAPPER_MODULE_FN_PREFIX} = undef;
+
+	if (not defined($self->check_or_start($env, "standard"))) {
+	    return undef;
+	}
+
+	my $upn_array = ["$env->{REALM}.upn"];
+	my $spn_array = ["$env->{REALM}.spn"];
+
+	if ($self->setup_namespaces($env, $upn_array, $spn_array) != 0) {
+		return undef;
+	}
+
+	return $env;
+}
+
+# Used to test a live upgrade of the schema on a 2 DC network.
+sub setup_schema_dc
+{
+	my ($self, $path) = @_;
+
+	# provision the PDC using an older base schema
+	my $provision_args = ["--base-schema=2008_R2", "--backend-store=mdb"];
+
+	my $env = $self->provision_ad_dc($path,
+					 "liveupgrade1dc",
+					 "SCHEMADOMAIN",
+					 "schema.samba.example.com",
+					 undef,
+					 "drs: max link sync = 2",
+					 $provision_args);
+	unless ($env) {
+		return undef;
+	}
+
+	if (not defined($self->check_or_start($env, "prefork"))) {
+	    return undef;
+	}
+
+	my $upn_array = ["$env->{REALM}.upn"];
+	my $spn_array = ["$env->{REALM}.spn"];
+
+	if ($self->setup_namespaces($env, $upn_array, $spn_array) != 0) {
+		return undef;
+	}
+
+	return $env;
+}
+
+# the second DC in the live schema upgrade pair
+sub setup_schema_pair_dc
+{
+	# note: dcvars contains the env info for the dependent testenv ('schema_dc')
+	my ($self, $prefix, $dcvars) = @_;
+	print "Preparing SCHEMA UPGRADE PAIR DC...\n";
+
+	my ($env, $ctx) = $self->prepare_dc_testenv($prefix, "liveupgrade2dc",
+						    $dcvars->{DOMAIN},
+						    $dcvars->{REALM},
+						    $dcvars->{PASSWORD},
+						    "");
+
+	my $samba_tool =  Samba::bindir_path($self, "samba-tool");
+	my $cmd_vars = $self->get_cmd_env_vars($env);
+
+	my $join_cmd = $cmd_vars;
+	$join_cmd .= "$samba_tool domain join $env->{CONFIGURATION} $dcvars->{REALM} DC --realm=$dcvars->{REALM}";
+	$join_cmd .= " -U$dcvars->{DC_USERNAME}\%$dcvars->{DC_PASSWORD} ";
+	$join_cmd .= " --backend-store=mdb";
+
+	my $upgrade_cmd = $cmd_vars;
+	$upgrade_cmd .= "$samba_tool domain schemaupgrade $dcvars->{CONFIGURATION}";
+	$upgrade_cmd .= " -U$dcvars->{USERNAME}\%$dcvars->{PASSWORD}";
+
+	my $repl_cmd = $cmd_vars;
+	$repl_cmd .= "$samba_tool drs replicate $env->{SERVER} $dcvars->{SERVER}";
+        $repl_cmd .= " CN=Schema,CN=Configuration,DC=schema,DC=samba,DC=example,DC=com";
+	$repl_cmd .= " -U$dcvars->{DC_USERNAME}\%$dcvars->{DC_PASSWORD}";
+
+	unless (system($join_cmd) == 0) {
+		warn("Join failed\n$join_cmd");
+		return undef;
+	}
+
+	$env->{DC_SERVER} = $dcvars->{SERVER};
+	$env->{DC_SERVER_IP} = $dcvars->{SERVER_IP};
+	$env->{DC_SERVER_IPV6} = $dcvars->{SERVER_IPV6};
+	$env->{DC_NETBIOSNAME} = $dcvars->{NETBIOSNAME};
+
+	# start samba for the new DC
+	if (not defined($self->check_or_start($env, "standard"))) {
+	    return undef;
+	}
+
+	unless (system($upgrade_cmd) == 0) {
+		warn("Schema upgrade failed\n$upgrade_cmd");
+		return undef;
+	}
+
+	unless (system($repl_cmd) == 0) {
+		warn("Post-update schema replication failed\n$repl_cmd");
+		return undef;
+	}
+
+	return $env;
+}
+
+# Sets up a DC that's solely used to do a domain backup from. We then use the
+# backupfrom-DC to create the restore-DC - this proves that the backup/restore
+# process will create a Samba DC that will actually start up.
+# We don't use the backup-DC for anything else because its domain will conflict
+# with the restore DC.
+sub setup_backupfromdc
+{
+	my ($self, $path) = @_;
+
+	# If we didn't build with ADS, pretend this env was never available
+	if (not $self->{target3}->have_ads()) {
+	       return "UNKNOWN";
+	}
+
+	my $provision_args = ["--site=Backup-Site"];
+
+	my $env = $self->provision_ad_dc($path,
+					 "backupfromdc",
+					 "BACKUPDOMAIN",
+					 "backupdom.samba.example.com",
+					 undef,
+					 "samba kcc command = /bin/true",
+					 $provision_args);
+	unless ($env) {
+		return undef;
+	}
+
+	if (not defined($self->check_or_start($env))) {
+	    return undef;
+	}
+
+	my $upn_array = ["$env->{REALM}.upn"];
+	my $spn_array = ["$env->{REALM}.spn"];
+
+	if ($self->setup_namespaces($env, $upn_array, $spn_array) != 0) {
+		return undef;
+	}
+
+	# Set up a dangling forward link to an expunged object
+	#
+	# We need this to ensure that the "samba-tool domain backup rename"
+	# that is part of the creation of the labdc environment can
+	# cope with this situation on the source DC.
+
+	if (not $self->write_ldb_file("$env->{PRIVATEDIR}/sam.ldb", "
+dn: ou=linktest,dc=backupdom,dc=samba,dc=example,dc=com
+objectclass: organizationalUnit
+-
+
+dn: cn=linkto,ou=linktest,dc=backupdom,dc=samba,dc=example,dc=com
+objectclass: msExchConfigurationContainer
+-
+
+dn: cn=linkfrom,ou=linktest,dc=backupdom,dc=samba,dc=example,dc=com
+objectclass: msExchConfigurationContainer
+addressBookRoots: cn=linkto,ou=linktest,dc=backupdom,dc=samba,dc=example,dc=com
+-
+
+")) {
+	    return undef;
+	}
+	my $ldbdel = Samba::bindir_path($self, "ldbdel");
+	my $cmd = "$ldbdel -H $env->{PRIVATEDIR}/sam.ldb cn=linkto,ou=linktest,dc=backupdom,dc=samba,dc=example,dc=com";
+
+	unless(system($cmd) == 0) {
+		warn("Failed to delete link target: \n$cmd");
+		return undef;
+	}
+
+	# Expunge will ensure that linkto is totally wiped from the DB
+	my $samba_tool = Samba::bindir_path($self, "samba-tool");
+	$cmd = "$samba_tool  domain tombstones expunge --tombstone-lifetime=0 $env->{CONFIGURATION}";
+
+	unless(system($cmd) == 0) {
+		warn("Failed to expunge link target: \n$cmd");
+		return undef;
+	}
+	return $env;
+}
+
+# returns the server/user-auth params needed to run an online backup cmd
+sub get_backup_server_args
+{
+	# dcvars contains the env info for the backup DC testenv
+	my ($self, $dcvars) = @_;
+	my $server = $dcvars->{DC_SERVER_IP};
+	my $server_args = "--server=$server ";
+	$server_args .= "-U$dcvars->{DC_USERNAME}\%$dcvars->{DC_PASSWORD}";
+	$server_args .= " $dcvars->{CONFIGURATION}";
+
+	return $server_args;
+}
+
+# Creates a backup of a running testenv DC
+sub create_backup
+{
+	# note: dcvars contains the env info for the backup DC testenv
+	my ($self, $env, $dcvars, $backupdir, $backup_cmd) = @_;
+
+	# get all the env variables we pass in with the samba-tool command
+	# Note: use the backupfrom-DC's krb5.conf to do the backup
+	my $overwrite = undef;
+	$overwrite->{KRB5_CONFIG} = $dcvars->{KRB5_CONFIG};
+	my $cmd_env = $self->get_cmd_env_vars($env, $overwrite);
+
+	# use samba-tool to create a backup from the 'backupfromdc' DC
+	my $cmd = "";
+	my $samba_tool = Samba::bindir_path($self, "samba-tool");
+
+	$cmd .= "$cmd_env $samba_tool domain backup $backup_cmd";
+	$cmd .= " --targetdir=$backupdir";
+
+	print "Executing: $cmd\n";
+	unless(system($cmd) == 0) {
+		warn("Failed to create backup using: \n$cmd");
+		return undef;
+	}
+
+	# get the name of the backup file created
+	opendir(DIR, $backupdir);
+	my @files = grep(/\.tar/, readdir(DIR));
+	closedir(DIR);
+
+	if(scalar @files != 1) {
+		warn("Backup file not found in directory $backupdir\n");
+		return undef;
+	}
+	my $backup_file = "$backupdir/$files[0]";
+	print "Using backup file $backup_file...\n";
+
+	return $backup_file;
+}
+
+# Restores a backup-file to populate a testenv for a new DC
+sub restore_backup_file
+{
+	my ($self, $backup_file, $restore_opts, $restoredir, $smbconf) = @_;
+
+	# pass the restore command the testenv's smb.conf that we've already
+	# generated. But move it to a temp-dir first, so that the restore doesn't
+	# overwrite it
+	my $tmpdir = File::Temp->newdir();
+	my $tmpconf = "$tmpdir/smb.conf";
+	my $cmd = "cp $smbconf $tmpconf";
+	unless(system($cmd) == 0) {
+		warn("Failed to backup smb.conf using: \n$cmd");
+		return -1;
+	}
+
+	my $samba_tool = Samba::bindir_path($self, "samba-tool");
+	$cmd = "$samba_tool domain backup restore --backup-file=$backup_file";
+	$cmd .= " --targetdir=$restoredir $restore_opts --configfile=$tmpconf";
+
+	print "Executing: $cmd\n";
+	unless(system($cmd) == 0) {
+		warn("Failed to restore backup using: \n$cmd");
+		return -1;
+	}
+
+	print "Restore complete\n";
+	return 0
+}
+
+# sets up the initial directory and returns the new testenv's env info
+# (without actually doing a 'domain join')
+sub prepare_dc_testenv
+{
+	my ($self, $prefix, $dcname, $domain, $realm,
+		$password, $conf_options, $dnsupdate_options) = @_;
+
+	my $ctx = $self->provision_raw_prepare($prefix, "domain controller",
+					       $dcname,
+					       $domain,
+					       $realm,
+					       undef,
+					       "2008",
+					       $password,
+					       undef,
+					       undef);
+
+	# the restore uses a slightly different state-dir location to other testenvs
+	$ctx->{statedir} = "$ctx->{prefix_abs}/state";
+	push(@{$ctx->{directories}}, "$ctx->{statedir}");
+
+	# add support for sysvol/netlogon/tmp shares
+	$ctx->{share} = "$ctx->{prefix_abs}/share";
+	push(@{$ctx->{directories}}, "$ctx->{share}");
+	push(@{$ctx->{directories}}, "$ctx->{share}/test1");
+
+	if (defined($dnsupdate_options)) {
+		$ctx->{samba_dnsupdate} .= $dnsupdate_options;
+	}
+
+	$ctx->{smb_conf_extra_options} = "
+	$conf_options
+	max xmit = 32K
+	server max protocol = SMB2
+	samba kcc command = /bin/true
+	xattr_tdb:file = $ctx->{statedir}/xattr.tdb
+
+[sysvol]
+	path = $ctx->{statedir}/sysvol
+	read only = no
+
+[netlogon]
+	path = $ctx->{statedir}/sysvol/$ctx->{dnsname}/scripts
+	read only = no
+
+[tmp]
+	path = $ctx->{share}
+	read only = no
+	posix:sharedelay = 10000
+	posix:oplocktimeout = 3
+	posix:writetimeupdatedelay = 50000
+
+[test1]
+	path = $ctx->{share}/test1
+	read only = no
+	posix:sharedelay = 100000
+	posix:oplocktimeout = 3
+	posix:writetimeupdatedelay = 500000
+";
+
+	my $env = $self->provision_raw_step1($ctx);
+
+    return ($env, $ctx);
+}
+
+
+# Set up a DC testenv solely by using the samba-tool domain backup/restore
+# commands. This proves that we can backup an online DC ('backupfromdc') and
+# use the backup file to create a valid, working samba DC.
+sub setup_restoredc
+{
+	# note: dcvars contains the env info for the dependent testenv ('backupfromdc')
+	my ($self, $prefix, $dcvars) = @_;
+	print "Preparing RESTORE DC...\n";
+
+	# we arbitrarily designate the restored DC as having SMBv1 disabled
+	my $extra_conf = "
+	server min protocol = SMB2
+	client min protocol = SMB2
+	prefork children = 1";
+	my $dnsupdate_options = " --use-samba-tool --no-credentials";
+
+	my ($env, $ctx) = $self->prepare_dc_testenv($prefix, "restoredc",
+						    $dcvars->{DOMAIN},
+						    $dcvars->{REALM},
+						    $dcvars->{PASSWORD},
+						    $extra_conf,
+						    $dnsupdate_options);
+
+	# create a backup of the 'backupfromdc'
+	my $backupdir = File::Temp->newdir();
+	my $server_args = $self->get_backup_server_args($dcvars);
+	my $backup_args = "online $server_args";
+	my $backup_file = $self->create_backup($env, $dcvars, $backupdir,
+					       $backup_args);
+	unless($backup_file) {
+		return undef;
+	}
+
+	# restore the backup file to populate the restore-DC testenv
+	my $restore_dir = abs_path($prefix);
+	my $ret = $self->restore_backup_file($backup_file,
+					     "--newservername=$env->{SERVER}",
+					     $restore_dir, $env->{SERVERCONFFILE});
+	unless ($ret == 0) {
+		return undef;
+	}
+
+	#
+	# As we create a the same domain as a clone
+	# we need a separate resolv.conf!
+	#
+	$ctx->{resolv_conf} = "$ctx->{etcdir}/resolv.conf";
+	$ctx->{dns_ipv4} = $ctx->{ipv4};
+	$ctx->{dns_ipv6} = $ctx->{ipv6};
+	Samba::mk_resolv_conf($ctx);
+	$env->{RESOLV_CONF} = $ctx->{resolv_conf};
+
+	# start samba for the restored DC
+	if (not defined($self->check_or_start($env))) {
+	    return undef;
+	}
+
+	return $env;
+}
+
+# Set up a DC testenv solely by using the 'samba-tool domain backup rename' and
+# restore commands. This proves that we can backup and rename an online DC
+# ('backupfromdc') and use the backup file to create a valid, working samba DC.
+sub setup_renamedc
+{
+	# note: dcvars contains the env info for the dependent testenv ('backupfromdc')
+	my ($self, $prefix, $dcvars) = @_;
+	print "Preparing RENAME DC...\n";
+	my $extra_conf = "prefork children = 1";
+
+	my $realm = "renamedom.samba.example.com";
+	my ($env, $ctx) = $self->prepare_dc_testenv($prefix, "renamedc",
+						    "RENAMEDOMAIN", $realm,
+						    $dcvars->{PASSWORD}, $extra_conf);
+
+	# create a backup of the 'backupfromdc' which renames the domain
+	my $backupdir = File::Temp->newdir();
+	my $server_args = $self->get_backup_server_args($dcvars);
+	my $backup_args = "rename $env->{DOMAIN} $env->{REALM} $server_args";
+	$backup_args .= " --backend-store=tdb";
+	my $backup_file = $self->create_backup($env, $dcvars, $backupdir,
+					       $backup_args);
+	unless($backup_file) {
+		return undef;
+	}
+
+	# restore the backup file to populate the rename-DC testenv
+	my $restore_dir = abs_path($prefix);
+	my $restore_opts =  "--newservername=$env->{SERVER} --host-ip=$env->{SERVER_IP}";
+	my $ret = $self->restore_backup_file($backup_file, $restore_opts,
+					     $restore_dir, $env->{SERVERCONFFILE});
+	unless ($ret == 0) {
+		return undef;
+	}
+
+	# start samba for the restored DC
+	if (not defined($self->check_or_start($env))) {
+	    return undef;
+	}
+
+	my $upn_array = ["$env->{REALM}.upn"];
+	my $spn_array = ["$env->{REALM}.spn"];
+
+	if ($self->setup_namespaces($env, $upn_array, $spn_array) != 0) {
+		return undef;
+	}
+
+	return $env;
+}
+
+# Set up a DC testenv solely by using the 'samba-tool domain backup offline' and
+# restore commands. This proves that we do an offline backup of a local DC
+# ('backupfromdc') and use the backup file to create a valid, working samba DC.
+sub setup_offlinebackupdc
+{
+	# note: dcvars contains the env info for the dependent testenv ('backupfromdc')
+	my ($self, $prefix, $dcvars) = @_;
+	print "Preparing OFFLINE BACKUP DC...\n";
+	my $extra_conf = "prefork children = 1";
+	my $dnsupdate_options = " --use-samba-tool --no-credentials";
+
+	my ($env, $ctx) = $self->prepare_dc_testenv($prefix, "offlinebackupdc",
+						    $dcvars->{DOMAIN},
+						    $dcvars->{REALM},
+						    $dcvars->{PASSWORD},
+						    $extra_conf,
+						    $dnsupdate_options);
+
+	# create an offline backup of the 'backupfromdc' target
+	my $backupdir = File::Temp->newdir();
+	my $cmd = "offline --configfile $dcvars->{SERVERCONFFILE}";
+	my $backup_file = $self->create_backup($env, $dcvars,
+					       $backupdir, $cmd);
+
+	unless($backup_file) {
+		return undef;
+	}
+
+	# restore the backup file to populate the rename-DC testenv
+	my $restore_dir = abs_path($prefix);
+	my $restore_opts =  "--newservername=$env->{SERVER} --host-ip=$env->{SERVER_IP}";
+	my $ret = $self->restore_backup_file($backup_file, $restore_opts,
+					     $restore_dir, $env->{SERVERCONFFILE});
+	unless ($ret == 0) {
+		return undef;
+	}
+
+	#
+	# As we create a the same domain as a clone
+	# we need a separate resolv.conf!
+	#
+	$ctx->{resolv_conf} = "$ctx->{etcdir}/resolv.conf";
+	$ctx->{dns_ipv4} = $ctx->{ipv4};
+	$ctx->{dns_ipv6} = $ctx->{ipv6};
+	Samba::mk_resolv_conf($ctx);
+	$env->{RESOLV_CONF} = $ctx->{resolv_conf};
+
+	# re-create the testenv's krb5.conf (the restore may have overwritten it)
+	Samba::mk_krb5_conf($ctx);
+
+	# start samba for the restored DC
+	if (not defined($self->check_or_start($env))) {
+	    return undef;
+	}
+
+	return $env;
+}
+
+# Set up a DC testenv solely by using the samba-tool 'domain backup rename' and
+# restore commands, using the --no-secrets option. This proves that we can
+# create a realistic lab environment from an online DC ('backupfromdc').
+sub setup_labdc
+{
+	# note: dcvars contains the env info for the dependent testenv ('backupfromdc')
+	my ($self, $prefix, $dcvars) = @_;
+	print "Preparing LAB-DOMAIN DC...\n";
+	my $extra_conf = "prefork children = 1";
+
+	my ($env, $ctx) = $self->prepare_dc_testenv($prefix, "labdc",
+						    "LABDOMAIN",
+						    "labdom.samba.example.com",
+						    $dcvars->{PASSWORD}, $extra_conf);
+
+	# create a backup of the 'backupfromdc' which renames the domain and uses
+	# the --no-secrets option to scrub any sensitive info
+	my $backupdir = File::Temp->newdir();
+	my $server_args = $self->get_backup_server_args($dcvars);
+	my $backup_args = "rename $env->{DOMAIN} $env->{REALM} $server_args";
+	$backup_args .= " --no-secrets --backend-store=mdb";
+	my $backup_file = $self->create_backup($env, $dcvars, $backupdir,
+					       $backup_args);
+	unless($backup_file) {
+		return undef;
+	}
+
+	# restore the backup file to populate the lab-DC testenv
+	my $restore_dir = abs_path($prefix);
+	my $restore_opts =  "--newservername=$env->{SERVER} --host-ip=$env->{SERVER_IP}";
+	my $ret = $self->restore_backup_file($backup_file, $restore_opts,
+					     $restore_dir, $env->{SERVERCONFFILE});
+	unless ($ret == 0) {
+		return undef;
+	}
+
+	# because we don't include any secrets in the backup, we need to reset the
+	# admin user's password back to what the testenv expects
+	my $samba_tool = Samba::bindir_path($self, "samba-tool");
+	my $cmd = "$samba_tool user setpassword $env->{USERNAME} ";
+	$cmd .= "--newpassword=$env->{PASSWORD} -H $restore_dir/private/sam.ldb";
+	$cmd .= " $env->{CONFIGURATION}";
+
+	unless(system($cmd) == 0) {
+		warn("Failed to reset admin's password: \n$cmd");
+		return undef;
+	}
+
+	# start samba for the restored DC
+	if (not defined($self->check_or_start($env))) {
+	    return undef;
+	}
+
+	my $upn_array = ["$env->{REALM}.upn"];
+	my $spn_array = ["$env->{REALM}.spn"];
+
+	if ($self->setup_namespaces($env, $upn_array, $spn_array) != 0) {
+		return undef;
+	}
+
+	return $env;
+}
+
+# Inspects a backup *.tar.bz2 file and determines the realm/domain it contains
+sub get_backup_domain_realm
+{
+	my ($self, $backup_file) = @_;
+
+	print "Determining REALM/DOMAIN values in backup...\n";
+
+	# The backup will have the correct domain/realm values in the smb.conf.
+	# So we can work out the env variables the testenv should use based on
+	# that. Let's start by extracting the smb.conf
+	my $tar = Archive::Tar->new($backup_file);
+	my $tmpdir = File::Temp->newdir();
+	my $smbconf = "$tmpdir/smb.conf";
+
+	# note that the filepaths within the tar-file differ slightly for online
+	# and offline backups
+	if ($tar->contains_file("etc/smb.conf")) {
+		$tar->extract_file("etc/smb.conf", $smbconf);
+	} elsif ($tar->contains_file("./etc/smb.conf")) {
+		$tar->extract_file("./etc/smb.conf", $smbconf);
+	} else {
+		warn("Could not find smb.conf in $backup_file");
+		return undef, undef;
+	}
+
+	# make sure we don't try to create locks/sockets in the default install
+	# location (i.e. /usr/local/samba/)
+	my $options = "--option=\"private dir = $tmpdir\"";
+	$options .=  " --option=\"lock dir = $tmpdir\"";
+
+	# now use testparm to read the values we're interested in
+	my $testparm = Samba::bindir_path($self, "testparm");
+	my $domain = `$testparm $smbconf -sl --parameter-name=WORKGROUP $options`;
+	my $realm = `$testparm $smbconf -sl --parameter-name=REALM $options`;
+	chomp $realm;
+	chomp $domain;
+	print "Backup-file REALM is $realm, DOMAIN is $domain\n";
+
+	return ($domain, $realm);
+}
+
+# This spins up a custom testenv that can be based on any backup-file you want.
+# This is just intended for manual testing (rather than automated test-cases)
+sub setup_customdc
+{
+	my ($self, $prefix) = @_;
+	print "Preparing CUSTOM RESTORE DC...\n";
+	my $dc_name = "customdc";
+	my $password = "locDCpass1";
+	my $backup_file = $ENV{'BACKUP_FILE'};
+	my $dnsupdate_options = " --use-samba-tool --no-credentials";
+
+	# user must specify a backup file to restore via an ENV variable, i.e.
+	# BACKUP_FILE=backup-blah.tar.bz2 SELFTEST_TESTENV=customdc make testenv
+	if (not defined($backup_file)) {
+		warn("Please specify BACKUP_FILE");
+		return undef;
+	}
+
+	# work out the correct domain/realm env values from the backup-file
+	my ($domain, $realm) = $self->get_backup_domain_realm($backup_file);
+	if ($domain eq '' or $realm eq '') {
+		warn("Could not determine domain or realm");
+		return undef;
+	}
+
+	# create a placeholder directory and smb.conf, as well as the env vars.
+	my ($env, $ctx) = $self->prepare_dc_testenv($prefix, $dc_name,
+						    $domain, $realm, $password, "",
+						    $dnsupdate_options);
+
+	# restore the specified backup file to populate the testenv
+	my $restore_dir = abs_path($prefix);
+	my $ret = $self->restore_backup_file($backup_file,
+					     "--newservername=$env->{SERVER}",
+					     $restore_dir, $env->{SERVERCONFFILE});
+	unless ($ret == 0) {
+		return undef;
+	}
+
+	#
+	# As we create a the same domain as a clone
+	# we need a separate resolv.conf!
+	#
+	$ctx->{resolv_conf} = "$ctx->{etcdir}/resolv.conf";
+	$ctx->{dns_ipv4} = $ctx->{ipv4};
+	$ctx->{dns_ipv6} = $ctx->{ipv6};
+	Samba::mk_resolv_conf($ctx);
+	$env->{RESOLV_CONF} = $ctx->{resolv_conf};
+
+	# Change the admin password to the testenv default, just in case it's
+	# different, or in case this was a --no-secrets backup
+	my $samba_tool = Samba::bindir_path($self, "samba-tool");
+	my $cmd = "$samba_tool user setpassword $env->{USERNAME} ";
+	$cmd .= "--newpassword=$password -H $restore_dir/private/sam.ldb";
+	$cmd .= " $env->{CONFIGURATION}";
+
+	unless(system($cmd) == 0) {
+		warn("Failed to reset admin's password: \n$cmd");
+		return undef;
+	}
+
+	# re-create the testenv's krb5.conf (the restore may have overwritten it,
+	# if the backup-file was an offline backup)
+	Samba::mk_krb5_conf($ctx);
+
+	# start samba for the restored DC
+	if (not defined($self->check_or_start($env))) {
+	    return undef;
+	}
+
+	# if this was a backup-rename, then we may need to setup namespaces
+	my $upn_array = ["$env->{REALM}.upn"];
+	my $spn_array = ["$env->{REALM}.spn"];
+
+	if ($self->setup_namespaces($env, $upn_array, $spn_array) != 0) {
+		return undef;
+	}
+
+	return $env;
+}
+
+sub setup_none
+{
+	my ($self, $path) = @_;
+
+	my $ret = {
+		KRB5_CONFIG => abs_path($path) . "/no_krb5.conf",
+		SAMBA_PID => -1,
+	}
+}
+
+1;
diff --git a/source3/param/loadparm.c b/source3/param/loadparm.c
index 0ebdd31..5c24024 100644
--- a/source3/param/loadparm.c
+++ b/source3/param/loadparm.c
@@ -883,7 +883,7 @@ static void init_globals(struct loadparm_context *lp_ctx, bool reinit_globals)
 
 	Globals.server_services = str_list_make_v3_const(NULL, "s3fs rpc nbt wrepl ldap cldap kdc drepl winbindd ntp_signd kcc dnsupdate dns", NULL);
 
-	Globals.dcerpc_endpoint_servers = str_list_make_v3_const(NULL, "epmapper wkssvc rpcecho samr netlogon lsarpc drsuapi dssetup unixinfo browser eventlog6 backupkey dnsserver", NULL);
+	Globals.dcerpc_endpoint_servers = str_list_make_v3_const(NULL, "epmapper wkssvc samr netlogon lsarpc drsuapi dssetup unixinfo browser eventlog6 backupkey dnsserver", NULL);
 
 	Globals.tls_enabled = true;
 	Globals.tls_verify_peer = TLS_VERIFY_PEER_AS_STRICT_AS_POSSIBLE;
diff --git a/source3/param/loadparm.c.orig b/source3/param/loadparm.c.orig
new file mode 100644
index 0000000..0ebdd31
--- /dev/null
+++ b/source3/param/loadparm.c.orig
@@ -0,0 +1,4837 @@
+/*
+   Unix SMB/CIFS implementation.
+   Parameter loading functions
+   Copyright (C) Karl Auer 1993-1998
+
+   Largely re-written by Andrew Tridgell, September 1994
+
+   Copyright (C) Simo Sorce 2001
+   Copyright (C) Alexander Bokovoy 2002
+   Copyright (C) Stefan (metze) Metzmacher 2002
+   Copyright (C) Jim McDonough <jmcd@us.ibm.com> 2003
+   Copyright (C) Michael Adam 2008
+   Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007
+   Copyright (C) Andrew Bartlett 2011
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*
+ *  Load parameters.
+ *
+ *  This module provides suitable callback functions for the params
+ *  module. It builds the internal table of service details which is
+ *  then used by the rest of the server.
+ *
+ * To add a parameter:
+ *
+ * 1) add it to the global or service structure definition
+ * 2) add it to the parm_table
+ * 3) add it to the list of available functions (eg: using FN_GLOBAL_STRING())
+ * 4) If it's a global then initialise it in init_globals. If a local
+ *    (ie. service) parameter then initialise it in the sDefault structure
+ *
+ *
+ * Notes:
+ *   The configuration file is processed sequentially for speed. It is NOT
+ *   accessed randomly as happens in 'real' Windows. For this reason, there
+ *   is a fair bit of sequence-dependent code here - ie., code which assumes
+ *   that certain things happen before others. In particular, the code which
+ *   happens at the boundary between sections is delicately poised, so be
+ *   careful!
+ *
+ */
+
+#define LOADPARM_SUBSTITUTION_INTERNALS 1
+#include "includes.h"
+#include "system/filesys.h"
+#include "util_tdb.h"
+#include "lib/param/loadparm.h"
+#include "lib/param/param.h"
+#include "printing.h"
+#include "lib/smbconf/smbconf.h"
+#include "lib/smbconf/smbconf_init.h"
+
+#include "include/smb_ldap.h"
+#include "../librpc/gen_ndr/svcctl.h"
+#include "intl.h"
+#include "../libcli/smb/smb_signing.h"
+#include "dbwrap/dbwrap.h"
+#include "dbwrap/dbwrap_rbt.h"
+#include "../lib/util/bitmap.h"
+#include "librpc/gen_ndr/nbt.h"
+#include "librpc/gen_ndr/dns.h"
+#include "source4/lib/tls/tls.h"
+#include "libcli/auth/ntlm_check.h"
+#include "lib/crypto/gnutls_helpers.h"
+#include "lib/util/string_wrappers.h"
+#include "auth/credentials/credentials.h"
+#include "source3/lib/substitute.h"
+
+#ifdef HAVE_SYS_SYSCTL_H
+#include <sys/sysctl.h>
+#endif
+
+bool bLoaded = false;
+
+extern userdom_struct current_user_info;
+
+/* the special value for the include parameter
+ * to be interpreted not as a file name but to
+ * trigger loading of the global smb.conf options
+ * from registry. */
+#ifndef INCLUDE_REGISTRY_NAME
+#define INCLUDE_REGISTRY_NAME "registry"
+#endif
+
+static bool in_client = false;		/* Not in the client by default */
+static struct smbconf_csn conf_last_csn;
+
+static int config_backend = CONFIG_BACKEND_FILE;
+
+/* some helpful bits */
+#define LP_SNUM_OK(i) (((i) >= 0) && ((i) < iNumServices) && \
+                       (ServicePtrs != NULL) && \
+		       (ServicePtrs[(i)] != NULL) && ServicePtrs[(i)]->valid)
+#define VALID(i) ((ServicePtrs != NULL) && (ServicePtrs[i]!= NULL) && \
+                  ServicePtrs[i]->valid)
+
+#define USERSHARE_VALID 1
+#define USERSHARE_PENDING_DELETE 2
+
+static bool defaults_saved = false;
+
+#include "lib/param/param_global.h"
+
+static struct loadparm_global Globals;
+
+/* This is a default service used to prime a services structure */
+static const struct loadparm_service _sDefault =
+{
+	.valid = true,
+	.autoloaded = false,
+	.usershare = 0,
+	.usershare_last_mod = {0, 0},
+	.szService = NULL,
+	.path = NULL,
+	.invalid_users = NULL,
+	.valid_users = NULL,
+	.admin_users = NULL,
+	.copy = NULL,
+	.include = NULL,
+	.preexec = NULL,
+	.postexec = NULL,
+	.root_preexec = NULL,
+	.root_postexec = NULL,
+	.cups_options = NULL,
+	.print_command = NULL,
+	.lpq_command = NULL,
+	.lprm_command = NULL,
+	.lppause_command = NULL,
+	.lpresume_command = NULL,
+	.queuepause_command = NULL,
+	.queueresume_command = NULL,
+	._printername = NULL,
+	.printjob_username = NULL,
+	.dont_descend = NULL,
+	.hosts_allow = NULL,
+	.hosts_deny = NULL,
+	.magic_script = NULL,
+	.magic_output = NULL,
+	.veto_files = NULL,
+	.hide_files = NULL,
+	.veto_oplock_files = NULL,
+	.comment = NULL,
+	.force_user = NULL,
+	.force_group = NULL,
+	.read_list = NULL,
+	.write_list = NULL,
+	.volume = NULL,
+	.fstype = NULL,
+	.vfs_objects = NULL,
+	.msdfs_proxy = NULL,
+	.aio_write_behind = NULL,
+	.dfree_command = NULL,
+	.min_print_space = 0,
+	.max_print_jobs = 1000,
+	.max_reported_print_jobs = 0,
+	.create_mask = 0744,
+	.force_create_mode = 0,
+	.directory_mask = 0755,
+	.force_directory_mode = 0,
+	.max_connections = 0,
+	.default_case = CASE_LOWER,
+	.printing = DEFAULT_PRINTING,
+	.csc_policy = 0,
+	.block_size = 1024,
+	.dfree_cache_time = 0,
+	.preexec_close = false,
+	.root_preexec_close = false,
+	.case_sensitive = Auto,
+	.preserve_case = true,
+	.short_preserve_case = true,
+	.hide_dot_files = true,
+	.hide_special_files = false,
+	.hide_unreadable = false,
+	.hide_unwriteable_files = false,
+	.browseable = true,
+	.access_based_share_enum = false,
+	.available = true,
+	.read_only = true,
+	.spotlight = false,
+	.guest_only = false,
+	.administrative_share = false,
+	.guest_ok = false,
+	.printable = false,
+	.print_notify_backchannel = false,
+	.map_system = false,
+	.map_hidden = false,
+	.map_archive = true,
+	.store_dos_attributes = true,
+	.smbd_max_xattr_size = 65536,
+	.dmapi_support = false,
+	.locking = true,
+	.strict_locking = Auto,
+	.posix_locking = true,
+	.oplocks = true,
+	.kernel_oplocks = false,
+	.level2_oplocks = true,
+	.mangled_names = MANGLED_NAMES_ILLEGAL,
+	.wide_links = false,
+	.follow_symlinks = true,
+	.sync_always = false,
+	.strict_allocate = false,
+	.strict_rename = false,
+	.strict_sync = true,
+	.mangling_char = '~',
+	.copymap = NULL,
+	.delete_readonly = false,
+	.fake_oplocks = false,
+	.delete_veto_files = false,
+	.dos_filemode = false,
+	.dos_filetimes = true,
+	.dos_filetime_resolution = false,
+	.fake_directory_create_times = false,
+	.blocking_locks = true,
+	.inherit_permissions = false,
+	.inherit_acls = false,
+	.inherit_owner = false,
+	.msdfs_root = false,
+	.msdfs_shuffle_referrals = false,
+	.use_client_driver = false,
+	.default_devmode = true,
+	.force_printername = false,
+	.nt_acl_support = true,
+	.force_unknown_acl_user = false,
+	._use_sendfile = false,
+	.map_acl_inherit = false,
+	.afs_share = false,
+	.ea_support = true,
+	.acl_check_permissions = true,
+	.acl_map_full_control = true,
+	.acl_group_control = false,
+	.acl_allow_execute_always = false,
+	.acl_flag_inherited_canonicalization = true,
+	.aio_read_size = 1,
+	.aio_write_size = 1,
+	.map_readonly = MAP_READONLY_NO,
+	.directory_name_cache_size = 100,
+	.server_smb_encrypt = SMB_ENCRYPTION_DEFAULT,
+	.kernel_share_modes = false,
+	.durable_handles = true,
+	.check_parent_directory_delete_on_close = false,
+	.param_opt = NULL,
+	.smbd_search_ask_sharemode = true,
+	.smbd_getinfo_ask_sharemode = true,
+	.spotlight_backend = SPOTLIGHT_BACKEND_NOINDEX,
+	.honor_change_notify_privilege = false,
+	.volume_serial_number = -1,
+	.dummy = ""
+};
+
+/*
+ * This is a copy of the default service structure. Service options in the
+ * global section would otherwise overwrite the initial default values.
+ */
+static struct loadparm_service sDefault;
+
+/* local variables */
+static struct loadparm_service **ServicePtrs = NULL;
+static int iNumServices = 0;
+static int iServiceIndex = 0;
+static struct db_context *ServiceHash;
+static bool bInGlobalSection = true;
+static bool bGlobalOnly = false;
+static struct file_lists *file_lists = NULL;
+static unsigned int *flags_list = NULL;
+
+static void set_allowed_client_auth(void);
+
+static bool lp_set_cmdline_helper(const char *pszParmName, const char *pszParmValue);
+static void free_param_opts(struct parmlist_entry **popts);
+
+/**
+ *  Function to return the default value for the maximum number of open
+ *  file descriptors permitted.  This function tries to consult the
+ *  kernel-level (sysctl) and ulimit (getrlimit()) values and goes
+ *  the smaller of those.
+ */
+static int max_open_files(void)
+{
+	int sysctl_max = MAX_OPEN_FILES;
+	int rlimit_max = MAX_OPEN_FILES;
+
+#ifdef HAVE_SYSCTLBYNAME
+	{
+		size_t size = sizeof(sysctl_max);
+		sysctlbyname("kern.maxfilesperproc", &sysctl_max, &size, NULL,
+			     0);
+	}
+#endif
+
+#if (defined(HAVE_GETRLIMIT) && defined(RLIMIT_NOFILE))
+	{
+		struct rlimit rl;
+
+		ZERO_STRUCT(rl);
+
+		if (getrlimit(RLIMIT_NOFILE, &rl) == 0)
+			rlimit_max = rl.rlim_cur;
+
+#if defined(RLIM_INFINITY)
+		if(rl.rlim_cur == RLIM_INFINITY)
+			rlimit_max = MAX_OPEN_FILES;
+#endif
+	}
+#endif
+
+	if (sysctl_max < MIN_OPEN_FILES_WINDOWS) {
+		DEBUG(2,("max_open_files: increasing sysctl_max (%d) to "
+			"minimum Windows limit (%d)\n",
+			sysctl_max,
+			MIN_OPEN_FILES_WINDOWS));
+		sysctl_max = MIN_OPEN_FILES_WINDOWS;
+	}
+
+	if (rlimit_max < MIN_OPEN_FILES_WINDOWS) {
+		DEBUG(2,("rlimit_max: increasing rlimit_max (%d) to "
+			"minimum Windows limit (%d)\n",
+			rlimit_max,
+			MIN_OPEN_FILES_WINDOWS));
+		rlimit_max = MIN_OPEN_FILES_WINDOWS;
+	}
+
+	return MIN(sysctl_max, rlimit_max);
+}
+
+/**
+ * Common part of freeing allocated data for one parameter.
+ */
+static void free_one_parameter_common(void *parm_ptr,
+				      struct parm_struct parm)
+{
+	if ((parm.type == P_STRING) ||
+	    (parm.type == P_USTRING))
+	{
+		lpcfg_string_free((char**)parm_ptr);
+	} else if (parm.type == P_LIST || parm.type == P_CMDLIST) {
+		TALLOC_FREE(*((char***)parm_ptr));
+	}
+}
+
+/**
+ * Free the allocated data for one parameter for a share
+ * given as a service struct.
+ */
+static void free_one_parameter(struct loadparm_service *service,
+			       struct parm_struct parm)
+{
+	void *parm_ptr;
+
+	if (parm.p_class != P_LOCAL) {
+		return;
+	}
+
+	parm_ptr = lp_parm_ptr(service, &parm);
+
+	free_one_parameter_common(parm_ptr, parm);
+}
+
+/**
+ * Free the allocated parameter data of a share given
+ * as a service struct.
+ */
+static void free_parameters(struct loadparm_service *service)
+{
+	uint32_t i;
+
+	for (i=0; parm_table[i].label; i++) {
+		free_one_parameter(service, parm_table[i]);
+	}
+}
+
+/**
+ * Free the allocated data for one parameter for a given share
+ * specified by an snum.
+ */
+static void free_one_parameter_by_snum(int snum, struct parm_struct parm)
+{
+	void *parm_ptr;
+
+	if (snum < 0) {
+		parm_ptr = lp_parm_ptr(NULL, &parm);
+	} else if (parm.p_class != P_LOCAL) {
+		return;
+	} else {
+		parm_ptr = lp_parm_ptr(ServicePtrs[snum], &parm);
+	}
+
+	free_one_parameter_common(parm_ptr, parm);
+}
+
+/**
+ * Free the allocated parameter data for a share specified
+ * by an snum.
+ */
+static void free_parameters_by_snum(int snum)
+{
+	uint32_t i;
+
+	for (i=0; parm_table[i].label; i++) {
+		free_one_parameter_by_snum(snum, parm_table[i]);
+	}
+}
+
+/**
+ * Free the allocated global parameters.
+ */
+static void free_global_parameters(void)
+{
+	uint32_t i;
+	struct parm_struct *parm;
+
+	free_param_opts(&Globals.param_opt);
+	free_parameters_by_snum(GLOBAL_SECTION_SNUM);
+
+	/* Reset references in the defaults because the context is going to be freed */
+	for (i=0; parm_table[i].label; i++) {
+		parm = &parm_table[i];
+		if ((parm->type == P_STRING) ||
+		    (parm->type == P_USTRING)) {
+			if ((parm->def.svalue != NULL) &&
+			    (*(parm->def.svalue) != '\0')) {
+				if (talloc_parent(parm->def.svalue) == Globals.ctx) {
+					parm->def.svalue = NULL;
+				}
+			}
+		}
+	}
+	TALLOC_FREE(Globals.ctx);
+}
+
+struct lp_stored_option {
+	struct lp_stored_option *prev, *next;
+	const char *label;
+	const char *value;
+};
+
+static struct lp_stored_option *stored_options;
+
+/*
+  save options set by lp_set_cmdline() into a list. This list is
+  re-applied when we do a globals reset, so that cmdline set options
+  are sticky across reloads of smb.conf
+ */
+bool store_lp_set_cmdline(const char *pszParmName, const char *pszParmValue)
+{
+	struct lp_stored_option *entry, *entry_next;
+	for (entry = stored_options; entry != NULL; entry = entry_next) {
+		entry_next = entry->next;
+		if (strcmp(pszParmName, entry->label) == 0) {
+			DLIST_REMOVE(stored_options, entry);
+			talloc_free(entry);
+			break;
+		}
+	}
+
+	entry = talloc(NULL, struct lp_stored_option);
+	if (!entry) {
+		return false;
+	}
+
+	entry->label = talloc_strdup(entry, pszParmName);
+	if (!entry->label) {
+		talloc_free(entry);
+		return false;
+	}
+
+	entry->value = talloc_strdup(entry, pszParmValue);
+	if (!entry->value) {
+		talloc_free(entry);
+		return false;
+	}
+
+	DLIST_ADD_END(stored_options, entry);
+
+	return true;
+}
+
+static bool apply_lp_set_cmdline(void)
+{
+	struct lp_stored_option *entry = NULL;
+	for (entry = stored_options; entry != NULL; entry = entry->next) {
+		if (!lp_set_cmdline_helper(entry->label, entry->value)) {
+			DEBUG(0, ("Failed to re-apply cmdline parameter %s = %s\n",
+				  entry->label, entry->value));
+			return false;
+		}
+	}
+	return true;
+}
+
+/***************************************************************************
+ Initialise the global parameter structure.
+***************************************************************************/
+
+static void init_globals(struct loadparm_context *lp_ctx, bool reinit_globals)
+{
+	static bool done_init = false;
+	char *s = NULL;
+	int i;
+
+        /* If requested to initialize only once and we've already done it... */
+        if (!reinit_globals && done_init) {
+                /* ... then we have nothing more to do */
+                return;
+        }
+
+	if (!done_init) {
+		/* The logfile can be set before this is invoked. Free it if so. */
+		lpcfg_string_free(&Globals.logfile);
+		done_init = true;
+	} else {
+		free_global_parameters();
+	}
+
+	/* This memset and the free_global_parameters() above will
+	 * wipe out smb.conf options set with lp_set_cmdline().  The
+	 * apply_lp_set_cmdline() call puts these values back in the
+	 * table once the defaults are set */
+	ZERO_STRUCT(Globals);
+
+	Globals.ctx = talloc_pooled_object(NULL, char, 272, 2048);
+
+	/* Initialize the flags list if necessary */
+	if (flags_list == NULL) {
+		get_flags();
+	}
+
+	for (i = 0; parm_table[i].label; i++) {
+		if ((parm_table[i].type == P_STRING ||
+		     parm_table[i].type == P_USTRING))
+		{
+			lpcfg_string_set(
+				Globals.ctx,
+				(char **)lp_parm_ptr(NULL, &parm_table[i]),
+				"");
+		}
+	}
+
+
+	lpcfg_string_set(Globals.ctx, &sDefault.fstype, FSTYPE_STRING);
+	lpcfg_string_set(Globals.ctx, &sDefault.printjob_username, "%U");
+
+	init_printer_values(lp_ctx, Globals.ctx, &sDefault);
+
+	sDefault.ntvfs_handler = str_list_make_v3_const(Globals.ctx, "unixuid default", NULL);
+
+	DEBUG(3, ("Initialising global parameters\n"));
+
+	/* Must manually force to upper case here, as this does not go via the handler */
+	lpcfg_string_set(Globals.ctx, &Globals.netbios_name,
+			 myhostname_upper());
+
+	lpcfg_string_set(Globals.ctx, &Globals.smb_passwd_file,
+			 get_dyn_SMB_PASSWD_FILE());
+	lpcfg_string_set(Globals.ctx, &Globals.private_dir,
+			 get_dyn_PRIVATE_DIR());
+	lpcfg_string_set(Globals.ctx, &Globals.binddns_dir,
+			 get_dyn_BINDDNS_DIR());
+
+	/* use the new 'hash2' method by default, with a prefix of 1 */
+	lpcfg_string_set(Globals.ctx, &Globals.mangling_method, "hash2");
+	Globals.mangle_prefix = 1;
+
+	lpcfg_string_set(Globals.ctx, &Globals.guest_account, GUEST_ACCOUNT);
+
+	/* using UTF8 by default allows us to support all chars */
+	lpcfg_string_set(Globals.ctx, &Globals.unix_charset,
+			 DEFAULT_UNIX_CHARSET);
+
+	/* Use codepage 850 as a default for the dos character set */
+	lpcfg_string_set(Globals.ctx, &Globals.dos_charset,
+			 DEFAULT_DOS_CHARSET);
+
+	/*
+	 * Allow the default PASSWD_CHAT to be overridden in local.h.
+	 */
+	lpcfg_string_set(Globals.ctx, &Globals.passwd_chat,
+			 DEFAULT_PASSWD_CHAT);
+
+	lpcfg_string_set(Globals.ctx, &Globals.workgroup, DEFAULT_WORKGROUP);
+
+	lpcfg_string_set(Globals.ctx, &Globals.passwd_program, "");
+	lpcfg_string_set(Globals.ctx, &Globals.lock_directory,
+			 get_dyn_LOCKDIR());
+	lpcfg_string_set(Globals.ctx, &Globals.state_directory,
+			 get_dyn_STATEDIR());
+	lpcfg_string_set(Globals.ctx, &Globals.cache_directory,
+			 get_dyn_CACHEDIR());
+	lpcfg_string_set(Globals.ctx, &Globals.pid_directory,
+			 get_dyn_PIDDIR());
+	lpcfg_string_set(Globals.ctx, &Globals.nbt_client_socket_address,
+			 "0.0.0.0");
+	/*
+	 * By default support explicit binding to broadcast
+ 	 * addresses.
+ 	 */
+	Globals.nmbd_bind_explicit_broadcast = true;
+
+	s = talloc_asprintf(talloc_tos(), "Samba %s", samba_version_string());
+	if (s == NULL) {
+		smb_panic("init_globals: ENOMEM");
+	}
+	lpcfg_string_set(Globals.ctx, &Globals.server_string, s);
+	TALLOC_FREE(s);
+#ifdef DEVELOPER
+	lpcfg_string_set(Globals.ctx, &Globals.panic_action,
+			 "/bin/sleep 999999999");
+#endif
+
+	lpcfg_string_set(Globals.ctx, &Globals.socket_options,
+			 DEFAULT_SOCKET_OPTIONS);
+
+	lpcfg_string_set(Globals.ctx, &Globals.logon_drive, "");
+	/* %N is the NIS auto.home server if -DAUTOHOME is used, else same as %L */
+	lpcfg_string_set(Globals.ctx, &Globals.logon_home, "\\\\%N\\%U");
+	lpcfg_string_set(Globals.ctx, &Globals.logon_path,
+			 "\\\\%N\\%U\\profile");
+
+	Globals.name_resolve_order =
+			str_list_make_v3_const(Globals.ctx,
+					       DEFAULT_NAME_RESOLVE_ORDER,
+					       NULL);
+	lpcfg_string_set(Globals.ctx, &Globals.password_server, "*");
+
+	Globals.algorithmic_rid_base = BASE_RID;
+
+	Globals.load_printers = true;
+	Globals.printcap_cache_time = 750; 	/* 12.5 minutes */
+
+	Globals.config_backend = config_backend;
+	Globals._server_role = ROLE_AUTO;
+
+	/* Was 65535 (0xFFFF). 0x4101 matches W2K and causes major speed improvements... */
+	/* Discovered by 2 days of pain by Don McCall @ HP :-). */
+	Globals.max_xmit = 0x4104;
+	Globals.max_mux = 50;	/* This is *needed* for profile support. */
+	Globals.lpq_cache_time = 30;	/* changed to handle large print servers better -- jerry */
+	Globals._disable_spoolss = false;
+	Globals.max_smbd_processes = 0;/* no limit specified */
+	Globals.username_level = 0;
+	Globals.deadtime = 10080;
+	Globals.getwd_cache = true;
+	Globals.large_readwrite = true;
+	Globals.max_log_size = 5000;
+	Globals.max_open_files = max_open_files();
+	Globals.server_max_protocol = PROTOCOL_SMB3_11;
+	Globals.server_min_protocol = PROTOCOL_SMB2_02;
+	Globals._client_max_protocol = PROTOCOL_DEFAULT;
+	Globals.client_min_protocol = PROTOCOL_SMB2_02;
+	Globals._client_ipc_max_protocol = PROTOCOL_DEFAULT;
+	Globals._client_ipc_min_protocol = PROTOCOL_DEFAULT;
+	Globals._security = SEC_AUTO;
+	Globals.encrypt_passwords = true;
+	Globals.client_schannel = true;
+	Globals.winbind_sealed_pipes = true;
+	Globals.require_strong_key = true;
+	Globals.reject_md5_servers = true;
+	Globals.server_schannel = true;
+	Globals.server_schannel_require_seal = true;
+	Globals.reject_md5_clients = true;
+	Globals.read_raw = true;
+	Globals.write_raw = true;
+	Globals.null_passwords = false;
+	Globals.old_password_allowed_period = 60;
+	Globals.obey_pam_restrictions = false;
+	Globals.syslog = 1;
+	Globals.syslog_only = false;
+	Globals.timestamp_logs = true;
+	lpcfg_string_set(Globals.ctx, &Globals.log_level, "0");
+	Globals.debug_prefix_timestamp = false;
+	Globals.debug_hires_timestamp = true;
+	Globals.debug_syslog_format = false;
+	Globals.debug_pid = false;
+	Globals.debug_uid = false;
+	Globals.debug_class = false;
+	Globals.enable_core_files = true;
+	Globals.max_ttl = 60 * 60 * 24 * 3;	/* 3 days default. */
+	Globals.max_wins_ttl = 60 * 60 * 24 * 6;	/* 6 days default. */
+	Globals.min_wins_ttl = 60 * 60 * 6;	/* 6 hours default. */
+	Globals.machine_password_timeout = 60 * 60 * 24 * 7;	/* 7 days default. */
+	Globals.lm_announce = Auto;	/* = Auto: send only if LM clients found */
+	Globals.lm_interval = 60;
+	Globals.time_server = false;
+	Globals.bind_interfaces_only = false;
+	Globals.unix_password_sync = false;
+	Globals.pam_password_change = false;
+	Globals.passwd_chat_debug = false;
+	Globals.passwd_chat_timeout = 2; /* 2 second default. */
+	Globals.nt_pipe_support = true;	/* Do NT pipes by default. */
+	Globals.nt_status_support = true; /* Use NT status by default. */
+	Globals.smbd_profiling_level = 0;
+	Globals.stat_cache = true;	/* use stat cache by default */
+	Globals.max_stat_cache_size = 512; /* 512k by default */
+	Globals.restrict_anonymous = 0;
+	Globals.client_lanman_auth = false;	/* Do NOT use the LanMan hash if it is available */
+	Globals.client_plaintext_auth = false;	/* Do NOT use a plaintext password even if is requested by the server */
+	Globals._lanman_auth = false;	/* Do NOT use the LanMan hash, even if it is supplied */
+	Globals.ntlm_auth = NTLM_AUTH_NTLMV2_ONLY;	/* Do NOT use NTLMv1 if it is supplied by the client (otherwise NTLMv2) */
+	Globals.nt_hash_store = NT_HASH_STORE_ALWAYS;	/* Fill in NT hash when setting password */
+	Globals.raw_ntlmv2_auth = false; /* Reject NTLMv2 without NTLMSSP */
+	Globals.client_ntlmv2_auth = true; /* Client should always use use NTLMv2, as we can't tell that the server supports it, but most modern servers do */
+	/* Note, that we will also use NTLM2 session security (which is different), if it is available */
+
+	Globals.allow_dcerpc_auth_level_connect = false; /* we don't allow this by default */
+
+	Globals.map_to_guest = 0;	/* By Default, "Never" */
+	Globals.oplock_break_wait_time = 0;	/* By Default, 0 msecs. */
+	Globals.enhanced_browsing = true;
+	Globals.lock_spin_time = WINDOWS_MINIMUM_LOCK_TIMEOUT_MS; /* msec. */
+	Globals.use_mmap = true;
+	Globals.unicode = true;
+	Globals.smb1_unix_extensions = true;
+	Globals.reset_on_zero_vc = false;
+	Globals.log_writeable_files_on_exit = false;
+	Globals.create_krb5_conf = true;
+	Globals.include_system_krb5_conf = true;
+	Globals._winbind_max_domain_connections = 1;
+
+	/* hostname lookups can be very expensive and are broken on
+	   a large number of sites (tridge) */
+	Globals.hostname_lookups = false;
+
+	Globals.change_notify = true,
+	Globals.kernel_change_notify = true,
+
+	lpcfg_string_set(Globals.ctx, &Globals.passdb_backend, "tdbsam");
+	lpcfg_string_set(Globals.ctx, &Globals.ldap_suffix, "");
+	lpcfg_string_set(Globals.ctx, &Globals._ldap_machine_suffix, "");
+	lpcfg_string_set(Globals.ctx, &Globals._ldap_user_suffix, "");
+	lpcfg_string_set(Globals.ctx, &Globals._ldap_group_suffix, "");
+	lpcfg_string_set(Globals.ctx, &Globals._ldap_idmap_suffix, "");
+
+	lpcfg_string_set(Globals.ctx, &Globals.ldap_admin_dn, "");
+	Globals.ldap_ssl = LDAP_SSL_START_TLS;
+	Globals.ldap_deref = -1;
+	Globals.ldap_passwd_sync = LDAP_PASSWD_SYNC_OFF;
+	Globals.ldap_delete_dn = false;
+	Globals.ldap_replication_sleep = 1000; /* wait 1 sec for replication */
+	Globals.ldap_follow_referral = Auto;
+	Globals.ldap_timeout = LDAP_DEFAULT_TIMEOUT;
+	Globals.ldap_connection_timeout = LDAP_CONNECTION_DEFAULT_TIMEOUT;
+	Globals.ldap_page_size = LDAP_PAGE_SIZE;
+
+	Globals.ldap_debug_level = 0;
+	Globals.ldap_debug_threshold = 10;
+
+	Globals.client_ldap_sasl_wrapping = ADS_AUTH_SASL_SIGN;
+
+	Globals.ldap_server_require_strong_auth =
+		LDAP_SERVER_REQUIRE_STRONG_AUTH_YES;
+
+	/* This is what we tell the afs client. in reality we set the token
+	 * to never expire, though, when this runs out the afs client will
+	 * forget the token. Set to 0 to get NEVERDATE.*/
+	Globals.afs_token_lifetime = 604800;
+	Globals.cups_connection_timeout = CUPS_DEFAULT_CONNECTION_TIMEOUT;
+
+/* these parameters are set to defaults that are more appropriate
+   for the increasing samba install base:
+
+   as a member of the workgroup, that will possibly become a
+   _local_ master browser (lm = true).  this is opposed to a forced
+   local master browser startup (pm = true).
+
+   doesn't provide WINS server service by default (wsupp = false),
+   and doesn't provide domain master browser services by default, either.
+
+*/
+
+	Globals.show_add_printer_wizard = true;
+	Globals.os_level = 20;
+	Globals.local_master = true;
+	Globals._domain_master = Auto;	/* depending on _domain_logons */
+	Globals._domain_logons = false;
+	Globals.browse_list = true;
+	Globals.we_are_a_wins_server = false;
+	Globals.wins_proxy = false;
+
+	TALLOC_FREE(Globals.init_logon_delayed_hosts);
+	Globals.init_logon_delay = 100; /* 100 ms default delay */
+
+	Globals.wins_dns_proxy = true;
+	Globals.dns_port = DNS_SERVICE_PORT;
+
+	Globals.allow_trusted_domains = true;
+	lpcfg_string_set(Globals.ctx, &Globals.idmap_backend, "tdb");
+
+	lpcfg_string_set(Globals.ctx, &Globals.template_shell, "/bin/false");
+	lpcfg_string_set(Globals.ctx, &Globals.template_homedir,
+			 "/home/%D/%U");
+	lpcfg_string_set(Globals.ctx, &Globals.winbind_separator, "\\");
+	lpcfg_string_set(Globals.ctx, &Globals.winbindd_socket_directory,
+			 dyn_WINBINDD_SOCKET_DIR);
+
+	lpcfg_string_set(Globals.ctx, &Globals.cups_server, "");
+	lpcfg_string_set(Globals.ctx, &Globals.iprint_server, "");
+
+	lpcfg_string_set(Globals.ctx, &Globals._ctdbd_socket, "");
+
+	Globals.cluster_addresses = NULL;
+	Globals.clustering = false;
+	Globals.ctdb_timeout = 0;
+	Globals.ctdb_locktime_warn_threshold = 0;
+
+	Globals.winbind_cache_time = 300;	/* 5 minutes */
+	Globals.winbind_reconnect_delay = 30;	/* 30 seconds */
+	Globals.winbind_request_timeout = 60;   /* 60 seconds */
+	Globals.winbind_max_clients = 200;
+	Globals.winbind_enum_users = false;
+	Globals.winbind_enum_groups = false;
+	Globals.winbind_use_default_domain = false;
+	Globals.winbind_nested_groups = true;
+	Globals.winbind_expand_groups = 0;
+	Globals.winbind_nss_info = str_list_make_v3_const(NULL, "template", NULL);
+	Globals.winbind_refresh_tickets = false;
+	Globals.winbind_offline_logon = false;
+	Globals.winbind_scan_trusted_domains = false;
+
+	Globals.idmap_cache_time = 86400 * 7; /* a week by default */
+	Globals.idmap_negative_cache_time = 120; /* 2 minutes by default */
+
+	Globals.passdb_expand_explicit = false;
+
+	Globals.name_cache_timeout = 660; /* In seconds */
+
+	Globals.client_use_spnego = true;
+
+	Globals.client_signing = SMB_SIGNING_DEFAULT;
+	Globals._client_ipc_signing = SMB_SIGNING_DEFAULT;
+	Globals.server_signing = SMB_SIGNING_DEFAULT;
+
+	Globals.defer_sharing_violations = true;
+	Globals.smb_ports = str_list_make_v3_const(NULL, SMB_PORTS, NULL);
+
+	Globals.enable_privileges = true;
+	Globals.host_msdfs        = true;
+	Globals.enable_asu_support       = false;
+
+	/* User defined shares. */
+	s = talloc_asprintf(talloc_tos(), "%s/usershares", get_dyn_STATEDIR());
+	if (s == NULL) {
+		smb_panic("init_globals: ENOMEM");
+	}
+	lpcfg_string_set(Globals.ctx, &Globals.usershare_path, s);
+	TALLOC_FREE(s);
+	lpcfg_string_set(Globals.ctx, &Globals.usershare_template_share, "");
+	Globals.usershare_max_shares = 0;
+	/* By default disallow sharing of directories not owned by the sharer. */
+	Globals.usershare_owner_only = true;
+	/* By default disallow guest access to usershares. */
+	Globals.usershare_allow_guests = false;
+
+	Globals.keepalive = DEFAULT_KEEPALIVE;
+
+	/* By default no shares out of the registry */
+	Globals.registry_shares = false;
+
+	Globals.min_receivefile_size = 0;
+
+	Globals.multicast_dns_register = true;
+
+	Globals.smb2_max_read = DEFAULT_SMB2_MAX_READ;
+	Globals.smb2_max_write = DEFAULT_SMB2_MAX_WRITE;
+	Globals.smb2_max_trans = DEFAULT_SMB2_MAX_TRANSACT;
+	Globals.smb2_max_credits = DEFAULT_SMB2_MAX_CREDITS;
+	Globals.smb2_leases = true;
+	Globals.server_multi_channel_support = true;
+
+	lpcfg_string_set(Globals.ctx, &Globals.ncalrpc_dir,
+			 get_dyn_NCALRPCDIR());
+
+	Globals.server_services = str_list_make_v3_const(NULL, "s3fs rpc nbt wrepl ldap cldap kdc drepl winbindd ntp_signd kcc dnsupdate dns", NULL);
+
+	Globals.dcerpc_endpoint_servers = str_list_make_v3_const(NULL, "epmapper wkssvc rpcecho samr netlogon lsarpc drsuapi dssetup unixinfo browser eventlog6 backupkey dnsserver", NULL);
+
+	Globals.tls_enabled = true;
+	Globals.tls_verify_peer = TLS_VERIFY_PEER_AS_STRICT_AS_POSSIBLE;
+
+	lpcfg_string_set(Globals.ctx, &Globals._tls_keyfile, "tls/key.pem");
+	lpcfg_string_set(Globals.ctx, &Globals._tls_certfile, "tls/cert.pem");
+	lpcfg_string_set(Globals.ctx, &Globals._tls_cafile, "tls/ca.pem");
+	lpcfg_string_set(Globals.ctx,
+			 &Globals.tls_priority,
+			 "NORMAL:-VERS-SSL3.0");
+
+	Globals._preferred_master = Auto;
+
+	Globals.allow_dns_updates = DNS_UPDATE_SIGNED;
+	Globals.dns_zone_scavenging = false;
+
+	lpcfg_string_set(Globals.ctx, &Globals.ntp_signd_socket_directory,
+			 get_dyn_NTP_SIGND_SOCKET_DIR());
+
+	s = talloc_asprintf(talloc_tos(), "%s/samba_kcc", get_dyn_SCRIPTSBINDIR());
+	if (s == NULL) {
+		smb_panic("init_globals: ENOMEM");
+	}
+	Globals.samba_kcc_command = str_list_make_v3_const(NULL, s, NULL);
+	TALLOC_FREE(s);
+
+#ifdef MIT_KDC_PATH
+	Globals.mit_kdc_command = str_list_make_v3_const(NULL, MIT_KDC_PATH, NULL);
+#endif
+
+	s = talloc_asprintf(talloc_tos(), "%s/samba_dnsupdate", get_dyn_SCRIPTSBINDIR());
+	if (s == NULL) {
+		smb_panic("init_globals: ENOMEM");
+	}
+	Globals.dns_update_command = str_list_make_v3_const(NULL, s, NULL);
+	TALLOC_FREE(s);
+
+	s = talloc_asprintf(talloc_tos(), "%s/samba-gpupdate", get_dyn_SCRIPTSBINDIR());
+	if (s == NULL) {
+		smb_panic("init_globals: ENOMEM");
+	}
+	Globals.gpo_update_command = str_list_make_v3_const(NULL, s, NULL);
+	TALLOC_FREE(s);
+
+	Globals.apply_group_policies = false;
+
+	s = talloc_asprintf(talloc_tos(), "%s/samba_spnupdate", get_dyn_SCRIPTSBINDIR());
+	if (s == NULL) {
+		smb_panic("init_globals: ENOMEM");
+	}
+	Globals.spn_update_command = str_list_make_v3_const(NULL, s, NULL);
+	TALLOC_FREE(s);
+
+	Globals.nsupdate_command = str_list_make_v3_const(NULL, "/usr/bin/nsupdate -g", NULL);
+
+	Globals.cldap_port = 389;
+
+	Globals.dgram_port = NBT_DGRAM_SERVICE_PORT;
+
+	Globals.nbt_port = NBT_NAME_SERVICE_PORT;
+
+	Globals.krb5_port = 88;
+
+	Globals.kpasswd_port = 464;
+
+	Globals.kdc_enable_fast = true;
+
+	Globals.aio_max_threads = 100;
+
+	lpcfg_string_set(Globals.ctx,
+			 &Globals.rpc_server_dynamic_port_range,
+			 "49152-65535");
+	Globals.rpc_low_port = SERVER_TCP_LOW_PORT;
+	Globals.rpc_high_port = SERVER_TCP_HIGH_PORT;
+	Globals.prefork_children = 4;
+	Globals.prefork_backoff_increment = 10;
+	Globals.prefork_maximum_backoff = 120;
+
+	Globals.ldap_max_anonymous_request_size = 256000;
+	Globals.ldap_max_authenticated_request_size = 16777216;
+	Globals.ldap_max_search_request_size = 256000;
+
+	/* Async DNS query timeout (in seconds). */
+	Globals.async_dns_timeout = 10;
+
+	Globals.client_smb_encrypt = SMB_ENCRYPTION_DEFAULT;
+
+	Globals._client_use_kerberos = CRED_USE_KERBEROS_DESIRED;
+
+	Globals.client_protection = CRED_CLIENT_PROTECTION_DEFAULT;
+
+	Globals.winbind_use_krb5_enterprise_principals = true;
+
+	Globals.client_smb3_signing_algorithms =
+		str_list_make_v3_const(NULL, DEFAULT_SMB3_SIGNING_ALGORITHMS, NULL);
+	Globals.server_smb3_signing_algorithms =
+		str_list_make_v3_const(NULL, DEFAULT_SMB3_SIGNING_ALGORITHMS, NULL);
+
+	Globals.client_smb3_encryption_algorithms =
+		str_list_make_v3_const(NULL, DEFAULT_SMB3_ENCRYPTION_ALGORITHMS, NULL);
+	Globals.server_smb3_encryption_algorithms =
+		str_list_make_v3_const(NULL, DEFAULT_SMB3_ENCRYPTION_ALGORITHMS, NULL);
+
+	Globals.min_domain_uid = 1000;
+
+	/*
+	 * By default allow smbd and winbindd to start samba-dcerpcd as
+	 * a named-pipe helper.
+	 */
+	Globals.rpc_start_on_demand_helpers = true;
+
+	/* Now put back the settings that were set with lp_set_cmdline() */
+	apply_lp_set_cmdline();
+}
+
+/* Convenience routine to setup an lp_context with additional s3 variables */
+static struct loadparm_context *setup_lp_context(TALLOC_CTX *mem_ctx)
+{
+	struct loadparm_context *lp_ctx;
+
+	lp_ctx = loadparm_init_s3(mem_ctx,
+				  loadparm_s3_helpers());
+	if (lp_ctx == NULL) {
+		DEBUG(0, ("loadparm_init_s3 failed\n"));
+		return NULL;
+	}
+
+	lp_ctx->sDefault = talloc_zero(lp_ctx, struct loadparm_service);
+	if (lp_ctx->sDefault == NULL) {
+		DBG_ERR("talloc_zero failed\n");
+		TALLOC_FREE(lp_ctx);
+		return NULL;
+	}
+
+	*lp_ctx->sDefault = _sDefault;
+	lp_ctx->services = NULL; /* We do not want to access this directly */
+	lp_ctx->bInGlobalSection = bInGlobalSection;
+	lp_ctx->flags = flags_list;
+
+	return lp_ctx;
+}
+
+/*******************************************************************
+ Convenience routine to grab string parameters into talloced memory
+ and run standard_sub_basic on them. The buffers can be written to by
+ callers without affecting the source string.
+********************************************************************/
+
+static char *loadparm_s3_global_substitution_fn(
+			TALLOC_CTX *mem_ctx,
+			const struct loadparm_substitution *lp_sub,
+			const char *s,
+			void *private_data)
+{
+	char *ret;
+
+	/* The follow debug is useful for tracking down memory problems
+	   especially if you have an inner loop that is calling a lp_*()
+	   function that returns a string.  Perhaps this debug should be
+	   present all the time? */
+
+#if 0
+	DEBUG(10, ("lp_string(%s)\n", s));
+#endif
+	if (!s) {
+		return NULL;
+	}
+
+	ret = talloc_sub_basic(mem_ctx,
+			get_current_username(),
+			current_user_info.domain,
+			s);
+	if (trim_char(ret, '\"', '\"')) {
+		if (strchr(ret,'\"') != NULL) {
+			TALLOC_FREE(ret);
+			ret = talloc_sub_basic(mem_ctx,
+					get_current_username(),
+					current_user_info.domain,
+					s);
+		}
+	}
+	return ret;
+}
+
+static const struct loadparm_substitution s3_global_substitution = {
+	.substituted_string_fn = loadparm_s3_global_substitution_fn,
+};
+
+const struct loadparm_substitution *loadparm_s3_global_substitution(void)
+{
+	return &s3_global_substitution;
+}
+
+/*
+   In this section all the functions that are used to access the
+   parameters from the rest of the program are defined
+*/
+
+#define FN_GLOBAL_SUBSTITUTED_STRING(fn_name,ptr) \
+char *lp_ ## fn_name(TALLOC_CTX *ctx, const struct loadparm_substitution *lp_sub) \
+ {return lpcfg_substituted_string(ctx, lp_sub, *(char **)(&Globals.ptr) ? *(char **)(&Globals.ptr) : "");}
+#define FN_GLOBAL_CONST_STRING(fn_name,ptr) \
+ const char *lp_ ## fn_name(void) {return(*(const char * const *)(&Globals.ptr) ? *(const char * const *)(&Globals.ptr) : "");}
+#define FN_GLOBAL_LIST(fn_name,ptr) \
+ const char **lp_ ## fn_name(void) {return(*(const char ***)(&Globals.ptr));}
+#define FN_GLOBAL_BOOL(fn_name,ptr) \
+ bool lp_ ## fn_name(void) {return(*(bool *)(&Globals.ptr));}
+#define FN_GLOBAL_CHAR(fn_name,ptr) \
+ char lp_ ## fn_name(void) {return(*(char *)(&Globals.ptr));}
+#define FN_GLOBAL_INTEGER(fn_name,ptr) \
+ int lp_ ## fn_name(void) {return(*(int *)(&Globals.ptr));}
+
+#define FN_LOCAL_SUBSTITUTED_STRING(fn_name,val) \
+char *lp_ ## fn_name(TALLOC_CTX *ctx, const struct loadparm_substitution *lp_sub, int i) \
+ {return lpcfg_substituted_string((ctx), lp_sub, (LP_SNUM_OK(i) && ServicePtrs[(i)]->val) ? ServicePtrs[(i)]->val : sDefault.val);}
+#define FN_LOCAL_CONST_STRING(fn_name,val) \
+ const char *lp_ ## fn_name(int i) {return (const char *)((LP_SNUM_OK(i) && ServicePtrs[(i)]->val) ? ServicePtrs[(i)]->val : sDefault.val);}
+#define FN_LOCAL_LIST(fn_name,val) \
+ const char **lp_ ## fn_name(int i) {return(const char **)(LP_SNUM_OK(i)? ServicePtrs[(i)]->val : sDefault.val);}
+#define FN_LOCAL_BOOL(fn_name,val) \
+ bool lp_ ## fn_name(int i) {return(bool)(LP_SNUM_OK(i)? ServicePtrs[(i)]->val : sDefault.val);}
+#define FN_LOCAL_INTEGER(fn_name,val) \
+ int lp_ ## fn_name(int i) {return(LP_SNUM_OK(i)? ServicePtrs[(i)]->val : sDefault.val);}
+
+#define FN_LOCAL_PARM_BOOL(fn_name,val) \
+ bool lp_ ## fn_name(const struct share_params *p) {return(bool)(LP_SNUM_OK(p->service)? ServicePtrs[(p->service)]->val : sDefault.val);}
+#define FN_LOCAL_PARM_INTEGER(fn_name,val) \
+ int lp_ ## fn_name(const struct share_params *p) {return(LP_SNUM_OK(p->service)? ServicePtrs[(p->service)]->val : sDefault.val);}
+#define FN_LOCAL_PARM_CHAR(fn_name,val) \
+ char lp_ ## fn_name(const struct share_params *p) {return(LP_SNUM_OK(p->service)? ServicePtrs[(p->service)]->val : sDefault.val);}
+
+int lp_winbind_max_domain_connections(void)
+{
+	if (lp_winbind_offline_logon() &&
+	    lp__winbind_max_domain_connections() > 1) {
+		DEBUG(1, ("offline logons active, restricting max domain "
+			  "connections to 1\n"));
+		return 1;
+	}
+	return MAX(1, lp__winbind_max_domain_connections());
+}
+
+/* These functions remain in source3/param for now */
+
+#include "lib/param/param_functions.c"
+
+FN_LOCAL_SUBSTITUTED_STRING(servicename, szService)
+FN_LOCAL_CONST_STRING(const_servicename, szService)
+
+/* These functions cannot be auto-generated */
+FN_LOCAL_BOOL(autoloaded, autoloaded)
+FN_GLOBAL_CONST_STRING(dnsdomain, dnsdomain)
+
+/* local prototypes */
+
+static int map_parameter_canonical(const char *pszParmName, bool *inverse);
+static const char *get_boolean(bool bool_value);
+static bool do_parameter(const char *pszParmName, const char *pszParmValue,
+			 void *userdata);
+static bool hash_a_service(const char *name, int number);
+static void free_service_byindex(int iService);
+static void show_parameter(int parmIndex);
+static bool is_synonym_of(int parm1, int parm2, bool *inverse);
+static bool lp_parameter_value_is_valid(const char *parm_name, const char *val);
+
+/*
+ * This is a helper function for parametrical options support.  It returns a
+ * pointer to parametrical option value if it exists or NULL otherwise. Actual
+ * parametrical functions are quite simple
+ */
+static struct parmlist_entry *get_parametrics(int snum, const char *type,
+						const char *option)
+{
+	if (snum >= iNumServices) return NULL;
+
+	if (snum < 0) {
+		return get_parametric_helper(NULL, type, option, Globals.param_opt);
+	} else {
+		return get_parametric_helper(ServicePtrs[snum],
+					     type, option, Globals.param_opt);
+	}
+}
+
+static void discard_whitespace(char *str)
+{
+	size_t len = strlen(str);
+	size_t i = 0;
+
+	while (i < len) {
+		if (isspace(str[i])) {
+			memmove(&str[i], &str[i+1], len-i);
+			len -= 1;
+			continue;
+		}
+		i += 1;
+	}
+}
+
+/**
+ * @brief Go through all global parametric parameters
+ *
+ * @param regex_str	A regular expression to scan param for
+ * @param max_matches   Max number of submatches the regexp expects
+ * @param cb		Function to call on match. Should return true
+ *                      when it wants wi_scan_global_parametrics to stop
+ *                      scanning
+ * @param private_data  Anonymous pointer passed to cb
+ *
+ * @return              0: success, regcomp/regexec return value on error.
+ *                      See "man regexec" for possible errors
+ */
+
+int lp_wi_scan_global_parametrics(
+	const char *regex_str, size_t max_matches,
+	bool (*cb)(const char *string, regmatch_t matches[],
+		   void *private_data),
+	void *private_data)
+{
+	struct parmlist_entry *data;
+	regex_t regex;
+	int ret;
+
+	ret = regcomp(&regex, regex_str, REG_ICASE);
+	if (ret != 0) {
+		return ret;
+	}
+
+	for (data = Globals.param_opt; data != NULL; data = data->next) {
+		size_t keylen = strlen(data->key);
+		char key[keylen+1];
+		regmatch_t matches[max_matches];
+		bool stop;
+
+		memcpy(key, data->key, sizeof(key));
+		discard_whitespace(key);
+
+		ret = regexec(&regex, key, max_matches, matches, 0);
+		if (ret == REG_NOMATCH) {
+			continue;
+		}
+		if (ret != 0) {
+			goto fail;
+		}
+
+		stop = cb(key, matches, private_data);
+		if (stop) {
+			break;
+		}
+	}
+
+	ret = 0;
+fail:
+	regfree(&regex);
+	return ret;
+}
+
+
+#define MISSING_PARAMETER(name) \
+    DEBUG(0, ("%s(): value is NULL or empty!\n", #name))
+
+/*******************************************************************
+convenience routine to return enum parameters.
+********************************************************************/
+static int lp_enum(const char *s,const struct enum_list *_enum)
+{
+	int i;
+
+	if (!s || !*s || !_enum) {
+		MISSING_PARAMETER(lp_enum);
+		return (-1);
+	}
+
+	for (i=0; _enum[i].name; i++) {
+		if (strequal(_enum[i].name,s))
+			return _enum[i].value;
+	}
+
+	DEBUG(0,("lp_enum(%s,enum): value is not in enum_list!\n",s));
+	return (-1);
+}
+
+#undef MISSING_PARAMETER
+
+/* Return parametric option from a given service. Type is a part of option before ':' */
+/* Parametric option has following syntax: 'Type: option = value' */
+char *lp_parm_substituted_string(TALLOC_CTX *mem_ctx,
+				 const struct loadparm_substitution *lp_sub,
+				 int snum,
+				 const char *type,
+				 const char *option,
+				 const char *def)
+{
+	struct parmlist_entry *data = get_parametrics(snum, type, option);
+
+	SMB_ASSERT(lp_sub != NULL);
+
+	if (data == NULL||data->value==NULL) {
+		if (def) {
+			return lpcfg_substituted_string(mem_ctx, lp_sub, def);
+		} else {
+			return NULL;
+		}
+	}
+
+	return lpcfg_substituted_string(mem_ctx, lp_sub, data->value);
+}
+
+/* Return parametric option from a given service. Type is a part of option before ':' */
+/* Parametric option has following syntax: 'Type: option = value' */
+const char *lp_parm_const_string(int snum, const char *type, const char *option, const char *def)
+{
+	struct parmlist_entry *data = get_parametrics(snum, type, option);
+
+	if (data == NULL||data->value==NULL)
+		return def;
+
+	return data->value;
+}
+
+
+/* Return parametric option from a given service. Type is a part of option before ':' */
+/* Parametric option has following syntax: 'Type: option = value' */
+
+const char **lp_parm_string_list(int snum, const char *type, const char *option, const char **def)
+{
+	struct parmlist_entry *data = get_parametrics(snum, type, option);
+
+	if (data == NULL||data->value==NULL)
+		return (const char **)def;
+
+	if (data->list==NULL) {
+		data->list = str_list_make_v3(NULL, data->value, NULL);
+	}
+
+	return discard_const_p(const char *, data->list);
+}
+
+/* Return parametric option from a given service. Type is a part of option before ':' */
+/* Parametric option has following syntax: 'Type: option = value' */
+
+int lp_parm_int(int snum, const char *type, const char *option, int def)
+{
+	struct parmlist_entry *data = get_parametrics(snum, type, option);
+
+	if (data && data->value && *data->value)
+		return lp_int(data->value);
+
+	return def;
+}
+
+/* Return parametric option from a given service. Type is a part of option before ':' */
+/* Parametric option has following syntax: 'Type: option = value' */
+
+unsigned long lp_parm_ulong(int snum, const char *type, const char *option, unsigned long def)
+{
+	struct parmlist_entry *data = get_parametrics(snum, type, option);
+
+	if (data && data->value && *data->value)
+		return lp_ulong(data->value);
+
+	return def;
+}
+
+/* Return parametric option from a given service. Type is a part of option before ':' */
+/* Parametric option has following syntax: 'Type: option = value' */
+
+unsigned long long lp_parm_ulonglong(int snum, const char *type,
+				     const char *option, unsigned long long def)
+{
+	struct parmlist_entry *data = get_parametrics(snum, type, option);
+
+	if (data && data->value && *data->value) {
+		return lp_ulonglong(data->value);
+	}
+
+	return def;
+}
+
+/* Return parametric option from a given service. Type is a part of option
+ * before ':' */
+/* Parametric option has following syntax: 'Type: option = value' */
+
+bool lp_parm_bool(int snum, const char *type, const char *option, bool def)
+{
+	struct parmlist_entry *data = get_parametrics(snum, type, option);
+
+	if (data && data->value && *data->value)
+		return lp_bool(data->value);
+
+	return def;
+}
+
+/* Return parametric option from a given service. Type is a part of option before ':' */
+/* Parametric option has following syntax: 'Type: option = value' */
+
+int lp_parm_enum(int snum, const char *type, const char *option,
+		 const struct enum_list *_enum, int def)
+{
+	struct parmlist_entry *data = get_parametrics(snum, type, option);
+
+	if (data && data->value && *data->value && _enum)
+		return lp_enum(data->value, _enum);
+
+	return def;
+}
+
+/**
+ * free a param_opts structure.
+ * param_opts handling should be moved to talloc;
+ * then this whole functions reduces to a TALLOC_FREE().
+ */
+
+static void free_param_opts(struct parmlist_entry **popts)
+{
+	struct parmlist_entry *opt, *next_opt;
+
+	if (*popts != NULL) {
+		DEBUG(5, ("Freeing parametrics:\n"));
+	}
+	opt = *popts;
+	while (opt != NULL) {
+		lpcfg_string_free(&opt->key);
+		lpcfg_string_free(&opt->value);
+		TALLOC_FREE(opt->list);
+		next_opt = opt->next;
+		TALLOC_FREE(opt);
+		opt = next_opt;
+	}
+	*popts = NULL;
+}
+
+/***************************************************************************
+ Free the dynamically allocated parts of a service struct.
+***************************************************************************/
+
+static void free_service(struct loadparm_service *pservice)
+{
+	if (!pservice)
+		return;
+
+	if (pservice->szService)
+		DEBUG(5, ("free_service: Freeing service %s\n",
+		       pservice->szService));
+
+	free_parameters(pservice);
+
+	lpcfg_string_free(&pservice->szService);
+	TALLOC_FREE(pservice->copymap);
+
+	free_param_opts(&pservice->param_opt);
+
+	ZERO_STRUCTP(pservice);
+}
+
+
+/***************************************************************************
+ remove a service indexed in the ServicePtrs array from the ServiceHash
+ and free the dynamically allocated parts
+***************************************************************************/
+
+static void free_service_byindex(int idx)
+{
+	if ( !LP_SNUM_OK(idx) )
+		return;
+
+	ServicePtrs[idx]->valid = false;
+
+	/* we have to cleanup the hash record */
+
+	if (ServicePtrs[idx]->szService) {
+		char *canon_name = canonicalize_servicename(
+			talloc_tos(),
+			ServicePtrs[idx]->szService );
+
+		dbwrap_delete_bystring(ServiceHash, canon_name );
+		TALLOC_FREE(canon_name);
+	}
+
+	free_service(ServicePtrs[idx]);
+	TALLOC_FREE(ServicePtrs[idx]);
+}
+
+/***************************************************************************
+ Add a new service to the services array initialising it with the given
+ service.
+***************************************************************************/
+
+static int add_a_service(const struct loadparm_service *pservice, const char *name)
+{
+	int i;
+	struct loadparm_service **tsp = NULL;
+
+	/* it might already exist */
+	if (name) {
+		i = getservicebyname(name, NULL);
+		if (i >= 0) {
+			return (i);
+		}
+	}
+
+	/* Re use empty slots if any before allocating new one.*/
+	for (i=0; i < iNumServices; i++) {
+		if (ServicePtrs[i] == NULL) {
+			break;
+		}
+	}
+	if (i == iNumServices) {
+		/* if not, then create one */
+		tsp = talloc_realloc(NULL, ServicePtrs,
+				     struct loadparm_service *,
+				     iNumServices + 1);
+		if (tsp == NULL) {
+			DEBUG(0, ("add_a_service: failed to enlarge "
+				  "ServicePtrs!\n"));
+			return (-1);
+		}
+		ServicePtrs = tsp;
+		iNumServices++;
+	}
+	ServicePtrs[i] = talloc_zero(ServicePtrs, struct loadparm_service);
+	if (!ServicePtrs[i]) {
+		DEBUG(0,("add_a_service: out of memory!\n"));
+		return (-1);
+	}
+
+	ServicePtrs[i]->valid = true;
+
+	copy_service(ServicePtrs[i], pservice, NULL);
+	if (name)
+		lpcfg_string_set(ServicePtrs[i], &ServicePtrs[i]->szService,
+				 name);
+
+	DEBUG(8,("add_a_service: Creating snum = %d for %s\n",
+		i, ServicePtrs[i]->szService));
+
+	if (!hash_a_service(ServicePtrs[i]->szService, i)) {
+		return (-1);
+	}
+
+	return (i);
+}
+
+/***************************************************************************
+  Convert a string to uppercase and remove whitespaces.
+***************************************************************************/
+
+char *canonicalize_servicename(TALLOC_CTX *ctx, const char *src)
+{
+	char *result;
+
+	if ( !src ) {
+		DEBUG(0,("canonicalize_servicename: NULL source name!\n"));
+		return NULL;
+	}
+
+	result = talloc_strdup(ctx, src);
+	SMB_ASSERT(result != NULL);
+
+	if (!strlower_m(result)) {
+		TALLOC_FREE(result);
+		return NULL;
+	}
+	return result;
+}
+
+/***************************************************************************
+  Add a name/index pair for the services array to the hash table.
+***************************************************************************/
+
+static bool hash_a_service(const char *name, int idx)
+{
+	char *canon_name;
+
+	if ( !ServiceHash ) {
+		DEBUG(10,("hash_a_service: creating servicehash\n"));
+		ServiceHash = db_open_rbt(NULL);
+		if ( !ServiceHash ) {
+			DEBUG(0,("hash_a_service: open tdb servicehash failed!\n"));
+			return false;
+		}
+	}
+
+	DEBUG(10,("hash_a_service: hashing index %d for service name %s\n",
+		idx, name));
+
+	canon_name = canonicalize_servicename(talloc_tos(), name );
+
+	dbwrap_store_bystring(ServiceHash, canon_name,
+			      make_tdb_data((uint8_t *)&idx, sizeof(idx)),
+			      TDB_REPLACE);
+
+	TALLOC_FREE(canon_name);
+
+	return true;
+}
+
+/***************************************************************************
+ Add a new home service, with the specified home directory, defaults coming
+ from service ifrom.
+***************************************************************************/
+
+bool lp_add_home(const char *pszHomename, int iDefaultService,
+		 const char *user, const char *pszHomedir)
+{
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	int i;
+	char *global_path;
+
+	if (pszHomename == NULL || user == NULL || pszHomedir == NULL ||
+			pszHomedir[0] == '\0') {
+		return false;
+	}
+
+	i = add_a_service(ServicePtrs[iDefaultService], pszHomename);
+
+	if (i < 0)
+		return false;
+
+	global_path = lp_path(talloc_tos(), lp_sub, GLOBAL_SECTION_SNUM);
+	if (!(*(ServicePtrs[iDefaultService]->path))
+	    || strequal(ServicePtrs[iDefaultService]->path, global_path)) {
+		lpcfg_string_set(ServicePtrs[i], &ServicePtrs[i]->path,
+				 pszHomedir);
+	}
+	TALLOC_FREE(global_path);
+
+	if (!(*(ServicePtrs[i]->comment))) {
+		char *comment = talloc_asprintf(talloc_tos(), "Home directory of %s", user);
+		if (comment == NULL) {
+			return false;
+		}
+		lpcfg_string_set(ServicePtrs[i], &ServicePtrs[i]->comment,
+				 comment);
+		TALLOC_FREE(comment);
+	}
+
+	/* set the browseable flag from the global default */
+
+	ServicePtrs[i]->browseable = sDefault.browseable;
+	ServicePtrs[i]->access_based_share_enum = sDefault.access_based_share_enum;
+
+	ServicePtrs[i]->autoloaded = true;
+
+	DEBUG(3, ("adding home's share [%s] for user '%s' at '%s'\n", pszHomename,
+	       user, ServicePtrs[i]->path ));
+
+	return true;
+}
+
+/***************************************************************************
+ Add a new service, based on an old one.
+***************************************************************************/
+
+int lp_add_service(const char *pszService, int iDefaultService)
+{
+	if (iDefaultService < 0) {
+		return add_a_service(&sDefault, pszService);
+	}
+
+	return (add_a_service(ServicePtrs[iDefaultService], pszService));
+}
+
+/***************************************************************************
+ Add the IPC service.
+***************************************************************************/
+
+static bool lp_add_ipc(const char *ipc_name, bool guest_ok)
+{
+	char *comment = NULL;
+	int i = add_a_service(&sDefault, ipc_name);
+
+	if (i < 0)
+		return false;
+
+	comment = talloc_asprintf(talloc_tos(), "IPC Service (%s)",
+				  Globals.server_string);
+	if (comment == NULL) {
+		return false;
+	}
+
+	lpcfg_string_set(ServicePtrs[i], &ServicePtrs[i]->path, tmpdir());
+	lpcfg_string_set(ServicePtrs[i], &ServicePtrs[i]->comment, comment);
+	lpcfg_string_set(ServicePtrs[i], &ServicePtrs[i]->fstype, "IPC");
+	ServicePtrs[i]->max_connections = 0;
+	ServicePtrs[i]->available = true;
+	ServicePtrs[i]->read_only = true;
+	ServicePtrs[i]->guest_only = false;
+	ServicePtrs[i]->administrative_share = true;
+	ServicePtrs[i]->guest_ok = guest_ok;
+	ServicePtrs[i]->printable = false;
+	ServicePtrs[i]->browseable = sDefault.browseable;
+	ServicePtrs[i]->autoloaded = false;
+
+	DEBUG(3, ("adding IPC service\n"));
+
+	TALLOC_FREE(comment);
+	return true;
+}
+
+/***************************************************************************
+ Add a new printer service, with defaults coming from service iFrom.
+***************************************************************************/
+
+bool lp_add_printer(const char *pszPrintername, int iDefaultService)
+{
+	const char *comment = "From Printcap";
+	int i = add_a_service(ServicePtrs[iDefaultService], pszPrintername);
+
+	if (i < 0)
+		return false;
+
+	/* note that we do NOT default the availability flag to true - */
+	/* we take it from the default service passed. This allows all */
+	/* dynamic printers to be disabled by disabling the [printers] */
+	/* entry (if/when the 'available' keyword is implemented!).    */
+
+	/* the printer name is set to the service name. */
+	lpcfg_string_set(ServicePtrs[i], &ServicePtrs[i]->_printername,
+			 pszPrintername);
+	lpcfg_string_set(ServicePtrs[i], &ServicePtrs[i]->comment, comment);
+
+	/* set the browseable flag from the gloabl default */
+	ServicePtrs[i]->browseable = sDefault.browseable;
+
+	/* Printers cannot be read_only. */
+	ServicePtrs[i]->read_only = false;
+	/* No oplocks on printer services. */
+	ServicePtrs[i]->oplocks = false;
+	/* Printer services must be printable. */
+	ServicePtrs[i]->printable = true;
+
+	DEBUG(3, ("adding printer service %s\n", pszPrintername));
+
+	return true;
+}
+
+
+/***************************************************************************
+ Check whether the given parameter name is valid.
+ Parametric options (names containing a colon) are considered valid.
+***************************************************************************/
+
+bool lp_parameter_is_valid(const char *pszParmName)
+{
+	return ((lpcfg_map_parameter(pszParmName) != -1) ||
+		(strchr(pszParmName, ':') != NULL));
+}
+
+/***************************************************************************
+ Check whether the given name is the name of a global parameter.
+ Returns true for strings belonging to parameters of class
+ P_GLOBAL, false for all other strings, also for parametric options
+ and strings not belonging to any option.
+***************************************************************************/
+
+bool lp_parameter_is_global(const char *pszParmName)
+{
+	int num = lpcfg_map_parameter(pszParmName);
+
+	if (num >= 0) {
+		return (parm_table[num].p_class == P_GLOBAL);
+	}
+
+	return false;
+}
+
+/**************************************************************************
+ Determine the canonical name for a parameter.
+ Indicate when it is an inverse (boolean) synonym instead of a
+ "usual" synonym.
+**************************************************************************/
+
+bool lp_canonicalize_parameter(const char *parm_name, const char **canon_parm,
+			       bool *inverse)
+{
+	int num;
+
+	if (!lp_parameter_is_valid(parm_name)) {
+		*canon_parm = NULL;
+		return false;
+	}
+
+	num = map_parameter_canonical(parm_name, inverse);
+	if (num < 0) {
+		/* parametric option */
+		*canon_parm = parm_name;
+	} else {
+		*canon_parm = parm_table[num].label;
+	}
+
+	return true;
+
+}
+
+/**************************************************************************
+ Determine the canonical name for a parameter.
+ Turn the value given into the inverse boolean expression when
+ the synonym is an invers boolean synonym.
+
+ Return true if
+ - parm_name is a valid parameter name and
+ - val is a valid value for this parameter and
+ - in case the parameter is an inverse boolean synonym, if the val
+   string could successfully be converted to the reverse bool.
+ Return false in all other cases.
+**************************************************************************/
+
+bool lp_canonicalize_parameter_with_value(const char *parm_name,
+					  const char *val,
+					  const char **canon_parm,
+					  const char **canon_val)
+{
+	int num;
+	bool inverse;
+	bool ret;
+
+	if (!lp_parameter_is_valid(parm_name)) {
+		*canon_parm = NULL;
+		*canon_val = NULL;
+		return false;
+	}
+
+	num = map_parameter_canonical(parm_name, &inverse);
+	if (num < 0) {
+		/* parametric option */
+		*canon_parm = parm_name;
+		*canon_val = val;
+		return true;
+	}
+
+	*canon_parm = parm_table[num].label;
+	if (inverse) {
+		if (!lp_invert_boolean(val, canon_val)) {
+			*canon_val = NULL;
+			return false;
+		}
+	} else {
+		*canon_val = val;
+	}
+
+	ret = lp_parameter_value_is_valid(*canon_parm, *canon_val);
+
+	return ret;
+}
+
+/***************************************************************************
+ Map a parameter's string representation to the index of the canonical
+ form of the parameter (it might be a synonym).
+ Returns -1 if the parameter string is not recognised.
+***************************************************************************/
+
+static int map_parameter_canonical(const char *pszParmName, bool *inverse)
+{
+	int parm_num, canon_num;
+	bool loc_inverse = false;
+
+	parm_num = lpcfg_map_parameter(pszParmName);
+	if ((parm_num < 0) || !(parm_table[parm_num].flags & FLAG_SYNONYM)) {
+		/* invalid, parametric or no canidate for synonyms ... */
+		goto done;
+	}
+
+	for (canon_num = 0; parm_table[canon_num].label; canon_num++) {
+		if (is_synonym_of(parm_num, canon_num, &loc_inverse)) {
+			parm_num = canon_num;
+			goto done;
+		}
+	}
+
+done:
+	if (inverse != NULL) {
+		*inverse = loc_inverse;
+	}
+	return parm_num;
+}
+
+/***************************************************************************
+ return true if parameter number parm1 is a synonym of parameter
+ number parm2 (parm2 being the principal name).
+ set inverse to true if parm1 is P_BOOLREV and parm2 is P_BOOL,
+ false otherwise.
+***************************************************************************/
+
+static bool is_synonym_of(int parm1, int parm2, bool *inverse)
+{
+	if ((parm_table[parm1].offset == parm_table[parm2].offset) &&
+	    (parm_table[parm1].p_class == parm_table[parm2].p_class) &&
+	    (parm_table[parm1].flags & FLAG_SYNONYM) &&
+	    !(parm_table[parm2].flags & FLAG_SYNONYM))
+	{
+		if (inverse != NULL) {
+			if ((parm_table[parm1].type == P_BOOLREV) &&
+			    (parm_table[parm2].type == P_BOOL))
+			{
+				*inverse = true;
+			} else {
+				*inverse = false;
+			}
+		}
+		return true;
+	}
+	return false;
+}
+
+/***************************************************************************
+ Show one parameter's name, type, [values,] and flags.
+ (helper functions for show_parameter_list)
+***************************************************************************/
+
+static void show_parameter(int parmIndex)
+{
+	size_t enumIndex, flagIndex;
+	size_t parmIndex2;
+	bool hadFlag;
+	bool hadSyn;
+	bool inverse;
+	const char *type[] = { "P_BOOL", "P_BOOLREV", "P_CHAR", "P_INTEGER",
+		"P_OCTAL", "P_LIST", "P_STRING", "P_USTRING",
+		"P_ENUM", "P_BYTES", "P_CMDLIST" };
+	unsigned flags[] = { FLAG_DEPRECATED, FLAG_SYNONYM };
+	const char *flag_names[] = { "FLAG_DEPRECATED", "FLAG_SYNONYM", NULL};
+
+	printf("%s=%s", parm_table[parmIndex].label,
+	       type[parm_table[parmIndex].type]);
+	if (parm_table[parmIndex].type == P_ENUM) {
+		printf(",");
+		for (enumIndex=0;
+		     parm_table[parmIndex].enum_list[enumIndex].name;
+		     enumIndex++)
+		{
+			printf("%s%s",
+			       enumIndex ? "|" : "",
+			       parm_table[parmIndex].enum_list[enumIndex].name);
+		}
+	}
+	printf(",");
+	hadFlag = false;
+	for (flagIndex=0; flag_names[flagIndex]; flagIndex++) {
+		if (parm_table[parmIndex].flags & flags[flagIndex]) {
+			printf("%s%s",
+				hadFlag ? "|" : "",
+				flag_names[flagIndex]);
+			hadFlag = true;
+		}
+	}
+
+	/* output synonyms */
+	hadSyn = false;
+	for (parmIndex2=0; parm_table[parmIndex2].label; parmIndex2++) {
+		if (is_synonym_of(parmIndex, parmIndex2, &inverse)) {
+			printf(" (%ssynonym of %s)", inverse ? "inverse " : "",
+			       parm_table[parmIndex2].label);
+		} else if (is_synonym_of(parmIndex2, parmIndex, &inverse)) {
+			if (!hadSyn) {
+				printf(" (synonyms: ");
+				hadSyn = true;
+			} else {
+				printf(", ");
+			}
+			printf("%s%s", parm_table[parmIndex2].label,
+			       inverse ? "[i]" : "");
+		}
+	}
+	if (hadSyn) {
+		printf(")");
+	}
+
+	printf("\n");
+}
+
+/*
+ * Check the value for a P_ENUM
+ */
+static bool check_enum_parameter(struct parm_struct *parm, const char *value)
+{
+	int i;
+
+	for (i = 0; parm->enum_list[i].name; i++) {
+		if (strwicmp(value, parm->enum_list[i].name) == 0) {
+			return true;
+		}
+	}
+	return false;
+}
+
+/**************************************************************************
+ Check whether the given value is valid for the given parameter name.
+**************************************************************************/
+
+static bool lp_parameter_value_is_valid(const char *parm_name, const char *val)
+{
+	bool ret = false, tmp_bool;
+	int num = lpcfg_map_parameter(parm_name), tmp_int;
+	uint64_t tmp_int64 = 0;
+	struct parm_struct *parm;
+
+	/* parametric options (parameter names containing a colon) cannot
+	   be checked and are therefore considered valid. */
+	if (strchr(parm_name, ':') != NULL) {
+		return true;
+	}
+
+	if (num >= 0) {
+		parm = &parm_table[num];
+		switch (parm->type) {
+			case P_BOOL:
+			case P_BOOLREV:
+				ret = set_boolean(val, &tmp_bool);
+				break;
+
+			case P_INTEGER:
+				ret = (sscanf(val, "%d", &tmp_int) == 1);
+				break;
+
+			case P_OCTAL:
+				ret = (sscanf(val, "%o", &tmp_int) == 1);
+				break;
+
+			case P_ENUM:
+				ret = check_enum_parameter(parm, val);
+				break;
+
+			case P_BYTES:
+				if (conv_str_size_error(val, &tmp_int64) &&
+				    tmp_int64 <= INT_MAX) {
+					ret = true;
+				}
+				break;
+
+			case P_CHAR:
+			case P_LIST:
+			case P_STRING:
+			case P_USTRING:
+			case P_CMDLIST:
+				ret = true;
+				break;
+		}
+	}
+	return ret;
+}
+
+/***************************************************************************
+ Show all parameter's name, type, [values,] and flags.
+***************************************************************************/
+
+void show_parameter_list(void)
+{
+	int classIndex, parmIndex;
+	const char *section_names[] = { "local", "global", NULL};
+
+	for (classIndex=0; section_names[classIndex]; classIndex++) {
+		printf("[%s]\n", section_names[classIndex]);
+		for (parmIndex = 0; parm_table[parmIndex].label; parmIndex++) {
+			if (parm_table[parmIndex].p_class == classIndex) {
+				show_parameter(parmIndex);
+			}
+		}
+	}
+}
+
+/***************************************************************************
+ Get the standard string representation of a boolean value ("yes" or "no")
+***************************************************************************/
+
+static const char *get_boolean(bool bool_value)
+{
+	static const char *yes_str = "yes";
+	static const char *no_str = "no";
+
+	return (bool_value ? yes_str : no_str);
+}
+
+/***************************************************************************
+ Provide the string of the negated boolean value associated to the boolean
+ given as a string. Returns false if the passed string does not correctly
+ represent a boolean.
+***************************************************************************/
+
+bool lp_invert_boolean(const char *str, const char **inverse_str)
+{
+	bool val;
+
+	if (!set_boolean(str, &val)) {
+		return false;
+	}
+
+	*inverse_str = get_boolean(!val);
+	return true;
+}
+
+/***************************************************************************
+ Provide the canonical string representation of a boolean value given
+ as a string. Return true on success, false if the string given does
+ not correctly represent a boolean.
+***************************************************************************/
+
+bool lp_canonicalize_boolean(const char *str, const char**canon_str)
+{
+	bool val;
+
+	if (!set_boolean(str, &val)) {
+		return false;
+	}
+
+	*canon_str = get_boolean(val);
+	return true;
+}
+
+/***************************************************************************
+Find a service by name. Otherwise works like get_service.
+***************************************************************************/
+
+int getservicebyname(const char *pszServiceName, struct loadparm_service *pserviceDest)
+{
+	int iService = -1;
+	char *canon_name;
+	TDB_DATA data;
+	NTSTATUS status;
+
+	if (ServiceHash == NULL) {
+		return -1;
+	}
+
+	canon_name = canonicalize_servicename(talloc_tos(), pszServiceName);
+
+	status = dbwrap_fetch_bystring(ServiceHash, canon_name, canon_name,
+				       &data);
+
+	if (NT_STATUS_IS_OK(status) &&
+	    (data.dptr != NULL) &&
+	    (data.dsize == sizeof(iService)))
+	{
+		memcpy(&iService, data.dptr, sizeof(iService));
+	}
+
+	TALLOC_FREE(canon_name);
+
+	if ((iService != -1) && (LP_SNUM_OK(iService))
+	    && (pserviceDest != NULL)) {
+		copy_service(pserviceDest, ServicePtrs[iService], NULL);
+	}
+
+	return (iService);
+}
+
+/* Return a pointer to a service by name.  Unlike getservicebyname, it does not copy the service */
+struct loadparm_service *lp_service(const char *pszServiceName)
+{
+	int iService = getservicebyname(pszServiceName, NULL);
+	if (iService == -1 || !LP_SNUM_OK(iService)) {
+		return NULL;
+	}
+	return ServicePtrs[iService];
+}
+
+struct loadparm_service *lp_servicebynum(int snum)
+{
+	if ((snum == -1) || !LP_SNUM_OK(snum)) {
+		return NULL;
+	}
+	return ServicePtrs[snum];
+}
+
+struct loadparm_service *lp_default_loadparm_service(void)
+{
+	return &sDefault;
+}
+
+static struct smbconf_ctx *lp_smbconf_ctx(void)
+{
+	sbcErr err;
+	static struct smbconf_ctx *conf_ctx = NULL;
+
+	if (conf_ctx == NULL) {
+		err = smbconf_init(NULL, &conf_ctx, "registry:");
+		if (!SBC_ERROR_IS_OK(err)) {
+			DEBUG(1, ("error initializing registry configuration: "
+				  "%s\n", sbcErrorString(err)));
+			conf_ctx = NULL;
+		}
+	}
+
+	return conf_ctx;
+}
+
+static bool process_smbconf_service(struct smbconf_service *service)
+{
+	uint32_t count;
+	bool ret;
+
+	if (service == NULL) {
+		return false;
+	}
+
+	ret = lp_do_section(service->name, NULL);
+	if (ret != true) {
+		return false;
+	}
+	for (count = 0; count < service->num_params; count++) {
+
+		if (!bInGlobalSection && bGlobalOnly) {
+			ret = true;
+		} else {
+			const char *pszParmName = service->param_names[count];
+			const char *pszParmValue = service->param_values[count];
+
+			DEBUGADD(4, ("doing parameter %s = %s\n", pszParmName, pszParmValue));
+
+			ret = lp_do_parameter(bInGlobalSection ? -2 : iServiceIndex,
+					      pszParmName, pszParmValue);
+		}
+
+		if (ret != true) {
+			return false;
+		}
+	}
+	if (iServiceIndex >= 0) {
+		return lpcfg_service_ok(ServicePtrs[iServiceIndex]);
+	}
+	return true;
+}
+
+/**
+ * load a service from registry and activate it
+ */
+bool process_registry_service(const char *service_name)
+{
+	sbcErr err;
+	struct smbconf_service *service = NULL;
+	TALLOC_CTX *mem_ctx = talloc_stackframe();
+	struct smbconf_ctx *conf_ctx = lp_smbconf_ctx();
+	bool ret = false;
+
+	if (conf_ctx == NULL) {
+		goto done;
+	}
+
+	DEBUG(5, ("process_registry_service: service name %s\n", service_name));
+
+	if (!smbconf_share_exists(conf_ctx, service_name)) {
+		/*
+		 * Registry does not contain data for this service (yet),
+		 * but make sure lp_load doesn't return false.
+		 */
+		ret = true;
+		goto done;
+	}
+
+	err = smbconf_get_share(conf_ctx, mem_ctx, service_name, &service);
+	if (!SBC_ERROR_IS_OK(err)) {
+		goto done;
+	}
+
+	ret = process_smbconf_service(service);
+	if (!ret) {
+		goto done;
+	}
+
+	/* store the csn */
+	smbconf_changed(conf_ctx, &conf_last_csn, NULL, NULL);
+
+done:
+	TALLOC_FREE(mem_ctx);
+	return ret;
+}
+
+/*
+ * process_registry_globals
+ */
+static bool process_registry_globals(void)
+{
+	bool ret;
+
+	add_to_file_list(NULL, &file_lists, INCLUDE_REGISTRY_NAME, INCLUDE_REGISTRY_NAME);
+
+	if (!bInGlobalSection && bGlobalOnly) {
+		ret = true;
+	} else {
+		const char *pszParmName = "registry shares";
+		const char *pszParmValue = "yes";
+
+		DEBUGADD(4, ("doing parameter %s = %s\n", pszParmName, pszParmValue));
+
+		ret = lp_do_parameter(bInGlobalSection ? -2 : iServiceIndex,
+				      pszParmName, pszParmValue);
+	}
+
+	if (!ret) {
+		return ret;
+	}
+
+	return process_registry_service(GLOBAL_NAME);
+}
+
+bool process_registry_shares(void)
+{
+	sbcErr err;
+	uint32_t count;
+	struct smbconf_service **service = NULL;
+	uint32_t num_shares = 0;
+	TALLOC_CTX *mem_ctx = talloc_stackframe();
+	struct smbconf_ctx *conf_ctx = lp_smbconf_ctx();
+	bool ret = false;
+
+	if (conf_ctx == NULL) {
+		goto done;
+	}
+
+	err = smbconf_get_config(conf_ctx, mem_ctx, &num_shares, &service);
+	if (!SBC_ERROR_IS_OK(err)) {
+		goto done;
+	}
+
+	ret = true;
+
+	for (count = 0; count < num_shares; count++) {
+		if (strequal(service[count]->name, GLOBAL_NAME)) {
+			continue;
+		}
+		ret = process_smbconf_service(service[count]);
+		if (!ret) {
+			goto done;
+		}
+	}
+
+	/* store the csn */
+	smbconf_changed(conf_ctx, &conf_last_csn, NULL, NULL);
+
+done:
+	TALLOC_FREE(mem_ctx);
+	return ret;
+}
+
+/**
+ * reload those shares from registry that are already
+ * activated in the services array.
+ */
+static bool reload_registry_shares(void)
+{
+	int i;
+	bool ret = true;
+
+	for (i = 0; i < iNumServices; i++) {
+		if (!VALID(i)) {
+			continue;
+		}
+
+		if (ServicePtrs[i]->usershare == USERSHARE_VALID) {
+			continue;
+		}
+
+		ret = process_registry_service(ServicePtrs[i]->szService);
+		if (!ret) {
+			goto done;
+		}
+	}
+
+done:
+	return ret;
+}
+
+
+#define MAX_INCLUDE_DEPTH 100
+
+static uint8_t include_depth;
+
+/**
+ * Free the file lists
+ */
+static void free_file_list(void)
+{
+	struct file_lists *f;
+	struct file_lists *next;
+
+	f = file_lists;
+	while( f ) {
+		next = f->next;
+		TALLOC_FREE( f );
+		f = next;
+	}
+	file_lists = NULL;
+}
+
+
+/**
+ * Utility function for outsiders to check if we're running on registry.
+ */
+bool lp_config_backend_is_registry(void)
+{
+	return (lp_config_backend() == CONFIG_BACKEND_REGISTRY);
+}
+
+/**
+ * Utility function to check if the config backend is FILE.
+ */
+bool lp_config_backend_is_file(void)
+{
+	return (lp_config_backend() == CONFIG_BACKEND_FILE);
+}
+
+/*******************************************************************
+ Check if a config file has changed date.
+********************************************************************/
+
+bool lp_file_list_changed(void)
+{
+	struct file_lists *f = file_lists;
+
+ 	DEBUG(6, ("lp_file_list_changed()\n"));
+
+	while (f) {
+		if (strequal(f->name, INCLUDE_REGISTRY_NAME)) {
+			struct smbconf_ctx *conf_ctx = lp_smbconf_ctx();
+
+			if (conf_ctx == NULL) {
+				return false;
+			}
+			if (smbconf_changed(conf_ctx, &conf_last_csn, NULL,
+					    NULL))
+			{
+				DEBUGADD(6, ("registry config changed\n"));
+				return true;
+			}
+		} else {
+			time_t mod_time;
+			char *n2 = NULL;
+
+			n2 = talloc_sub_basic(talloc_tos(),
+					      get_current_username(),
+					      current_user_info.domain,
+					      f->name);
+			if (!n2) {
+				return false;
+			}
+			DEBUGADD(6, ("file %s -> %s  last mod_time: %s\n",
+				     f->name, n2, ctime(&f->modtime)));
+
+			mod_time = file_modtime(n2);
+
+			if (mod_time &&
+			    ((f->modtime != mod_time) ||
+			     (f->subfname == NULL) ||
+			     (strcmp(n2, f->subfname) != 0)))
+			{
+				DEBUGADD(6,
+					 ("file %s modified: %s\n", n2,
+					  ctime(&mod_time)));
+				f->modtime = mod_time;
+				TALLOC_FREE(f->subfname);
+				f->subfname = talloc_strdup(f, n2);
+				if (f->subfname == NULL) {
+					smb_panic("talloc_strdup failed");
+				}
+				TALLOC_FREE(n2);
+				return true;
+			}
+			TALLOC_FREE(n2);
+		}
+		f = f->next;
+	}
+	return false;
+}
+
+
+/**
+ * Initialize iconv conversion descriptors.
+ *
+ * This is called the first time it is needed, and also called again
+ * every time the configuration is reloaded, because the charset or
+ * codepage might have changed.
+ **/
+static void init_iconv(void)
+{
+	struct smb_iconv_handle *ret = NULL;
+
+	ret = reinit_iconv_handle(NULL,
+				  lp_dos_charset(),
+				  lp_unix_charset());
+	if (ret == NULL) {
+		smb_panic("reinit_iconv_handle failed");
+	}
+}
+
+/***************************************************************************
+ Handle the include operation.
+***************************************************************************/
+static bool bAllowIncludeRegistry = true;
+
+bool lp_include(struct loadparm_context *lp_ctx, struct loadparm_service *service,
+	       	const char *pszParmValue, char **ptr)
+{
+	char *fname;
+
+	if (include_depth >= MAX_INCLUDE_DEPTH) {
+		DEBUG(0, ("Error: Maximum include depth (%u) exceeded!\n",
+			  include_depth));
+		return false;
+	}
+
+	if (strequal(pszParmValue, INCLUDE_REGISTRY_NAME)) {
+		if (!bAllowIncludeRegistry) {
+			return true;
+		}
+		if (lp_ctx->bInGlobalSection) {
+			bool ret;
+			include_depth++;
+			ret = process_registry_globals();
+			include_depth--;
+			return ret;
+		} else {
+			DEBUG(1, ("\"include = registry\" only effective "
+				  "in %s section\n", GLOBAL_NAME));
+			return false;
+		}
+	}
+
+	fname = talloc_sub_basic(talloc_tos(), get_current_username(),
+				 current_user_info.domain,
+				 pszParmValue);
+
+	add_to_file_list(NULL, &file_lists, pszParmValue, fname);
+
+	if (service == NULL) {
+		lpcfg_string_set(Globals.ctx, ptr, fname);
+	} else {
+		lpcfg_string_set(service, ptr, fname);
+	}
+
+	if (file_exist(fname)) {
+		bool ret;
+		include_depth++;
+		ret = pm_process(fname, lp_do_section, do_parameter, lp_ctx);
+		include_depth--;
+		TALLOC_FREE(fname);
+		return ret;
+	}
+
+	DEBUG(2, ("Can't find include file %s\n", fname));
+	TALLOC_FREE(fname);
+	return true;
+}
+
+bool lp_idmap_range(const char *domain_name, uint32_t *low, uint32_t *high)
+{
+	char *config_option = NULL;
+	const char *range = NULL;
+	bool ret = false;
+
+	SMB_ASSERT(low != NULL);
+	SMB_ASSERT(high != NULL);
+
+	if ((domain_name == NULL) || (domain_name[0] == '\0')) {
+		domain_name = "*";
+	}
+
+	config_option = talloc_asprintf(talloc_tos(), "idmap config %s",
+					domain_name);
+	if (config_option == NULL) {
+		DEBUG(0, ("out of memory\n"));
+		return false;
+	}
+
+	range = lp_parm_const_string(-1, config_option, "range", NULL);
+	if (range == NULL) {
+		DEBUG(1, ("idmap range not specified for domain '%s'\n", domain_name));
+		goto done;
+	}
+
+	if (sscanf(range, "%u - %u", low, high) != 2) {
+		DEBUG(1, ("error parsing idmap range '%s' for domain '%s'\n",
+			  range, domain_name));
+		goto done;
+	}
+
+	ret = true;
+
+done:
+	talloc_free(config_option);
+	return ret;
+
+}
+
+bool lp_idmap_default_range(uint32_t *low, uint32_t *high)
+{
+	return lp_idmap_range("*", low, high);
+}
+
+const char *lp_idmap_backend(const char *domain_name)
+{
+	char *config_option = NULL;
+	const char *backend = NULL;
+
+	if ((domain_name == NULL) || (domain_name[0] == '\0')) {
+		domain_name = "*";
+	}
+
+	config_option = talloc_asprintf(talloc_tos(), "idmap config %s",
+					domain_name);
+	if (config_option == NULL) {
+		DEBUG(0, ("out of memory\n"));
+		return false;
+	}
+
+	backend = lp_parm_const_string(-1, config_option, "backend", NULL);
+	if (backend == NULL) {
+		DEBUG(1, ("idmap backend not specified for domain '%s'\n", domain_name));
+		goto done;
+	}
+
+done:
+	talloc_free(config_option);
+	return backend;
+}
+
+const char *lp_idmap_default_backend(void)
+{
+	return lp_idmap_backend("*");
+}
+
+/***************************************************************************
+ Handle ldap suffixes - default to ldapsuffix if sub-suffixes are not defined.
+***************************************************************************/
+
+static const char *append_ldap_suffix(TALLOC_CTX *ctx, const char *str )
+{
+	const char *suffix_string;
+
+	suffix_string = talloc_asprintf(ctx, "%s,%s", str,
+					Globals.ldap_suffix );
+	if ( !suffix_string ) {
+		DEBUG(0,("append_ldap_suffix: talloc_asprintf() failed!\n"));
+		return "";
+	}
+
+	return suffix_string;
+}
+
+const char *lp_ldap_machine_suffix(TALLOC_CTX *ctx)
+{
+	if (Globals._ldap_machine_suffix[0])
+		return append_ldap_suffix(ctx, Globals._ldap_machine_suffix);
+
+	return talloc_strdup(ctx, Globals.ldap_suffix);
+}
+
+const char *lp_ldap_user_suffix(TALLOC_CTX *ctx)
+{
+	if (Globals._ldap_user_suffix[0])
+		return append_ldap_suffix(ctx, Globals._ldap_user_suffix);
+
+	return talloc_strdup(ctx, Globals.ldap_suffix);
+}
+
+const char *lp_ldap_group_suffix(TALLOC_CTX *ctx)
+{
+	if (Globals._ldap_group_suffix[0])
+		return append_ldap_suffix(ctx, Globals._ldap_group_suffix);
+
+	return talloc_strdup(ctx, Globals.ldap_suffix);
+}
+
+const char *lp_ldap_idmap_suffix(TALLOC_CTX *ctx)
+{
+	if (Globals._ldap_idmap_suffix[0])
+		return append_ldap_suffix(ctx, Globals._ldap_idmap_suffix);
+
+	return talloc_strdup(ctx, Globals.ldap_suffix);
+}
+
+/**
+  return the parameter pointer for a parameter
+*/
+void *lp_parm_ptr(struct loadparm_service *service, struct parm_struct *parm)
+{
+	if (service == NULL) {
+		if (parm->p_class == P_LOCAL)
+			return (void *)(((char *)&sDefault)+parm->offset);
+		else if (parm->p_class == P_GLOBAL)
+			return (void *)(((char *)&Globals)+parm->offset);
+		else return NULL;
+	} else {
+		return (void *)(((char *)service) + parm->offset);
+	}
+}
+
+/***************************************************************************
+ Process a parameter for a particular service number. If snum < 0
+ then assume we are in the globals.
+***************************************************************************/
+
+bool lp_do_parameter(int snum, const char *pszParmName, const char *pszParmValue)
+{
+	TALLOC_CTX *frame = talloc_stackframe();
+	struct loadparm_context *lp_ctx;
+	bool ok;
+
+	lp_ctx = setup_lp_context(frame);
+	if (lp_ctx == NULL) {
+		TALLOC_FREE(frame);
+		return false;
+	}
+
+	if (snum < 0) {
+		ok = lpcfg_do_global_parameter(lp_ctx, pszParmName, pszParmValue);
+	} else {
+		ok = lpcfg_do_service_parameter(lp_ctx, ServicePtrs[snum],
+						pszParmName, pszParmValue);
+	}
+
+	TALLOC_FREE(frame);
+
+	return ok;
+}
+
+/***************************************************************************
+set a parameter, marking it with FLAG_CMDLINE. Parameters marked as
+FLAG_CMDLINE won't be overridden by loads from smb.conf.
+***************************************************************************/
+
+static bool lp_set_cmdline_helper(const char *pszParmName, const char *pszParmValue)
+{
+	int parmnum, i;
+	parmnum = lpcfg_map_parameter(pszParmName);
+	if (parmnum >= 0) {
+		flags_list[parmnum] &= ~FLAG_CMDLINE;
+		if (!lp_do_parameter(-1, pszParmName, pszParmValue)) {
+			return false;
+		}
+		flags_list[parmnum] |= FLAG_CMDLINE;
+
+		/* we have to also set FLAG_CMDLINE on aliases.  Aliases must
+		 * be grouped in the table, so we don't have to search the
+		 * whole table */
+		for (i=parmnum-1;
+		     i>=0 && parm_table[i].offset == parm_table[parmnum].offset
+			     && parm_table[i].p_class == parm_table[parmnum].p_class;
+		     i--) {
+			flags_list[i] |= FLAG_CMDLINE;
+		}
+		for (i=parmnum+1;i<num_parameters() && parm_table[i].offset == parm_table[parmnum].offset
+			     && parm_table[i].p_class == parm_table[parmnum].p_class;i++) {
+			flags_list[i] |= FLAG_CMDLINE;
+		}
+
+		return true;
+	}
+
+	/* it might be parametric */
+	if (strchr(pszParmName, ':') != NULL) {
+		set_param_opt(NULL, &Globals.param_opt, pszParmName, pszParmValue, FLAG_CMDLINE);
+		return true;
+	}
+
+	DEBUG(0, ("Ignoring unknown parameter \"%s\"\n",  pszParmName));
+	return false;
+}
+
+bool lp_set_cmdline(const char *pszParmName, const char *pszParmValue)
+{
+	bool ret;
+	TALLOC_CTX *frame = talloc_stackframe();
+	struct loadparm_context *lp_ctx;
+
+	lp_ctx = setup_lp_context(frame);
+	if (lp_ctx == NULL) {
+		TALLOC_FREE(frame);
+		return false;
+	}
+
+	ret = lpcfg_set_cmdline(lp_ctx, pszParmName, pszParmValue);
+
+	TALLOC_FREE(frame);
+	return ret;
+}
+
+/***************************************************************************
+ Process a parameter.
+***************************************************************************/
+
+static bool do_parameter(const char *pszParmName, const char *pszParmValue,
+			 void *userdata)
+{
+	if (!bInGlobalSection && bGlobalOnly)
+		return true;
+
+	DEBUGADD(4, ("doing parameter %s = %s\n", pszParmName, pszParmValue));
+
+	if (bInGlobalSection) {
+		return lpcfg_do_global_parameter(userdata, pszParmName, pszParmValue);
+	} else {
+		return lpcfg_do_service_parameter(userdata, ServicePtrs[iServiceIndex],
+						  pszParmName, pszParmValue);
+	}
+}
+
+
+static const char *ad_dc_req_vfs_mods[] = {"dfs_samba4", "acl_xattr", NULL};
+
+/*
+ * check that @vfs_objects includes all vfs modules required by an AD DC.
+ */
+static bool check_ad_dc_required_mods(const char **vfs_objects)
+{
+	int i;
+	int j;
+	int got_req;
+
+	for (i = 0; ad_dc_req_vfs_mods[i] != NULL; i++) {
+		got_req = false;
+		for (j = 0; vfs_objects[j] != NULL; j++) {
+			if (!strwicmp(ad_dc_req_vfs_mods[i], vfs_objects[j])) {
+				got_req = true;
+				break;
+			}
+		}
+		if (!got_req) {
+			DEBUG(0, ("vfs objects specified without required AD "
+				  "DC module: %s\n", ad_dc_req_vfs_mods[i]));
+			return false;
+		}
+	}
+
+	DEBUG(6, ("vfs objects specified with all required AD DC modules\n"));
+	return true;
+}
+
+
+/***************************************************************************
+ Initialize any local variables in the sDefault table, after parsing a
+ [globals] section.
+***************************************************************************/
+
+static void init_locals(void)
+{
+	/*
+	 * We run this check once the [globals] is parsed, to force
+	 * the VFS objects and other per-share settings we need for
+	 * the standard way a AD DC is operated.  We may change these
+	 * as our code evolves, which is why we force these settings.
+	 *
+	 * We can't do this at the end of lp_load_ex(), as by that
+	 * point the services have been loaded and they will already
+	 * have "" as their vfs objects.
+	 */
+	if (lp_server_role() == ROLE_ACTIVE_DIRECTORY_DC) {
+		const char **vfs_objects = lp_vfs_objects(-1);
+		if (vfs_objects != NULL) {
+			/* ignore return, only warn if modules are missing */
+			check_ad_dc_required_mods(vfs_objects);
+		} else {
+			if (lp_parm_const_string(-1, "xattr_tdb", "file", NULL)) {
+				lp_do_parameter(-1, "vfs objects", "dfs_samba4 acl_xattr xattr_tdb");
+			} else if (lp_parm_const_string(-1, "posix", "eadb", NULL)) {
+				lp_do_parameter(-1, "vfs objects", "dfs_samba4 acl_xattr posix_eadb");
+			} else {
+				lp_do_parameter(-1, "vfs objects", "dfs_samba4 acl_xattr");
+			}
+		}
+
+		lp_do_parameter(-1, "map hidden", "no");
+		lp_do_parameter(-1, "map system", "no");
+		lp_do_parameter(-1, "map readonly", "no");
+		lp_do_parameter(-1, "map archive", "no");
+		lp_do_parameter(-1, "store dos attributes", "yes");
+	}
+}
+
+/***************************************************************************
+ Process a new section (service). At this stage all sections are services.
+ Later we'll have special sections that permit server parameters to be set.
+ Returns true on success, false on failure.
+***************************************************************************/
+
+bool lp_do_section(const char *pszSectionName, void *userdata)
+{
+	struct loadparm_context *lp_ctx = (struct loadparm_context *)userdata;
+	bool bRetval;
+	bool isglobal = ((strwicmp(pszSectionName, GLOBAL_NAME) == 0) ||
+			 (strwicmp(pszSectionName, GLOBAL_NAME2) == 0));
+
+	/* if we were in a global section then do the local inits */
+	if (bInGlobalSection && !isglobal)
+		init_locals();
+
+	/* if we've just struck a global section, note the fact. */
+	bInGlobalSection = isglobal;
+	if (lp_ctx != NULL) {
+		lp_ctx->bInGlobalSection = isglobal;
+	}
+
+	/* check for multiple global sections */
+	if (bInGlobalSection) {
+		DEBUG(3, ("Processing section \"[%s]\"\n", pszSectionName));
+		return true;
+	}
+
+	if (!bInGlobalSection && bGlobalOnly)
+		return true;
+
+	/* if we have a current service, tidy it up before moving on */
+	bRetval = true;
+
+	if ((iServiceIndex >= 0) && (ServicePtrs[iServiceIndex] != NULL))
+		bRetval = lpcfg_service_ok(ServicePtrs[iServiceIndex]);
+
+	/* if all is still well, move to the next record in the services array */
+	if (bRetval) {
+		/* We put this here to avoid an odd message order if messages are */
+		/* issued by the post-processing of a previous section. */
+		DEBUG(2, ("Processing section \"[%s]\"\n", pszSectionName));
+
+		iServiceIndex = add_a_service(&sDefault, pszSectionName);
+		if (iServiceIndex < 0) {
+			DEBUG(0, ("Failed to add a new service\n"));
+			return false;
+		}
+		/* Clean all parametric options for service */
+		/* They will be added during parsing again */
+		free_param_opts(&ServicePtrs[iServiceIndex]->param_opt);
+	}
+
+	return bRetval;
+}
+
+/***************************************************************************
+ Display the contents of a parameter of a single services record.
+***************************************************************************/
+
+bool dump_a_parameter(int snum, char *parm_name, FILE * f, bool isGlobal)
+{
+	bool result = false;
+	struct loadparm_context *lp_ctx;
+
+	lp_ctx = setup_lp_context(talloc_tos());
+	if (lp_ctx == NULL) {
+		return false;
+	}
+
+	if (isGlobal) {
+		result = lpcfg_dump_a_parameter(lp_ctx, NULL, parm_name, f);
+	} else {
+		result = lpcfg_dump_a_parameter(lp_ctx, ServicePtrs[snum], parm_name, f);
+	}
+	TALLOC_FREE(lp_ctx);
+	return result;
+}
+
+#if 0
+/***************************************************************************
+ Display the contents of a single copy structure.
+***************************************************************************/
+static void dump_copy_map(bool *pcopymap)
+{
+	int i;
+	if (!pcopymap)
+		return;
+
+	printf("\n\tNon-Copied parameters:\n");
+
+	for (i = 0; parm_table[i].label; i++)
+		if (parm_table[i].p_class == P_LOCAL &&
+		    parm_table[i].ptr && !pcopymap[i] &&
+		    (i == 0 || (parm_table[i].ptr != parm_table[i - 1].ptr)))
+		{
+			printf("\t\t%s\n", parm_table[i].label);
+		}
+}
+#endif
+
+/***************************************************************************
+ Return TRUE if the passed service number is within range.
+***************************************************************************/
+
+bool lp_snum_ok(int iService)
+{
+	return (LP_SNUM_OK(iService) && ServicePtrs[iService]->available);
+}
+
+/***************************************************************************
+ Auto-load some home services.
+***************************************************************************/
+
+static void lp_add_auto_services(const char *str)
+{
+	char *s;
+	char *p;
+	int homes;
+	char *saveptr;
+
+	if (!str)
+		return;
+
+	s = talloc_strdup(talloc_tos(), str);
+	if (!s) {
+		smb_panic("talloc_strdup failed");
+		return;
+	}
+
+	homes = lp_servicenumber(HOMES_NAME);
+
+	for (p = strtok_r(s, LIST_SEP, &saveptr); p;
+	     p = strtok_r(NULL, LIST_SEP, &saveptr)) {
+		char *home;
+
+		if (lp_servicenumber(p) >= 0)
+			continue;
+
+		home = get_user_home_dir(talloc_tos(), p);
+
+		if (home && home[0] && homes >= 0)
+			lp_add_home(p, homes, p, home);
+
+		TALLOC_FREE(home);
+	}
+	TALLOC_FREE(s);
+}
+
+/***************************************************************************
+ Auto-load one printer.
+***************************************************************************/
+
+void lp_add_one_printer(const char *name, const char *comment,
+			const char *location, void *pdata)
+{
+	int printers = lp_servicenumber(PRINTERS_NAME);
+	int i;
+
+	if (lp_servicenumber(name) < 0) {
+		lp_add_printer(name, printers);
+		if ((i = lp_servicenumber(name)) >= 0) {
+			lpcfg_string_set(ServicePtrs[i],
+					 &ServicePtrs[i]->comment, comment);
+			ServicePtrs[i]->autoloaded = true;
+		}
+	}
+}
+
+/***************************************************************************
+ Have we loaded a services file yet?
+***************************************************************************/
+
+bool lp_loaded(void)
+{
+	return (bLoaded);
+}
+
+/***************************************************************************
+ Unload unused services.
+***************************************************************************/
+
+void lp_killunused(struct smbd_server_connection *sconn,
+		   bool (*snumused) (struct smbd_server_connection *, int))
+{
+	int i;
+	for (i = 0; i < iNumServices; i++) {
+		if (!VALID(i))
+			continue;
+
+		/* don't kill autoloaded or usershare services */
+		if ( ServicePtrs[i]->autoloaded ||
+				ServicePtrs[i]->usershare == USERSHARE_VALID) {
+			continue;
+		}
+
+		if (!snumused || !snumused(sconn, i)) {
+			free_service_byindex(i);
+		}
+	}
+}
+
+/**
+ * Kill all except autoloaded and usershare services - convenience wrapper
+ */
+void lp_kill_all_services(void)
+{
+	lp_killunused(NULL, NULL);
+}
+
+/***************************************************************************
+ Unload a service.
+***************************************************************************/
+
+void lp_killservice(int iServiceIn)
+{
+	if (VALID(iServiceIn)) {
+		free_service_byindex(iServiceIn);
+	}
+}
+
+/***************************************************************************
+ Save the curent values of all global and sDefault parameters into the
+ defaults union. This allows testparm to show only the
+ changed (ie. non-default) parameters.
+***************************************************************************/
+
+static void lp_save_defaults(void)
+{
+	int i;
+	struct parmlist_entry * parm;
+	for (i = 0; parm_table[i].label; i++) {
+		if (!(flags_list[i] & FLAG_CMDLINE)) {
+			flags_list[i] |= FLAG_DEFAULT;
+		}
+
+		if (i > 0 && parm_table[i].offset == parm_table[i - 1].offset
+		    && parm_table[i].p_class == parm_table[i - 1].p_class)
+			continue;
+		switch (parm_table[i].type) {
+			case P_LIST:
+			case P_CMDLIST:
+				parm_table[i].def.lvalue = str_list_copy(
+					NULL, *(const char ***)lp_parm_ptr(NULL, &parm_table[i]));
+				break;
+			case P_STRING:
+			case P_USTRING:
+				lpcfg_string_set(
+					Globals.ctx,
+					&parm_table[i].def.svalue,
+					*(char **)lp_parm_ptr(
+						NULL, &parm_table[i]));
+				if (parm_table[i].def.svalue == NULL) {
+					smb_panic("lpcfg_string_set() failed");
+				}
+				break;
+			case P_BOOL:
+			case P_BOOLREV:
+				parm_table[i].def.bvalue =
+					*(bool *)lp_parm_ptr(NULL, &parm_table[i]);
+				break;
+			case P_CHAR:
+				parm_table[i].def.cvalue =
+					*(char *)lp_parm_ptr(NULL, &parm_table[i]);
+				break;
+			case P_INTEGER:
+			case P_OCTAL:
+			case P_ENUM:
+			case P_BYTES:
+				parm_table[i].def.ivalue =
+					*(int *)lp_parm_ptr(NULL, &parm_table[i]);
+				break;
+		}
+	}
+
+	for (parm=Globals.param_opt; parm; parm=parm->next) {
+		if (!(parm->priority & FLAG_CMDLINE)) {
+			parm->priority |= FLAG_DEFAULT;
+		}
+	}
+
+	for (parm=sDefault.param_opt; parm; parm=parm->next) {
+		if (!(parm->priority & FLAG_CMDLINE)) {
+			parm->priority |= FLAG_DEFAULT;
+		}
+	}
+
+	defaults_saved = true;
+}
+
+/***********************************************************
+ If we should send plaintext/LANMAN passwords in the clinet
+************************************************************/
+
+static void set_allowed_client_auth(void)
+{
+	if (Globals.client_ntlmv2_auth) {
+		Globals.client_lanman_auth = false;
+	}
+	if (!Globals.client_lanman_auth) {
+		Globals.client_plaintext_auth = false;
+	}
+}
+
+/***************************************************************************
+ JRA.
+ The following code allows smbd to read a user defined share file.
+ Yes, this is my intent. Yes, I'm comfortable with that...
+
+ THE FOLLOWING IS SECURITY CRITICAL CODE.
+
+ It washes your clothes, it cleans your house, it guards you while you sleep...
+ Do not f%^k with it....
+***************************************************************************/
+
+#define MAX_USERSHARE_FILE_SIZE (10*1024)
+
+/***************************************************************************
+ Check allowed stat state of a usershare file.
+ Ensure we print out who is dicking with us so the admin can
+ get their sorry ass fired.
+***************************************************************************/
+
+static bool check_usershare_stat(const char *fname,
+				 const SMB_STRUCT_STAT *psbuf)
+{
+	if (!S_ISREG(psbuf->st_ex_mode)) {
+		DEBUG(0,("check_usershare_stat: file %s owned by uid %u is "
+			"not a regular file\n",
+			fname, (unsigned int)psbuf->st_ex_uid ));
+		return false;
+	}
+
+	/* Ensure this doesn't have the other write bit set. */
+	if (psbuf->st_ex_mode & S_IWOTH) {
+		DEBUG(0,("check_usershare_stat: file %s owned by uid %u allows "
+			"public write. Refusing to allow as a usershare file.\n",
+			fname, (unsigned int)psbuf->st_ex_uid ));
+		return false;
+	}
+
+	/* Should be 10k or less. */
+	if (psbuf->st_ex_size > MAX_USERSHARE_FILE_SIZE) {
+		DEBUG(0,("check_usershare_stat: file %s owned by uid %u is "
+			"too large (%u) to be a user share file.\n",
+			fname, (unsigned int)psbuf->st_ex_uid,
+			(unsigned int)psbuf->st_ex_size ));
+		return false;
+	}
+
+	return true;
+}
+
+/***************************************************************************
+ Parse the contents of a usershare file.
+***************************************************************************/
+
+enum usershare_err parse_usershare_file(TALLOC_CTX *ctx,
+			SMB_STRUCT_STAT *psbuf,
+			const char *servicename,
+			int snum,
+			char **lines,
+			int numlines,
+			char **pp_sharepath,
+			char **pp_comment,
+			char **pp_cp_servicename,
+			struct security_descriptor **ppsd,
+			bool *pallow_guest)
+{
+	const char **prefixallowlist = lp_usershare_prefix_allow_list();
+	const char **prefixdenylist = lp_usershare_prefix_deny_list();
+	int us_vers;
+	DIR *dp;
+	SMB_STRUCT_STAT sbuf;
+	char *sharepath = NULL;
+	char *comment = NULL;
+
+	*pp_sharepath = NULL;
+	*pp_comment = NULL;
+
+	*pallow_guest = false;
+
+	if (numlines < 4) {
+		return USERSHARE_MALFORMED_FILE;
+	}
+
+	if (strcmp(lines[0], "#VERSION 1") == 0) {
+		us_vers = 1;
+	} else if (strcmp(lines[0], "#VERSION 2") == 0) {
+		us_vers = 2;
+		if (numlines < 5) {
+			return USERSHARE_MALFORMED_FILE;
+		}
+	} else {
+		return USERSHARE_BAD_VERSION;
+	}
+
+	if (strncmp(lines[1], "path=", 5) != 0) {
+		return USERSHARE_MALFORMED_PATH;
+	}
+
+	sharepath = talloc_strdup(ctx, &lines[1][5]);
+	if (!sharepath) {
+		return USERSHARE_POSIX_ERR;
+	}
+	trim_string(sharepath, " ", " ");
+
+	if (strncmp(lines[2], "comment=", 8) != 0) {
+		return USERSHARE_MALFORMED_COMMENT_DEF;
+	}
+
+	comment = talloc_strdup(ctx, &lines[2][8]);
+	if (!comment) {
+		return USERSHARE_POSIX_ERR;
+	}
+	trim_string(comment, " ", " ");
+	trim_char(comment, '"', '"');
+
+	if (strncmp(lines[3], "usershare_acl=", 14) != 0) {
+		return USERSHARE_MALFORMED_ACL_DEF;
+	}
+
+	if (!parse_usershare_acl(ctx, &lines[3][14], ppsd)) {
+		return USERSHARE_ACL_ERR;
+	}
+
+	if (us_vers == 2) {
+		if (strncmp(lines[4], "guest_ok=", 9) != 0) {
+			return USERSHARE_MALFORMED_ACL_DEF;
+		}
+		if (lines[4][9] == 'y') {
+			*pallow_guest = true;
+		}
+
+		/* Backwards compatible extension to file version #2. */
+		if (numlines > 5) {
+			if (strncmp(lines[5], "sharename=", 10) != 0) {
+				return USERSHARE_MALFORMED_SHARENAME_DEF;
+			}
+			if (!strequal(&lines[5][10], servicename)) {
+				return USERSHARE_BAD_SHARENAME;
+			}
+			*pp_cp_servicename = talloc_strdup(ctx, &lines[5][10]);
+			if (!*pp_cp_servicename) {
+				return USERSHARE_POSIX_ERR;
+			}
+		}
+	}
+
+	if (*pp_cp_servicename == NULL) {
+		*pp_cp_servicename = talloc_strdup(ctx, servicename);
+		if (!*pp_cp_servicename) {
+			return USERSHARE_POSIX_ERR;
+		}
+	}
+
+	if (snum != -1 && (strcmp(sharepath, ServicePtrs[snum]->path) == 0)) {
+		/* Path didn't change, no checks needed. */
+		*pp_sharepath = sharepath;
+		*pp_comment = comment;
+		return USERSHARE_OK;
+	}
+
+	/* The path *must* be absolute. */
+	if (sharepath[0] != '/') {
+		DEBUG(2,("parse_usershare_file: share %s: path %s is not an absolute path.\n",
+			servicename, sharepath));
+		return USERSHARE_PATH_NOT_ABSOLUTE;
+	}
+
+	/* If there is a usershare prefix deny list ensure one of these paths
+	   doesn't match the start of the user given path. */
+	if (prefixdenylist) {
+		int i;
+		for ( i=0; prefixdenylist[i]; i++ ) {
+			DEBUG(10,("parse_usershare_file: share %s : checking prefixdenylist[%d]='%s' against %s\n",
+				servicename, i, prefixdenylist[i], sharepath ));
+			if (memcmp( sharepath, prefixdenylist[i], strlen(prefixdenylist[i])) == 0) {
+				DEBUG(2,("parse_usershare_file: share %s path %s starts with one of the "
+					"usershare prefix deny list entries.\n",
+					servicename, sharepath));
+				return USERSHARE_PATH_IS_DENIED;
+			}
+		}
+	}
+
+	/* If there is a usershare prefix allow list ensure one of these paths
+	   does match the start of the user given path. */
+
+	if (prefixallowlist) {
+		int i;
+		for ( i=0; prefixallowlist[i]; i++ ) {
+			DEBUG(10,("parse_usershare_file: share %s checking prefixallowlist[%d]='%s' against %s\n",
+				servicename, i, prefixallowlist[i], sharepath ));
+			if (memcmp( sharepath, prefixallowlist[i], strlen(prefixallowlist[i])) == 0) {
+				break;
+			}
+		}
+		if (prefixallowlist[i] == NULL) {
+			DEBUG(2,("parse_usershare_file: share %s path %s doesn't start with one of the "
+				"usershare prefix allow list entries.\n",
+				servicename, sharepath));
+			return USERSHARE_PATH_NOT_ALLOWED;
+		}
+        }
+
+	/* Ensure this is pointing to a directory. */
+	dp = opendir(sharepath);
+
+	if (!dp) {
+		DEBUG(2,("parse_usershare_file: share %s path %s is not a directory.\n",
+			servicename, sharepath));
+		return USERSHARE_PATH_NOT_DIRECTORY;
+	}
+
+	/* Ensure the owner of the usershare file has permission to share
+	   this directory. */
+
+	if (sys_stat(sharepath, &sbuf, false) == -1) {
+		DEBUG(2,("parse_usershare_file: share %s : stat failed on path %s. %s\n",
+			servicename, sharepath, strerror(errno) ));
+		closedir(dp);
+		return USERSHARE_POSIX_ERR;
+	}
+
+	closedir(dp);
+
+	if (!S_ISDIR(sbuf.st_ex_mode)) {
+		DEBUG(2,("parse_usershare_file: share %s path %s is not a directory.\n",
+			servicename, sharepath ));
+		return USERSHARE_PATH_NOT_DIRECTORY;
+	}
+
+	/* Check if sharing is restricted to owner-only. */
+	/* psbuf is the stat of the usershare definition file,
+	   sbuf is the stat of the target directory to be shared. */
+
+	if (lp_usershare_owner_only()) {
+		/* root can share anything. */
+		if ((psbuf->st_ex_uid != 0) && (sbuf.st_ex_uid != psbuf->st_ex_uid)) {
+			return USERSHARE_PATH_NOT_ALLOWED;
+		}
+	}
+
+	*pp_sharepath = sharepath;
+	*pp_comment = comment;
+	return USERSHARE_OK;
+}
+
+/***************************************************************************
+ Deal with a usershare file.
+ Returns:
+	>= 0 - snum
+	-1 - Bad name, invalid contents.
+	   - service name already existed and not a usershare, problem
+	    with permissions to share directory etc.
+***************************************************************************/
+
+static int process_usershare_file(const char *dir_name, const char *file_name, int snum_template)
+{
+	SMB_STRUCT_STAT sbuf;
+	SMB_STRUCT_STAT lsbuf;
+	char *fname = NULL;
+	char *sharepath = NULL;
+	char *comment = NULL;
+	char *cp_service_name = NULL;
+	char **lines = NULL;
+	int numlines = 0;
+	int fd = -1;
+	int iService = -1;
+	TALLOC_CTX *ctx = talloc_stackframe();
+	struct security_descriptor *psd = NULL;
+	bool guest_ok = false;
+	char *canon_name = NULL;
+	bool added_service = false;
+	int ret = -1;
+	NTSTATUS status;
+
+	/* Ensure share name doesn't contain invalid characters. */
+	if (!validate_net_name(file_name, INVALID_SHARENAME_CHARS, strlen(file_name))) {
+		DEBUG(0,("process_usershare_file: share name %s contains "
+			"invalid characters (any of %s)\n",
+			file_name, INVALID_SHARENAME_CHARS ));
+		goto out;
+	}
+
+	canon_name = canonicalize_servicename(ctx, file_name);
+	if (!canon_name) {
+		goto out;
+	}
+
+	fname = talloc_asprintf(ctx, "%s/%s", dir_name, file_name);
+	if (!fname) {
+		goto out;
+	}
+
+	/* Minimize the race condition by doing an lstat before we
+	   open and fstat. Ensure this isn't a symlink link. */
+
+	if (sys_lstat(fname, &lsbuf, false) != 0) {
+		if (errno == ENOENT) {
+			/* Unknown share requested. Just ignore. */
+			goto out;
+		}
+		/* Only log messages for meaningful problems. */
+		DEBUG(0,("process_usershare_file: stat of %s failed. %s\n",
+			fname, strerror(errno) ));
+		goto out;
+	}
+
+	/* This must be a regular file, not a symlink, directory or
+	   other strange filetype. */
+	if (!check_usershare_stat(fname, &lsbuf)) {
+		goto out;
+	}
+
+	{
+		TDB_DATA data;
+
+		status = dbwrap_fetch_bystring(ServiceHash, canon_name,
+					       canon_name, &data);
+
+		iService = -1;
+
+		if (NT_STATUS_IS_OK(status) &&
+		    (data.dptr != NULL) &&
+		    (data.dsize == sizeof(iService))) {
+			memcpy(&iService, data.dptr, sizeof(iService));
+		}
+	}
+
+	if (iService != -1 &&
+	    timespec_compare(&ServicePtrs[iService]->usershare_last_mod,
+			     &lsbuf.st_ex_mtime) == 0) {
+		/* Nothing changed - Mark valid and return. */
+		DEBUG(10,("process_usershare_file: service %s not changed.\n",
+			canon_name ));
+		ServicePtrs[iService]->usershare = USERSHARE_VALID;
+		ret = iService;
+		goto out;
+	}
+
+	/* Try and open the file read only - no symlinks allowed. */
+#ifdef O_NOFOLLOW
+	fd = open(fname, O_RDONLY|O_NOFOLLOW, 0);
+#else
+	fd = open(fname, O_RDONLY, 0);
+#endif
+
+	if (fd == -1) {
+		DEBUG(0,("process_usershare_file: unable to open %s. %s\n",
+			fname, strerror(errno) ));
+		goto out;
+	}
+
+	/* Now fstat to be *SURE* it's a regular file. */
+	if (sys_fstat(fd, &sbuf, false) != 0) {
+		close(fd);
+		DEBUG(0,("process_usershare_file: fstat of %s failed. %s\n",
+			fname, strerror(errno) ));
+		goto out;
+	}
+
+	/* Is it the same dev/inode as was lstated ? */
+	if (!check_same_stat(&lsbuf, &sbuf)) {
+		close(fd);
+		DEBUG(0,("process_usershare_file: fstat of %s is a different file from lstat. "
+			"Symlink spoofing going on ?\n", fname ));
+		goto out;
+	}
+
+	/* This must be a regular file, not a symlink, directory or
+	   other strange filetype. */
+	if (!check_usershare_stat(fname, &sbuf)) {
+		close(fd);
+		goto out;
+	}
+
+	lines = fd_lines_load(fd, &numlines, MAX_USERSHARE_FILE_SIZE, NULL);
+
+	close(fd);
+	if (lines == NULL) {
+		DEBUG(0,("process_usershare_file: loading file %s owned by %u failed.\n",
+			fname, (unsigned int)sbuf.st_ex_uid ));
+		goto out;
+	}
+
+	if (parse_usershare_file(ctx, &sbuf, file_name,
+			iService, lines, numlines, &sharepath,
+			&comment, &cp_service_name,
+			&psd, &guest_ok) != USERSHARE_OK) {
+		goto out;
+	}
+
+	/* Everything ok - add the service possibly using a template. */
+	if (iService < 0) {
+		const struct loadparm_service *sp = &sDefault;
+		if (snum_template != -1) {
+			sp = ServicePtrs[snum_template];
+		}
+
+		if ((iService = add_a_service(sp, cp_service_name)) < 0) {
+			DEBUG(0, ("process_usershare_file: Failed to add "
+				"new service %s\n", cp_service_name));
+			goto out;
+		}
+
+		added_service = true;
+
+		/* Read only is controlled by usershare ACL below. */
+		ServicePtrs[iService]->read_only = false;
+	}
+
+	/* Write the ACL of the new/modified share. */
+	status = set_share_security(canon_name, psd);
+	if (!NT_STATUS_IS_OK(status)) {
+		 DEBUG(0, ("process_usershare_file: Failed to set share "
+			"security for user share %s\n",
+			canon_name ));
+		goto out;
+	}
+
+	/* If from a template it may be marked invalid. */
+	ServicePtrs[iService]->valid = true;
+
+	/* Set the service as a valid usershare. */
+	ServicePtrs[iService]->usershare = USERSHARE_VALID;
+
+	/* Set guest access. */
+	if (lp_usershare_allow_guests()) {
+		ServicePtrs[iService]->guest_ok = guest_ok;
+	}
+
+	/* And note when it was loaded. */
+	ServicePtrs[iService]->usershare_last_mod = sbuf.st_ex_mtime;
+	lpcfg_string_set(ServicePtrs[iService], &ServicePtrs[iService]->path,
+			 sharepath);
+	lpcfg_string_set(ServicePtrs[iService],
+			 &ServicePtrs[iService]->comment, comment);
+
+	ret = iService;
+
+  out:
+
+	if (ret == -1 && iService != -1 && added_service) {
+		lp_remove_service(iService);
+	}
+
+	TALLOC_FREE(lines);
+	TALLOC_FREE(ctx);
+	return ret;
+}
+
+/***************************************************************************
+ Checks if a usershare entry has been modified since last load.
+***************************************************************************/
+
+static bool usershare_exists(int iService, struct timespec *last_mod)
+{
+	SMB_STRUCT_STAT lsbuf;
+	const char *usersharepath = Globals.usershare_path;
+	char *fname;
+
+	fname = talloc_asprintf(talloc_tos(),
+				"%s/%s",
+				usersharepath,
+				ServicePtrs[iService]->szService);
+	if (fname == NULL) {
+		return false;
+	}
+
+	if (sys_lstat(fname, &lsbuf, false) != 0) {
+		TALLOC_FREE(fname);
+		return false;
+	}
+
+	if (!S_ISREG(lsbuf.st_ex_mode)) {
+		TALLOC_FREE(fname);
+		return false;
+	}
+
+	TALLOC_FREE(fname);
+	*last_mod = lsbuf.st_ex_mtime;
+	return true;
+}
+
+static bool usershare_directory_is_root(uid_t uid)
+{
+	if (uid == 0) {
+		return true;
+	}
+
+	if (uid_wrapper_enabled()) {
+		return true;
+	}
+
+	return false;
+}
+
+/***************************************************************************
+ Load a usershare service by name. Returns a valid servicenumber or -1.
+***************************************************************************/
+
+int load_usershare_service(const char *servicename)
+{
+	SMB_STRUCT_STAT sbuf;
+	const char *usersharepath = Globals.usershare_path;
+	int max_user_shares = Globals.usershare_max_shares;
+	int snum_template = -1;
+
+	if (servicename[0] == '\0') {
+		/* Invalid service name. */
+		return -1;
+	}
+
+	if (*usersharepath == 0 ||  max_user_shares == 0) {
+		return -1;
+	}
+
+	if (sys_stat(usersharepath, &sbuf, false) != 0) {
+		DEBUG(0,("load_usershare_service: stat of %s failed. %s\n",
+			usersharepath, strerror(errno) ));
+		return -1;
+	}
+
+	if (!S_ISDIR(sbuf.st_ex_mode)) {
+		DEBUG(0,("load_usershare_service: %s is not a directory.\n",
+			usersharepath ));
+		return -1;
+	}
+
+	/*
+	 * This directory must be owned by root, and have the 't' bit set.
+	 * It also must not be writable by "other".
+	 */
+
+#ifdef S_ISVTX
+	if (!usershare_directory_is_root(sbuf.st_ex_uid) ||
+	    !(sbuf.st_ex_mode & S_ISVTX) || (sbuf.st_ex_mode & S_IWOTH)) {
+#else
+	if (!usershare_directory_is_root(sbuf.st_ex_uid) ||
+	    (sbuf.st_ex_mode & S_IWOTH)) {
+#endif
+		DEBUG(0,("load_usershare_service: directory %s is not owned by root "
+			"or does not have the sticky bit 't' set or is writable by anyone.\n",
+			usersharepath ));
+		return -1;
+	}
+
+	/* Ensure the template share exists if it's set. */
+	if (Globals.usershare_template_share[0]) {
+		/* We can't use lp_servicenumber here as we are recommending that
+		   template shares have -valid=false set. */
+		for (snum_template = iNumServices - 1; snum_template >= 0; snum_template--) {
+			if (ServicePtrs[snum_template]->szService &&
+					strequal(ServicePtrs[snum_template]->szService,
+						Globals.usershare_template_share)) {
+				break;
+			}
+		}
+
+		if (snum_template == -1) {
+			DEBUG(0,("load_usershare_service: usershare template share %s "
+				"does not exist.\n",
+				Globals.usershare_template_share ));
+			return -1;
+		}
+	}
+
+	return process_usershare_file(usersharepath, servicename, snum_template);
+}
+
+/***************************************************************************
+ Load all user defined shares from the user share directory.
+ We only do this if we're enumerating the share list.
+ This is the function that can delete usershares that have
+ been removed.
+***************************************************************************/
+
+int load_usershare_shares(struct smbd_server_connection *sconn,
+			  bool (*snumused) (struct smbd_server_connection *, int))
+{
+	DIR *dp;
+	SMB_STRUCT_STAT sbuf;
+	struct dirent *de;
+	int num_usershares = 0;
+	int max_user_shares = Globals.usershare_max_shares;
+	unsigned int num_dir_entries, num_bad_dir_entries, num_tmp_dir_entries;
+	unsigned int allowed_bad_entries = ((2*max_user_shares)/10);
+	unsigned int allowed_tmp_entries = ((2*max_user_shares)/10);
+	int iService;
+	int snum_template = -1;
+	const char *usersharepath = Globals.usershare_path;
+	int ret = lp_numservices();
+	TALLOC_CTX *tmp_ctx;
+
+	if (max_user_shares == 0 || *usersharepath == '\0') {
+		return lp_numservices();
+	}
+
+	if (sys_stat(usersharepath, &sbuf, false) != 0) {
+		DEBUG(0,("load_usershare_shares: stat of %s failed. %s\n",
+			usersharepath, strerror(errno) ));
+		return ret;
+	}
+
+	/*
+	 * This directory must be owned by root, and have the 't' bit set.
+	 * It also must not be writable by "other".
+	 */
+
+#ifdef S_ISVTX
+	if (sbuf.st_ex_uid != 0 || !(sbuf.st_ex_mode & S_ISVTX) || (sbuf.st_ex_mode & S_IWOTH)) {
+#else
+	if (sbuf.st_ex_uid != 0 || (sbuf.st_ex_mode & S_IWOTH)) {
+#endif
+		DEBUG(0,("load_usershare_shares: directory %s is not owned by root "
+			"or does not have the sticky bit 't' set or is writable by anyone.\n",
+			usersharepath ));
+		return ret;
+	}
+
+	/* Ensure the template share exists if it's set. */
+	if (Globals.usershare_template_share[0]) {
+		/* We can't use lp_servicenumber here as we are recommending that
+		   template shares have -valid=false set. */
+		for (snum_template = iNumServices - 1; snum_template >= 0; snum_template--) {
+			if (ServicePtrs[snum_template]->szService &&
+					strequal(ServicePtrs[snum_template]->szService,
+						Globals.usershare_template_share)) {
+				break;
+			}
+		}
+
+		if (snum_template == -1) {
+			DEBUG(0,("load_usershare_shares: usershare template share %s "
+				"does not exist.\n",
+				Globals.usershare_template_share ));
+			return ret;
+		}
+	}
+
+	/* Mark all existing usershares as pending delete. */
+	for (iService = iNumServices - 1; iService >= 0; iService--) {
+		if (VALID(iService) && ServicePtrs[iService]->usershare) {
+			ServicePtrs[iService]->usershare = USERSHARE_PENDING_DELETE;
+		}
+	}
+
+	dp = opendir(usersharepath);
+	if (!dp) {
+		DEBUG(0,("load_usershare_shares:: failed to open directory %s. %s\n",
+			usersharepath, strerror(errno) ));
+		return ret;
+	}
+
+	for (num_dir_entries = 0, num_bad_dir_entries = 0, num_tmp_dir_entries = 0;
+			(de = readdir(dp));
+			num_dir_entries++ ) {
+		int r;
+		const char *n = de->d_name;
+
+		/* Ignore . and .. */
+		if (*n == '.') {
+			if ((n[1] == '\0') || (n[1] == '.' && n[2] == '\0')) {
+				continue;
+			}
+		}
+
+		if (n[0] == ':') {
+			/* Temporary file used when creating a share. */
+			num_tmp_dir_entries++;
+		}
+
+		/* Allow 20% tmp entries. */
+		if (num_tmp_dir_entries > allowed_tmp_entries) {
+			DEBUG(0,("load_usershare_shares: too many temp entries (%u) "
+				"in directory %s\n",
+				num_tmp_dir_entries, usersharepath));
+			break;
+		}
+
+		r = process_usershare_file(usersharepath, n, snum_template);
+		if (r == 0) {
+			/* Update the services count. */
+			num_usershares++;
+			if (num_usershares >= max_user_shares) {
+				DEBUG(0,("load_usershare_shares: max user shares reached "
+					"on file %s in directory %s\n",
+					n, usersharepath ));
+				break;
+			}
+		} else if (r == -1) {
+			num_bad_dir_entries++;
+		}
+
+		/* Allow 20% bad entries. */
+		if (num_bad_dir_entries > allowed_bad_entries) {
+			DEBUG(0,("load_usershare_shares: too many bad entries (%u) "
+				"in directory %s\n",
+				num_bad_dir_entries, usersharepath));
+			break;
+		}
+
+		/* Allow 20% bad entries. */
+		if (num_dir_entries > max_user_shares + allowed_bad_entries) {
+			DEBUG(0,("load_usershare_shares: too many total entries (%u) "
+			"in directory %s\n",
+			num_dir_entries, usersharepath));
+			break;
+		}
+	}
+
+	closedir(dp);
+
+	/* Sweep through and delete any non-refreshed usershares that are
+	   not currently in use. */
+	tmp_ctx = talloc_stackframe();
+	for (iService = iNumServices - 1; iService >= 0; iService--) {
+		if (VALID(iService) && (ServicePtrs[iService]->usershare == USERSHARE_PENDING_DELETE)) {
+			const struct loadparm_substitution *lp_sub =
+				loadparm_s3_global_substitution();
+			char *servname;
+
+			if (snumused && snumused(sconn, iService)) {
+				continue;
+			}
+
+			servname = lp_servicename(tmp_ctx, lp_sub, iService);
+
+			/* Remove from the share ACL db. */
+			DEBUG(10,("load_usershare_shares: Removing deleted usershare %s\n",
+				  servname ));
+			delete_share_security(servname);
+			free_service_byindex(iService);
+		}
+	}
+	talloc_free(tmp_ctx);
+
+	return lp_numservices();
+}
+
+/********************************************************
+ Destroy global resources allocated in this file
+********************************************************/
+
+void gfree_loadparm(void)
+{
+	int i;
+
+	free_file_list();
+
+	/* Free resources allocated to services */
+
+	for ( i = 0; i < iNumServices; i++ ) {
+		if ( VALID(i) ) {
+			free_service_byindex(i);
+		}
+	}
+
+	TALLOC_FREE( ServicePtrs );
+	iNumServices = 0;
+
+	/* Now release all resources allocated to global
+	   parameters and the default service */
+
+	free_global_parameters();
+}
+
+
+/***************************************************************************
+ Allow client apps to specify that they are a client
+***************************************************************************/
+static void lp_set_in_client(bool b)
+{
+    in_client = b;
+}
+
+
+/***************************************************************************
+ Determine if we're running in a client app
+***************************************************************************/
+static bool lp_is_in_client(void)
+{
+    return in_client;
+}
+
+static void lp_enforce_ad_dc_settings(void)
+{
+	lp_do_parameter(GLOBAL_SECTION_SNUM, "passdb backend", "samba_dsdb");
+	lp_do_parameter(GLOBAL_SECTION_SNUM,
+			"winbindd:use external pipes", "true");
+	lp_do_parameter(GLOBAL_SECTION_SNUM, "rpc_server:default", "external");
+	lp_do_parameter(GLOBAL_SECTION_SNUM, "rpc_server:svcctl", "embedded");
+	lp_do_parameter(GLOBAL_SECTION_SNUM, "rpc_server:srvsvc", "embedded");
+	lp_do_parameter(GLOBAL_SECTION_SNUM, "rpc_server:eventlog", "embedded");
+	lp_do_parameter(GLOBAL_SECTION_SNUM, "rpc_server:ntsvcs", "embedded");
+	lp_do_parameter(GLOBAL_SECTION_SNUM, "rpc_server:winreg", "embedded");
+	lp_do_parameter(GLOBAL_SECTION_SNUM, "rpc_server:spoolss", "embedded");
+	lp_do_parameter(GLOBAL_SECTION_SNUM, "rpc_daemon:spoolssd", "embedded");
+	lp_do_parameter(GLOBAL_SECTION_SNUM, "rpc_server:tcpip", "no");
+}
+
+/***************************************************************************
+ Load the services array from the services file. Return true on success,
+ false on failure.
+***************************************************************************/
+
+static bool lp_load_ex(const char *pszFname,
+		       bool global_only,
+		       bool save_defaults,
+		       bool add_ipc,
+		       bool reinit_globals,
+		       bool allow_include_registry,
+		       bool load_all_shares)
+{
+	char *n2 = NULL;
+	bool bRetval;
+	TALLOC_CTX *frame = talloc_stackframe();
+	struct loadparm_context *lp_ctx;
+	int max_protocol, min_protocol;
+
+	DEBUG(3, ("lp_load_ex: refreshing parameters\n"));
+
+	bInGlobalSection = true;
+	bGlobalOnly = global_only;
+	bAllowIncludeRegistry = allow_include_registry;
+	sDefault = _sDefault;
+
+	lp_ctx = setup_lp_context(talloc_tos());
+
+	init_globals(lp_ctx, reinit_globals);
+
+	free_file_list();
+
+	if (save_defaults) {
+		init_locals();
+		lp_save_defaults();
+	}
+
+	if (!reinit_globals) {
+		free_param_opts(&Globals.param_opt);
+		apply_lp_set_cmdline();
+	}
+
+	lp_do_parameter(-1, "idmap config * : backend", Globals.idmap_backend);
+
+	/* We get sections first, so have to start 'behind' to make up */
+	iServiceIndex = -1;
+
+	if (lp_config_backend_is_file()) {
+		n2 = talloc_sub_basic(talloc_tos(), get_current_username(),
+					current_user_info.domain,
+					pszFname);
+		if (!n2) {
+			smb_panic("lp_load_ex: out of memory");
+		}
+
+		add_to_file_list(NULL, &file_lists, pszFname, n2);
+
+		bRetval = pm_process(n2, lp_do_section, do_parameter, lp_ctx);
+		TALLOC_FREE(n2);
+
+		/* finish up the last section */
+		DEBUG(4, ("pm_process() returned %s\n", BOOLSTR(bRetval)));
+		if (bRetval) {
+			if (iServiceIndex >= 0) {
+				bRetval = lpcfg_service_ok(ServicePtrs[iServiceIndex]);
+			}
+		}
+
+		if (lp_config_backend_is_registry()) {
+			bool ok;
+			/* config backend changed to registry in config file */
+			/*
+			 * We need to use this extra global variable here to
+			 * survive restart: init_globals uses this as a default
+			 * for config_backend. Otherwise, init_globals would
+			 *  send us into an endless loop here.
+			 */
+
+			config_backend = CONFIG_BACKEND_REGISTRY;
+			/* start over */
+			DEBUG(1, ("lp_load_ex: changing to config backend "
+				  "registry\n"));
+			init_globals(lp_ctx, true);
+
+			TALLOC_FREE(lp_ctx);
+
+			lp_kill_all_services();
+			ok = lp_load_ex(pszFname, global_only, save_defaults,
+					add_ipc, reinit_globals,
+					allow_include_registry,
+					load_all_shares);
+			TALLOC_FREE(frame);
+			return ok;
+		}
+	} else if (lp_config_backend_is_registry()) {
+		bRetval = process_registry_globals();
+	} else {
+		DEBUG(0, ("Illegal config  backend given: %d\n",
+			  lp_config_backend()));
+		bRetval = false;
+	}
+
+	if (bRetval && lp_registry_shares()) {
+		if (load_all_shares) {
+			bRetval = process_registry_shares();
+		} else {
+			bRetval = reload_registry_shares();
+		}
+	}
+
+	{
+		const struct loadparm_substitution *lp_sub =
+			loadparm_s3_global_substitution();
+		char *serv = lp_auto_services(talloc_tos(), lp_sub);
+		lp_add_auto_services(serv);
+		TALLOC_FREE(serv);
+	}
+
+	if (add_ipc) {
+		/* When 'restrict anonymous = 2' guest connections to ipc$
+		   are denied */
+		lp_add_ipc("IPC$", (lp_restrict_anonymous() < 2));
+		if ( lp_enable_asu_support() ) {
+			lp_add_ipc("ADMIN$", false);
+		}
+	}
+
+	set_allowed_client_auth();
+
+	if (lp_security() == SEC_ADS && strchr(lp_password_server(), ':')) {
+		DEBUG(1, ("WARNING: The optional ':port' in password server = %s is deprecated\n",
+			  lp_password_server()));
+	}
+
+	bLoaded = true;
+
+	/* Now we check we_are_a_wins_server and set szWINSserver to 127.0.0.1 */
+	/* if we_are_a_wins_server is true and we are in the client            */
+	if (lp_is_in_client() && Globals.we_are_a_wins_server) {
+		lp_do_parameter(GLOBAL_SECTION_SNUM, "wins server", "127.0.0.1");
+	}
+
+	init_iconv();
+
+	fault_configure(smb_panic_s3);
+
+	/*
+	 * We run this check once the whole smb.conf is parsed, to
+	 * force some settings for the standard way a AD DC is
+	 * operated.  We may change these as our code evolves, which
+	 * is why we force these settings.
+	 */
+	if (lp_server_role() == ROLE_ACTIVE_DIRECTORY_DC) {
+		lp_enforce_ad_dc_settings();
+	}
+
+	bAllowIncludeRegistry = true;
+
+	/* Check if command line max protocol < min protocol, if so
+	 * report a warning to the user.
+	 */
+	max_protocol = lp_client_max_protocol();
+	min_protocol = lp_client_min_protocol();
+	if (max_protocol < min_protocol) {
+		const char *max_protocolp, *min_protocolp;
+		max_protocolp = lpcfg_get_smb_protocol(max_protocol);
+		min_protocolp = lpcfg_get_smb_protocol(min_protocol);
+		DBG_ERR("Max protocol %s is less than min protocol %s.\n",
+			max_protocolp, min_protocolp);
+	}
+
+	TALLOC_FREE(frame);
+	return (bRetval);
+}
+
+static bool lp_load(const char *pszFname,
+		    bool global_only,
+		    bool save_defaults,
+		    bool add_ipc,
+		    bool reinit_globals)
+{
+	return lp_load_ex(pszFname,
+			  global_only,
+			  save_defaults,
+			  add_ipc,
+			  reinit_globals,
+			  true,   /* allow_include_registry */
+			  false); /* load_all_shares*/
+}
+
+bool lp_load_initial_only(const char *pszFname)
+{
+	return lp_load_ex(pszFname,
+			  true,   /* global only */
+			  true,   /* save_defaults */
+			  false,  /* add_ipc */
+			  true,   /* reinit_globals */
+			  false,  /* allow_include_registry */
+			  false); /* load_all_shares*/
+}
+
+/**
+ * most common lp_load wrapper, loading only the globals
+ *
+ * If this is used in a daemon or client utility it should be called
+ * after processing popt.
+ */
+bool lp_load_global(const char *file_name)
+{
+	return lp_load(file_name,
+		       true,   /* global_only */
+		       false,  /* save_defaults */
+		       false,  /* add_ipc */
+		       true);  /* reinit_globals */
+}
+
+/**
+ * The typical lp_load wrapper with shares, loads global and
+ * shares, including IPC, but does not force immediate
+ * loading of all shares from registry.
+ */
+bool lp_load_with_shares(const char *file_name)
+{
+	return lp_load(file_name,
+		       false,  /* global_only */
+		       false,  /* save_defaults */
+		       true,   /* add_ipc */
+		       true);  /* reinit_globals */
+}
+
+/**
+ * lp_load wrapper, especially for clients
+ */
+bool lp_load_client(const char *file_name)
+{
+	lp_set_in_client(true);
+
+	return lp_load_global(file_name);
+}
+
+/**
+ * lp_load wrapper, loading only globals, but intended
+ * for subsequent calls, not reinitializing the globals
+ * to default values
+ */
+bool lp_load_global_no_reinit(const char *file_name)
+{
+	return lp_load(file_name,
+		       true,   /* global_only */
+		       false,  /* save_defaults */
+		       false,  /* add_ipc */
+		       false); /* reinit_globals */
+}
+
+/**
+ * lp_load wrapper, loading globals and shares,
+ * intended for subsequent calls, i.e. not reinitializing
+ * the globals to default values.
+ */
+bool lp_load_no_reinit(const char *file_name)
+{
+	return lp_load(file_name,
+		       false,  /* global_only */
+		       false,  /* save_defaults */
+		       false,  /* add_ipc */
+		       false); /* reinit_globals */
+}
+
+
+/**
+ * lp_load wrapper, especially for clients, no reinitialization
+ */
+bool lp_load_client_no_reinit(const char *file_name)
+{
+	lp_set_in_client(true);
+
+	return lp_load_global_no_reinit(file_name);
+}
+
+bool lp_load_with_registry_shares(const char *pszFname)
+{
+	return lp_load_ex(pszFname,
+			  false, /* global_only */
+			  true,  /* save_defaults */
+			  false, /* add_ipc */
+			  true, /* reinit_globals */
+			  true,  /* allow_include_registry */
+			  true); /* load_all_shares*/
+}
+
+/***************************************************************************
+ Return the max number of services.
+***************************************************************************/
+
+int lp_numservices(void)
+{
+	return (iNumServices);
+}
+
+/***************************************************************************
+Display the contents of the services array in human-readable form.
+***************************************************************************/
+
+void lp_dump(FILE *f, bool show_defaults, int maxtoprint)
+{
+	int iService;
+	struct loadparm_context *lp_ctx;
+
+	if (show_defaults)
+		defaults_saved = false;
+
+	lp_ctx = setup_lp_context(talloc_tos());
+	if (lp_ctx == NULL) {
+		return;
+	}
+
+	lpcfg_dump_globals(lp_ctx, f, !defaults_saved);
+
+	lpcfg_dump_a_service(&sDefault, &sDefault, f, flags_list, show_defaults);
+
+	for (iService = 0; iService < maxtoprint; iService++) {
+		fprintf(f,"\n");
+		lp_dump_one(f, show_defaults, iService);
+	}
+	TALLOC_FREE(lp_ctx);
+}
+
+/***************************************************************************
+Display the contents of one service in human-readable form.
+***************************************************************************/
+
+void lp_dump_one(FILE * f, bool show_defaults, int snum)
+{
+	if (VALID(snum)) {
+		if (ServicePtrs[snum]->szService[0] == '\0')
+			return;
+		lpcfg_dump_a_service(ServicePtrs[snum], &sDefault, f,
+				     flags_list, show_defaults);
+	}
+}
+
+/***************************************************************************
+Return the number of the service with the given name, or -1 if it doesn't
+exist. Note that this is a DIFFERENT ANIMAL from the internal function
+getservicebyname()! This works ONLY if all services have been loaded, and
+does not copy the found service.
+***************************************************************************/
+
+int lp_servicenumber(const char *pszServiceName)
+{
+	int iService;
+        fstring serviceName;
+
+        if (!pszServiceName) {
+        	return GLOBAL_SECTION_SNUM;
+	}
+
+	for (iService = iNumServices - 1; iService >= 0; iService--) {
+		if (VALID(iService) && ServicePtrs[iService]->szService) {
+			/*
+			 * The substitution here is used to support %U in
+			 * service names
+			 */
+			fstrcpy(serviceName, ServicePtrs[iService]->szService);
+			standard_sub_basic(get_current_username(),
+					   current_user_info.domain,
+					   serviceName,sizeof(serviceName));
+			if (strequal(serviceName, pszServiceName)) {
+				break;
+			}
+		}
+	}
+
+	if (iService >= 0 && ServicePtrs[iService]->usershare == USERSHARE_VALID) {
+		struct timespec last_mod;
+
+		if (!usershare_exists(iService, &last_mod)) {
+			/* Remove the share security tdb entry for it. */
+			delete_share_security(lp_const_servicename(iService));
+			/* Remove it from the array. */
+			free_service_byindex(iService);
+			/* Doesn't exist anymore. */
+			return GLOBAL_SECTION_SNUM;
+		}
+
+		/* Has it been modified ? If so delete and reload. */
+		if (timespec_compare(&ServicePtrs[iService]->usershare_last_mod,
+				     &last_mod) < 0) {
+			/* Remove it from the array. */
+			free_service_byindex(iService);
+			/* and now reload it. */
+			iService = load_usershare_service(pszServiceName);
+		}
+	}
+
+	if (iService < 0) {
+		DEBUG(7,("lp_servicenumber: couldn't find %s\n", pszServiceName));
+		return GLOBAL_SECTION_SNUM;
+	}
+
+	return (iService);
+}
+
+/*******************************************************************
+ A useful volume label function.
+********************************************************************/
+
+const char *volume_label(TALLOC_CTX *ctx, int snum)
+{
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	char *ret;
+	const char *label = lp_volume(ctx, lp_sub, snum);
+	size_t end = 32;
+
+	if (!*label) {
+		label = lp_servicename(ctx, lp_sub, snum);
+	}
+
+	/*
+	 * Volume label can be a max of 32 bytes. Make sure to truncate
+	 * it at a codepoint boundary if it's longer than 32 and contains
+	 * multibyte characters. Windows insists on a volume label being
+	 * a valid mb sequence, and errors out if not.
+	 */
+	if (strlen(label) > 32) {
+		/*
+		 * A MB char can be a max of 5 bytes, thus
+		 * we should have a valid mb character at a
+		 * minimum position of (32-5) = 27.
+		 */
+		while (end >= 27) {
+			/*
+			 * Check if a codepoint starting from next byte
+			 * is valid. If yes, then the current byte is the
+			 * end of a MB or ascii sequence and the label can
+			 * be safely truncated here. If not, keep going
+			 * backwards till a valid codepoint is found.
+			 */
+			size_t len = 0;
+			const char *s = &label[end];
+			codepoint_t c = next_codepoint(s, &len);
+			if (c != INVALID_CODEPOINT) {
+				break;
+			}
+			end--;
+		}
+	}
+
+	/* This returns a max of 33 byte guarenteed null terminated string. */
+	ret = talloc_strndup(ctx, label, end);
+	if (!ret) {
+		return "";
+	}
+	return ret;
+}
+
+/*******************************************************************
+ Get the default server type we will announce as via nmbd.
+********************************************************************/
+
+int lp_default_server_announce(void)
+{
+	int default_server_announce = 0;
+	default_server_announce |= SV_TYPE_WORKSTATION;
+	default_server_announce |= SV_TYPE_SERVER;
+	default_server_announce |= SV_TYPE_SERVER_UNIX;
+
+	/* note that the flag should be set only if we have a
+	   printer service but nmbd doesn't actually load the
+	   services so we can't tell   --jerry */
+
+	default_server_announce |= SV_TYPE_PRINTQ_SERVER;
+
+	default_server_announce |= SV_TYPE_SERVER_NT;
+	default_server_announce |= SV_TYPE_NT;
+
+	switch (lp_server_role()) {
+		case ROLE_DOMAIN_MEMBER:
+			default_server_announce |= SV_TYPE_DOMAIN_MEMBER;
+			break;
+		case ROLE_DOMAIN_PDC:
+		case ROLE_IPA_DC:
+			default_server_announce |= SV_TYPE_DOMAIN_CTRL;
+			break;
+		case ROLE_DOMAIN_BDC:
+			default_server_announce |= SV_TYPE_DOMAIN_BAKCTRL;
+			break;
+		case ROLE_STANDALONE:
+		default:
+			break;
+	}
+	if (lp_time_server())
+		default_server_announce |= SV_TYPE_TIME_SOURCE;
+
+	if (lp_host_msdfs())
+		default_server_announce |= SV_TYPE_DFS_SERVER;
+
+	return default_server_announce;
+}
+
+/***********************************************************
+ If we are PDC then prefer us as DMB
+************************************************************/
+
+bool lp_domain_master(void)
+{
+	if (Globals._domain_master == Auto)
+		return (lp_server_role() == ROLE_DOMAIN_PDC ||
+			lp_server_role() == ROLE_IPA_DC);
+
+	return (bool)Globals._domain_master;
+}
+
+/***********************************************************
+ If we are PDC then prefer us as DMB
+************************************************************/
+
+static bool lp_domain_master_true_or_auto(void)
+{
+	if (Globals._domain_master) /* auto or yes */
+		return true;
+
+	return false;
+}
+
+/***********************************************************
+ If we are DMB then prefer us as LMB
+************************************************************/
+
+bool lp_preferred_master(void)
+{
+	int preferred_master = lp__preferred_master();
+
+	if (preferred_master == Auto)
+		return (lp_local_master() && lp_domain_master());
+
+	return (bool)preferred_master;
+}
+
+/*******************************************************************
+ Remove a service.
+********************************************************************/
+
+void lp_remove_service(int snum)
+{
+	ServicePtrs[snum]->valid = false;
+}
+
+const char *lp_printername(TALLOC_CTX *ctx,
+			   const struct loadparm_substitution *lp_sub,
+			   int snum)
+{
+	const char *ret = lp__printername(ctx, lp_sub, snum);
+
+	if (ret == NULL || *ret == '\0') {
+		ret = lp_const_servicename(snum);
+	}
+
+	return ret;
+}
+
+
+/***********************************************************
+ Allow daemons such as winbindd to fix their logfile name.
+************************************************************/
+
+void lp_set_logfile(const char *name)
+{
+	lpcfg_string_set(Globals.ctx, &Globals.logfile, name);
+	debug_set_logfile(name);
+}
+
+/*******************************************************************
+ Return the max print jobs per queue.
+********************************************************************/
+
+int lp_maxprintjobs(int snum)
+{
+	int maxjobs = lp_max_print_jobs(snum);
+
+	if (maxjobs <= 0 || maxjobs >= PRINT_MAX_JOBID)
+		maxjobs = PRINT_MAX_JOBID - 1;
+
+	return maxjobs;
+}
+
+const char *lp_printcapname(void)
+{
+	const char *printcap_name = lp_printcap_name();
+
+	if ((printcap_name != NULL) &&
+	    (printcap_name[0] != '\0'))
+		return printcap_name;
+
+	if (sDefault.printing == PRINT_CUPS) {
+		return "cups";
+	}
+
+	if (sDefault.printing == PRINT_BSD)
+		return "/etc/printcap";
+
+	return PRINTCAP_NAME;
+}
+
+static uint32_t spoolss_state;
+
+bool lp_disable_spoolss( void )
+{
+	if ( spoolss_state == SVCCTL_STATE_UNKNOWN )
+		spoolss_state = lp__disable_spoolss() ? SVCCTL_STOPPED : SVCCTL_RUNNING;
+
+	return spoolss_state == SVCCTL_STOPPED ? true : false;
+}
+
+void lp_set_spoolss_state( uint32_t state )
+{
+	SMB_ASSERT( (state == SVCCTL_STOPPED) || (state == SVCCTL_RUNNING) );
+
+	spoolss_state = state;
+}
+
+uint32_t lp_get_spoolss_state( void )
+{
+	return lp_disable_spoolss() ? SVCCTL_STOPPED : SVCCTL_RUNNING;
+}
+
+/*******************************************************************
+ Turn off sendfile if we find the underlying OS doesn't support it.
+********************************************************************/
+
+void set_use_sendfile(int snum, bool val)
+{
+	if (LP_SNUM_OK(snum))
+		ServicePtrs[snum]->_use_sendfile = val;
+	else
+		sDefault._use_sendfile = val;
+}
+
+void lp_set_mangling_method(const char *new_method)
+{
+	lpcfg_string_set(Globals.ctx, &Globals.mangling_method, new_method);
+}
+
+/*******************************************************************
+ Global state for POSIX pathname processing.
+********************************************************************/
+
+static bool posix_pathnames;
+
+bool lp_posix_pathnames(void)
+{
+	return posix_pathnames;
+}
+
+/*******************************************************************
+ Change everything needed to ensure POSIX pathname processing (currently
+ not much).
+********************************************************************/
+
+void lp_set_posix_pathnames(void)
+{
+	posix_pathnames = true;
+}
+
+/*******************************************************************
+ Global state for POSIX lock processing - CIFS unix extensions.
+********************************************************************/
+
+bool posix_default_lock_was_set;
+static enum brl_flavour posix_cifsx_locktype; /* By default 0 == WINDOWS_LOCK */
+
+enum brl_flavour lp_posix_cifsu_locktype(files_struct *fsp)
+{
+	if (posix_default_lock_was_set) {
+		return posix_cifsx_locktype;
+	} else {
+		return (fsp->posix_flags & FSP_POSIX_FLAGS_OPEN) ?
+			POSIX_LOCK : WINDOWS_LOCK;
+	}
+}
+
+/*******************************************************************
+********************************************************************/
+
+void lp_set_posix_default_cifsx_readwrite_locktype(enum brl_flavour val)
+{
+	posix_default_lock_was_set = true;
+	posix_cifsx_locktype = val;
+}
+
+int lp_min_receive_file_size(void)
+{
+	int min_receivefile_size = lp_min_receivefile_size();
+
+	if (min_receivefile_size < 0) {
+		return 0;
+	}
+	return min_receivefile_size;
+}
+
+/*******************************************************************
+ Safe wide links checks.
+ This helper function always verify the validity of wide links,
+ even after a configuration file reload.
+********************************************************************/
+
+void widelinks_warning(int snum)
+{
+	if (lp_allow_insecure_wide_links()) {
+		return;
+	}
+
+	if (lp_wide_links(snum)) {
+		if (lp_smb1_unix_extensions()) {
+			DBG_ERR("Share '%s' has wide links and SMB1 unix "
+			"extensions enabled. "
+			"These parameters are incompatible. "
+			"Wide links will be disabled for this share.\n",
+			 lp_const_servicename(snum));
+		} else if (lp_smb2_unix_extensions()) {
+			DBG_ERR("Share '%s' has wide links and SMB2 unix "
+			"extensions enabled. "
+			"These parameters are incompatible. "
+			"Wide links will be disabled for this share.\n",
+			 lp_const_servicename(snum));
+		}
+	}
+}
+
+bool lp_widelinks(int snum)
+{
+	/* wide links is always incompatible with unix extensions */
+	if (lp_smb1_unix_extensions() || lp_smb2_unix_extensions()) {
+		/*
+		 * Unless we have "allow insecure widelinks"
+		 * turned on.
+		 */
+		if (!lp_allow_insecure_wide_links()) {
+			return false;
+		}
+	}
+
+	return lp_wide_links(snum);
+}
+
+int lp_server_role(void)
+{
+	return lp_find_server_role(lp__server_role(),
+				   lp__security(),
+				   lp__domain_logons(),
+				   lp_domain_master_true_or_auto());
+}
+
+int lp_security(void)
+{
+	return lp_find_security(lp__server_role(),
+				lp__security());
+}
+
+int lp_client_max_protocol(void)
+{
+	int client_max_protocol = lp__client_max_protocol();
+	if (client_max_protocol == PROTOCOL_DEFAULT) {
+		return PROTOCOL_LATEST;
+	}
+	return client_max_protocol;
+}
+
+int lp_client_ipc_min_protocol(void)
+{
+	int client_ipc_min_protocol = lp__client_ipc_min_protocol();
+	if (client_ipc_min_protocol == PROTOCOL_DEFAULT) {
+		client_ipc_min_protocol = lp_client_min_protocol();
+	}
+	if (client_ipc_min_protocol < PROTOCOL_NT1) {
+		return PROTOCOL_NT1;
+	}
+	return client_ipc_min_protocol;
+}
+
+int lp_client_ipc_max_protocol(void)
+{
+	int client_ipc_max_protocol = lp__client_ipc_max_protocol();
+	if (client_ipc_max_protocol == PROTOCOL_DEFAULT) {
+		return PROTOCOL_LATEST;
+	}
+	if (client_ipc_max_protocol < PROTOCOL_NT1) {
+		return PROTOCOL_NT1;
+	}
+	return client_ipc_max_protocol;
+}
+
+int lp_client_ipc_signing(void)
+{
+	int client_ipc_signing = lp__client_ipc_signing();
+	if (client_ipc_signing == SMB_SIGNING_DEFAULT) {
+		return SMB_SIGNING_REQUIRED;
+	}
+	return client_ipc_signing;
+}
+
+enum credentials_use_kerberos lp_client_use_kerberos(void)
+{
+	if (lp_weak_crypto() == SAMBA_WEAK_CRYPTO_DISALLOWED) {
+		return CRED_USE_KERBEROS_REQUIRED;
+	}
+
+	return lp__client_use_kerberos();
+}
+
+
+int lp_rpc_low_port(void)
+{
+	return Globals.rpc_low_port;
+}
+
+int lp_rpc_high_port(void)
+{
+	return Globals.rpc_high_port;
+}
+
+/*
+ * Do not allow LanMan auth if unless NTLMv1 is also allowed
+ *
+ * This also ensures it is disabled if NTLM is totally disabled
+ */
+bool lp_lanman_auth(void)
+{
+	enum ntlm_auth_level ntlm_auth_level = lp_ntlm_auth();
+
+	if (ntlm_auth_level == NTLM_AUTH_ON) {
+		return lp__lanman_auth();
+	} else {
+		return false;
+	}
+}
+
+struct loadparm_global * get_globals(void)
+{
+	return &Globals;
+}
+
+unsigned int * get_flags(void)
+{
+	if (flags_list == NULL) {
+		flags_list = talloc_zero_array(NULL, unsigned int, num_parameters());
+	}
+
+	return flags_list;
+}
+
+enum samba_weak_crypto lp_weak_crypto(void)
+{
+	if (Globals.weak_crypto == SAMBA_WEAK_CRYPTO_UNKNOWN) {
+		Globals.weak_crypto = SAMBA_WEAK_CRYPTO_DISALLOWED;
+
+		if (samba_gnutls_weak_crypto_allowed()) {
+			Globals.weak_crypto = SAMBA_WEAK_CRYPTO_ALLOWED;
+		}
+	}
+
+	return Globals.weak_crypto;
+}
+
+uint32_t lp_get_async_dns_timeout(void)
+{
+	/*
+	 * Clamp minimum async dns timeout to 1 second
+	 * as per the man page.
+	 */
+	return MAX(Globals.async_dns_timeout, 1);
+}
+
+/* SMB2 POSIX extensions. For now, *always* disabled. */
+bool lp_smb2_unix_extensions(void)
+{
+	return false;
+}
diff --git a/source4/rpc_server/wscript_build b/source4/rpc_server/wscript_build
index 0e44a3c..31ec4f6 100644
--- a/source4/rpc_server/wscript_build
+++ b/source4/rpc_server/wscript_build
@@ -33,7 +33,8 @@ bld.SAMBA_MODULE('dcerpc_rpcecho',
                  source='echo/rpc_echo.c',
                  subsystem='dcerpc_server',
                  init_function='dcerpc_server_rpcecho_init',
-                 deps='ndr-standard events'
+                 deps='ndr-standard events',
+                 enabled=bld.CONFIG_GET('ENABLE_SELFTEST')
                  )
 
 
-- 
2.39.3

